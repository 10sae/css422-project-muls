00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/30/2021 6:01:27 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 000019FE             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29                     
00001014                            30              ;===TESTING===
00001014  4EB9 0000101A             31              JSR      testing
0000101A                            32              
0000101A                            33  ;===TESTING================            
0000101A                            34  testing:
0000101A                            35  
0000101A                            36  ;See what you can do with MOVEM
0000101A                            37  ;Implement the rest of the opcodes when the other members have them
0000101A                            38  
0000101A  0603 000C                 39              ADD.B       #12,D3
0000101E  0647 04D2                 40              ADD.W       #1234,D7
00001022  0684 00BC614E             41              ADD.L       #12345678,D4
00001028  0403 000C                 42              SUB.B       #12,D3
0000102C  0445 04D2                 43              SUB.W       #1234,D5
00001030  0486 00BC614E             44              SUB.L       #12345678,D6
00001036                            45              
00001036  0603 000C                 46              ADD.B       #12,D3
0000103A  DEB9 12345678             47              ADD.L       $12345678,D7
00001040  0647 04D2                 48              ADD.W       #1234,D7
00001044  0684 00BC614E             49              ADD.L       #12345678,D4
0000104A  0403 000C                 50              SUB.B       #12,D3
0000104E  0445 04D2                 51              SUB.W       #1234,D5
00001052  0486 00BC614E             52              SUB.L       #12345678,D6
00001058                            53              
00001058  11FC 000C 6788            54              MOVE.B      #12,$6788
0000105E  31FC 2654 4568            55              MOVE.W      #9812,$4568
00001064  21FC 00BD995F 4674        56              MOVE.L      #12425567,$4674
0000106C                            57              
0000106C                            58  
0000106C                            59              
0000106C                            60             
0000106C                            61              
0000106C                            62  ;==========================            
0000106C                            63              
0000106C                            64  startingPrompt:
0000106C                            65              ;Ask the user for the starting hex3
0000106C  43F9 00001A22             66              LEA         userSA,A1
00001072  103C 000E                 67              MOVE.B      #14,D0
00001076  4E4F                      68              TRAP        #15        
00001078                            69              
00001078                            70              ;Clear the registers in case we had an error
00001078  227C 00000000             71              MOVE.L      #0,A1
0000107E  247C 00000000             72              MOVE.L      #0,A2
00001084  4283                      73              CLR.L       D3
00001086  4284                      74              CLR.L       D4
00001088  4285                      75              CLR.L       D5
0000108A  4286                      76              CLR.L       D6
0000108C                            77             
0000108C                            78              
0000108C                            79              ;Input for the hex (D1 equals number of chars)
0000108C  303C 0002                 80              MOVE.W      #2,D0
00001090  4E4F                      81              TRAP        #15
00001092                            82              
00001092                            83              ;Moves A1 into A2      
00001092                            84              ;MOVEA.L     A1,A2
00001092                            85              
00001092                            86              ;Makes sure D7 is clear incase we're looping back after an error.
00001092  4207                      87              CLR.B       D7
00001094                            88              
00001094  6000 002A                 89              BRA         convert  
00001098                            90              
00001098                            91  endingPrompt:
00001098                            92              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001098  1E3C 0001                 93              MOVE.B       #1,D7
0000109C                            94              
0000109C                            95              ;Ask the user for the ending hex
0000109C  43F9 00001A64             96              LEA         userEA,A1
000010A2  103C 000E                 97              MOVE.B      #14,D0
000010A6  4E4F                      98              TRAP        #15
000010A8                            99              
000010A8                           100              ;Clearing the registers so we can reuse them for the ending address
000010A8  227C 00000000            101              MOVE.L      #0,A1
000010AE  247C 00000000            102              MOVE.L      #0,A2
000010B4  4286                     103              CLR.L       D6
000010B6                           104  
000010B6                           105              ;Input for the hex (D1 equals number of chars)
000010B6  303C 0002                106              MOVE.W      #2,D0
000010BA  4E4F                     107              TRAP        #15
000010BC                           108              
000010BC                           109              ;Moves A1 into A2      
000010BC                           110              ;MOVEA.L     A1,A2
000010BC                           111              
000010BC  6000 0002                112              BRA         convert
000010C0                           113  
000010C0                           114  convert:    
000010C0                           115              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
000010C0  B23C 0006                116              CMP.B       #6, D1
000010C4  6E00 0918                117              BGT         manyCharError  
000010C8                           118              
000010C8                           119              ;See if our counter variable is 0
000010C8  B23C 0000                120              CMP.B       #0,D1
000010CC                           121              
000010CC                           122              ;This means that we have gone through all the characters
000010CC  6700 0046                123              BEQ         moreChecks
000010D0                           124              
000010D0                           125              ;Decrement the counter, this means we're about to go through another char
000010D0  5301                     126              SUB.B       #1,D1
000010D2                           127  
000010D2                           128              ;Let's move the byte stored at A1
000010D2  1612                     129              MOVE.B      (A2),D3
000010D4                           130              
000010D4                           131              ;If the byte is greater than or equal to hex $40, then it's a letter
000010D4  B63C 0041                132              CMP.B       #$41,D3
000010D8  6C00 000A                133              BGE         letter
000010DC                           134              
000010DC                           135              ;If the byte is less than or equal to hex $39, then it's a number
000010DC  B63C 0040                136              CMP.B       #$40,D3
000010E0  6F00 0016                137              BLE         number
000010E4                           138              
000010E4                           139  letter:
000010E4                           140              ;We do this check to see if the character is greater than or equal 'G'
000010E4  B63C 0047                141              CMP.B       #$47,D3
000010E8                           142              ;If so, then display an error and ask the user to enter startingAdd again
000010E8  6C00 08D4                143              BGE         charError
000010EC                           144              
000010EC                           145              ;Subtract the Ascii value to convert to hex
000010EC  0403 0037                146              SUB.B       #$37,D3
000010F0                           147              ;Move the value back to our register
000010F0  14C3                     148              MOVE.B      D3,(A2)+
000010F2                           149              
000010F2                           150              ;Shift D5 left to make room for next hex value
000010F2  E986                     151              ASL.L       #4, D6
000010F4                           152              ;Move value to D5
000010F4  DC03                     153              ADD.B      D3, D6
000010F6                           154              
000010F6  60C8                     155              BRA         convert
000010F8                           156             
000010F8                           157  
000010F8                           158  number:          
000010F8                           159             ;We do this check to see if the character is less than or equal to '/'  
000010F8  B63C 002F                160             CMP.B        #$2F,D3
000010FC                           161             ;If so, then display an error and ask the user to enter startingAdd again
000010FC  6F00 08C0                162             BLE          charError     
00001100                           163   
00001100                           164             ;Check to see if the character is greater than or equal to ':'
00001100  B63C 003A                165             CMP.B        #$3A,D3
00001104                           166             ;If so, then display an error and ask the user to enter startingAdd again
00001104  6C00 08B8                167             BGE          charError
00001108                           168            
00001108                           169             ;Subtract the Ascii value to convert to hex
00001108  0403 0030                170             SUB.B        #$30,D3
0000110C                           171             ;Move the value back to our register
0000110C  14C3                     172             MOVE.B       D3,(A2)+
0000110E                           173   
0000110E                           174             ;Shift D5 left to make room for next hex value
0000110E  E986                     175             ASL.L        #4, D6
00001110                           176             ;Move value to D5
00001110  DC03                     177             ADD.B        D3, D6
00001112                           178              
00001112  60AC                     179             BRA          convert
00001114                           180   
00001114                           181            
00001114                           182  moreChecks:
00001114                           183              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
00001114  BE3C 0001                184              CMP.B      #1,D7
00001118  6700 0028                185              BEQ        moreChecks2
0000111C                           186              
0000111C  6000 0002                187              BRA        moreChecks1
00001120                           188   
00001120                           189  moreChecks1:
00001120                           190              
00001120                           191              ;Copy the hex value into a temp register
00001120  2806                     192              MOVE.L      D6,D4
00001122                           193              
00001122                           194              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001122  1A3C 001F                195              MOVE.B      #31,D5
00001126                           196              
00001126                           197              ;Shifts 31 bits, isolates last bit. 
00001126  EBAC                     198              LSL.L       D5,D4
00001128                           199  
00001128                           200              ;Shifts it back 31 bit, isolating the last bit. 
00001128  EAAC                     201              LSR.L       D5,D4
0000112A                           202  
0000112A                           203              ;If the last bit is 1, address was odd, and throw an error. 
0000112A  B83C 0001                204              CMP.B       #1,D4
0000112E  6700 089E                205              BEQ         oddError   
00001132                           206                          
00001132                           207              ;Reset address registers.
00001132  247C 00000000            208              MOVE.L      #0,A2
00001138                           209              
00001138                           210              ;Copy the value to our staHex variable
00001138  21C6 1000                211              MOVE.L      D6,staHex 
0000113C                           212              
0000113C  4286                     213              CLR.L       D6
0000113E  6000 FF58                214              BRA         endingPrompt     
00001142                           215              
00001142                           216  moreChecks2:       
00001142                           217              
00001142                           218              ;Copy the hex value into a temp register
00001142  2806                     219              MOVE.L      D6,D4
00001144                           220              
00001144                           221              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001144  1A3C 001F                222              MOVE.B      #31,D5
00001148                           223              
00001148                           224              ;Shifts 31 bits, isolates last bit. 
00001148  EBAC                     225              LSL.L       D5,D4
0000114A                           226  
0000114A                           227              ;Shifts it back 31 bit, isolating the last bit. 
0000114A  EAAC                     228              LSR.L       D5,D4
0000114C                           229  
0000114C                           230              ;If the last bit is 1, address was odd, and throw an error. 
0000114C  B83C 0001                231              CMP.B       #1,D4
00001150  6700 087C                232              BEQ         oddError   
00001154                           233                          
00001154                           234              ;Reset address registers.
00001154  247C 00000000            235              MOVE.L      #0,A2
0000115A                           236              
0000115A                           237              ;Place the value in our ending hex variable
0000115A  21C6 1004                238              MOVE.L      D6,endHex 
0000115E                           239              
0000115E                           240              ;Make D7 a temp location to compare our starting hex
0000115E  2E38 1000                241              MOVE.L      staHex,D7
00001162                           242           
00001162                           243              
00001162                           244              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001162  BC87                     245              CMP.L       D7,D6
00001164  6B00 0888                246              BMI         endGreater
00001168                           247              
00001168                           248              ;done, start reading memory. 
00001168                           249              
00001168                           250              ;Clear all the registers since we have the addresses stored in our variables
00001168  4283                     251              CLR.L       D3
0000116A  4285                     252              CLR.L       D5
0000116C  4286                     253              CLR.L       D6
0000116E  4287                     254              CLR.L       D7  
00001170                           255              
00001170                           256              ;Copy the value of our starting hex to A2 (temp register)
00001170  2478 1000                257              MOVEA.L     staHex,A2
00001174                           258                          
00001174                           259              
00001174                           260  LOOP:   
00001174                           261              ;We will be printing out the address, regardless if the opcode is valid or not
00001174  43F9 00001AA4            262              LEA         AddressNum,A1
0000117A  103C 000E                263              MOVE.B      #14,D0
0000117E  4E4F                     264              TRAP        #15
00001180                           265              
00001180                           266              ;Print out the address
00001180  700F                     267              MOVE.L      #15,D0
00001182  7410                     268              MOVE.L      #16,D2
00001184  220A                     269              MOVE.L      A2,D1
00001186  4E4F                     270              TRAP        #15
00001188                           271              
00001188  43F9 00001B4F            272              LEA         printSpace,A1
0000118E  103C 000E                273              MOVE.B      #14,D0
00001192  4E4F                     274              TRAP        #15
00001194                           275  
00001194                           276              ;--------------------------------------------------------
00001194                           277              ;Check for NOP or RTS
00001194                           278              ;--------------------------------------------------------
00001194                           279              
00001194                           280              ;Move the NOP binary value for comparing
00001194  243C 00004E71            281              MOVE.L      #%0100111001110001,D2
0000119A                           282              
0000119A                           283              ;Check and see i the instruction is NOP
0000119A  B452                     284              CMP.W       (A2),D2
0000119C  6700 0800                285              BEQ         printMNOP
000011A0                           286              
000011A0                           287              ;Move the RTS binary value for comparing
000011A0  243C 00004E75            288              MOVE.L      #%0100111001110101,D2
000011A6                           289              
000011A6                           290              ;Check and see if the instruction is RTS
000011A6  B452                     291              CMP.W       (A2),D2
000011A8  6700 0804                292              BEQ         printMRTS
000011AC                           293              
000011AC                           294              ;Clear the contents for reusing
000011AC  4282                     295              CLR.L       D2
000011AE                           296              
000011AE                           297              ;--------------------------------------------------------
000011AE                           298              ;Check for ADDI or SUBI, check for four 0's since it's the only
000011AE                           299              ;opcode with this pattern
000011AE                           300              ;--------------------------------------------------------  
000011AE                           301              ;Move the value in A2 to a temp register
000011AE  3412                     302              MOVE.W      (A2),D2
000011B0                           303              
000011B0                           304              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
000011B0  163C 000C                305              MOVE.B      #12,D3
000011B4  183C 0004                306              MOVE.B      #4,D4
000011B8                           307              
000011B8                           308              ;Jumps to getBits and returns with isolated bits in D2
000011B8  6100 0090                309              BSR         getBits
000011BC                           310              
000011BC  B43C 0000                311              CMP.B       #%0000,D2
000011C0  6700 009E                312              BEQ         M0000
000011C4                           313              
000011C4                           314              ;--------------------------------------------------------
000011C4                           315              ;Check for MOVE, since it's the only word starting with 00
000011C4                           316              ;--------------------------------------------------------            
000011C4                           317              ;Move the value in A2 to a temp register
000011C4  1412                     318              MOVE.B      (A2),D2
000011C6                           319              
000011C6                           320              ;Shift 6 bits to the right to isolate the left-most digits
000011C6  EC8A                     321              LSR.L       #6,D2
000011C8                           322              
000011C8                           323              ;If the first two bits (left-most) are 00, then the instruction is MOVE
000011C8  B43C 0000                324              CMP.B       #00,D2
000011CC  6F00 0166                325              BLE         M00
000011D0                           326              
000011D0                           327              ;Reuse the register
000011D0  4282                     328              CLR.L       D2
000011D2                           329              
000011D2                           330              
000011D2                           331              ;--------------------------------------------------------
000011D2                           332              ;Check for other OpCodes
000011D2                           333              ;--------------------------------------------------------
000011D2                           334              ;Move the word into a temp register 
000011D2  3412                     335              MOVE.W      (A2),D2
000011D4                           336              
000011D4                           337              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
000011D4  163C 000C                338              MOVE.B        #12,D3            ;Start bit index = 12
000011D8  183C 0004                339              MOVE.B        #4,D4             ;Number of bits needed = 4
000011DC                           340              
000011DC                           341              ;Jumps to getBits and returns with isolated bits in D2
000011DC  6100 006C                342              BSR           getBits            
000011E0                           343  
000011E0                           344              
000011E0                           345              ;MOVEM,LEA,NOT,JSR
000011E0  B43C 0004                346              CMP.B       #%0100,D2
000011E4  6700 01CC                347              BEQ         M0100
000011E8                           348              
000011E8                           349              ;BRA,BLT,BGE,BEQ
000011E8  B43C 0006                350              CMP.B       #%0110,D2
000011EC  6700 02A6                351              BEQ         M0110
000011F0                           352              
000011F0                           353              ;DIVU
000011F0  B43C 0008                354              CMP.B       #%1000,D2
000011F4  6700 029E                355              BEQ         M1000
000011F8                           356              
000011F8                           357              ;SUB
000011F8  B43C 0009                358              CMP.B       #%1001,D2
000011FC  6700 02C2                359              BEQ         M1001
00001200                           360              
00001200                           361              ;MULS,AND
00001200  B43C 000C                362              CMP.B       #%1100,D2
00001204  6700 02FE                363              BEQ         M1100
00001208                           364              
00001208                           365              ;LSL,LSR,ASL,ASR
00001208  B43C 000E                366              CMP.B       #%1110,D2
0000120C  6700 036A                367              BEQ         M1110
00001210                           368              
00001210                           369              ;ADD
00001210  B43C 000D                370              CMP.B       #%1101,D2
00001214  6700 051E                371              BEQ         M1101
00001218                           372              
00001218                           373              ;BSR         invalOpCode
00001218                           374              
00001218  6000 0A5F                375              BRA         ending
0000121C                           376              
0000121C                           377              
0000121C                           378              
0000121C                           379  
0000121C                           380  ;If time is allowed, we will get back to this. Otherwise we are 
0000121C                           381  ;focusing on valid input for testing
0000121C                           382  InOpCode:   
0000121C  43F9 00001C60            383              LEA         invalOpcode,A1
00001222  103C 000E                384              MOVE.B      #14,D0
00001226  4E4F                     385              TRAP        #15
00001228                           386              
00001228  700F                     387              MOVE.L      #15,D0
0000122A  7410                     388              MOVE.L      #16,D2
0000122C  220A                     389              MOVE.L      A2,D1
0000122E  4E4F                     390              TRAP        #15
00001230                           391              
00001230  6000 0002                392              BRA         update
00001234                           393              
00001234                           394             
00001234                           395  update:
00001234                           396              *=====Important if we've done any Immediate or Absolute addressing=====*
00001234                           397              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
00001234                           398              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
00001234                           399              ;because A2 always points at the the first word in an instruction (opcode).
00001234  B5CE                     400              CMP.L       A6,A2
00001236  6C00 0004                401              BGE         skipA6
0000123A                           402              
0000123A                           403              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
0000123A  244E                     404              MOVEA.L     A6,A2
0000123C                           405              
0000123C                           406  skipA6:
0000123C                           407              ;Check and see if we are at the ending hex
0000123C  B5F8 1004                408              CMP.L      endHex,A2
00001240  6E00 0A37                409              BGT        ending
00001244                           410  
00001244                           411              ;Update address in A2
00001244  544A                     412              ADDA.W      #2,A2
00001246                           413              
00001246                           414              
00001246  6000 FF2C                415              BRA        LOOP
0000124A                           416              
0000124A                           417              
0000124A                           418  getBits:
0000124A                           419              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
0000124A                           420              ;PARAMETERS:
0000124A                           421              ;D2 = the value the bits are extracted from & saved back in
0000124A                           422              ;D3 = the start bit index (starting from 0)
0000124A                           423              ;D4 = the number of bits we want to extract
0000124A                           424              
0000124A                           425              ;Calculate left shift
0000124A  3A3C 0010                426              MOVE.W      #16,D5
0000124E                           427              
0000124E  D843                     428              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
00001250  9A44                     429              SUB.W       D4,D5             ; 16 - X = leftShift
00001252                           430              
00001252  EB6A                     431              LSL.W       D5,D2
00001254                           432              
00001254                           433              
00001254                           434              ;Calculate right shift
00001254  DA43                     435              ADD.W       D3,D5             ; start bit + leftShift = X
00001256  EA6A                     436              LSR.W       D5,D2
00001258                           437              
00001258  4283                     438              CLR.L       D3
0000125A  4284                     439              CLR.L       D4
0000125C  4285                     440              CLR.L       D5   
0000125E  4E75                     441              RTS
00001260                           442  
00001260                           443  *-----------------------------------------------------------
00001260                           444  * 
00001260                           445  *
00001260                           446  *
00001260                           447  * OpCode Implementation
00001260                           448  *
00001260                           449  *
00001260                           450  *
00001260                           451  *-----------------------------------------------------------
00001260                           452  
00001260                           453  
00001260                           454  *-----------------------------------------------------------
00001260                           455  * ADDI/SUBI INSTRUCTION
00001260                           456  *-----------------------------------------------------------
00001260                           457  M0000:
00001260  4282                     458              CLR.L       D2
00001262  4283                     459              CLR.L       D3
00001264                           460              
00001264                           461              ;Copy the address values into a register to check for ADDI or SUBI
00001264  3412                     462              MOVE.W      (A2),D2
00001266                           463              
00001266                           464              ;Passing in paramters for isolating bits
00001266  163C 0008                465              MOVE.B      #8,D3
0000126A  183C 0004                466              MOVE.B      #4,D4
0000126E                           467              
0000126E                           468              ;Jumps to getBits and returns with isolated bits in D2
0000126E  61DA                     469              BSR         getBits
00001270                           470              
00001270                           471              ;--------------------------------------------------------
00001270                           472              ;Check for ADDI
00001270                           473              ;--------------------------------------------------------
00001270  B43C 0006                474              CMP.B       #%0110,D2
00001274  6700 000A                475              BEQ         MADDI
00001278                           476             
00001278                           477              ;--------------------------------------------------------
00001278                           478              ;Check for SUBI
00001278                           479              ;--------------------------------------------------------
00001278  B43C 0004                480              CMP.B       #%0100,D2
0000127C  6700 0036                481              BEQ         MSUBI
00001280                           482  
00001280                           483  MADDI:
00001280  43F9 00001AC3            484              LEA         printADDI,A1
00001286  103C 000E                485              MOVE.B      #14,D0
0000128A  4E4F                     486              TRAP        #15
0000128C                           487              
0000128C  4282                     488              CLR.L       D2
0000128E  4283                     489              CLR.L       D3
00001290                           490              
00001290                           491              ;======Isolate Size (S) Bits======
00001290                           492              ;Copy the address values into a register
00001290  3412                     493              MOVE.W      (A2),D2
00001292                           494              
00001292                           495              ;Passing in parameters for isolating size bits
00001292  163C 0006                496              MOVE.B      #6,D3
00001296  183C 0002                497              MOVE.B      #2,D4
0000129A                           498              
0000129A                           499              ;Jumps to getBits and returns with isolated bits in D2
0000129A  61AE                     500              BSR         getBits
0000129C                           501              
0000129C                           502              ;Jumps to printSizeSubroutine and returns after size has been printed
0000129C  6100 0560                503              BSR         printSizeSubroutine
000012A0                           504              
000012A0                           505              ;Let's store the size indicator since it will help us determine how many times
000012A0                           506              ;we have to iterate through addresses to print out the whole instruction
000012A0                           507              ;We will use A4 as the register to temporary store the size
000012A0  3842                     508              MOVE.W      D2,A4
000012A2  11C2 2000                509              MOVE.B      D2,$2000
000012A6                           510              
000012A6                           511              ;Clear the register so we can reuse it
000012A6  4282                     512              CLR.L       D2
000012A8                           513              
000012A8  1412                     514              MOVE.B      (A2),D2
000012AA                           515              
000012AA                           516              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012AA                           517              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012AA  264A                     518              MOVE.L      A2,A3
000012AC                           519              
000012AC  6100 003E                520              BSR         mEffect
000012B0                           521              
000012B0  4283                     522              CLR.L       D3
000012B2                           523              
000012B2  6080                     524              BRA         update
000012B4                           525              
000012B4                           526              
000012B4                           527  MSUBI:
000012B4  43F9 00001ACC            528              LEA         printSUBI,A1
000012BA  103C 000E                529              MOVE.B      #14,D0
000012BE  4E4F                     530              TRAP        #15
000012C0                           531              
000012C0  4282                     532              CLR.L       D2
000012C2  4283                     533              CLR.L       D3
000012C4                           534              
000012C4                           535              ;======Isolate Size (S) Bits======
000012C4                           536              ;Copy the address values into a register
000012C4  3412                     537              MOVE.W      (A2),D2
000012C6                           538              
000012C6                           539              ;Passing in parameters for isolating size bits
000012C6  163C 0006                540              MOVE.B      #6,D3
000012CA  183C 0002                541              MOVE.B      #2,D4
000012CE                           542              
000012CE                           543              ;Jumps to getBits and returns with isolated bits in D2
000012CE  6100 FF7A                544              BSR         getBits
000012D2                           545              
000012D2                           546              ;Jumps to printSizeSubroutine and returns after size has been printed
000012D2  6100 052A                547              BSR         printSizeSubroutine
000012D6                           548              
000012D6                           549              ;Let's store the size indicator since it will help us determine how many times
000012D6                           550              ;we have to iterate through addresses to print out the whole instruction
000012D6                           551              ;We will use A4 as the register to temporary store the size
000012D6  3842                     552              MOVE.W      D2,A4
000012D8  11C2 2000                553              MOVE.B      D2,$2000
000012DC                           554              
000012DC                           555              ;Clear the register so we can reuse it
000012DC  4282                     556              CLR.L       D2
000012DE                           557              
000012DE  1412                     558              MOVE.B      (A2),D2
000012E0                           559              
000012E0                           560              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012E0                           561              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012E0  264A                     562              MOVE.L      A2,A3
000012E2                           563              
000012E2  6100 0008                564              BSR         mEffect
000012E6                           565              
000012E6  4283                     566              CLR.L       D3
000012E8                           567              
000012E8  6000 FF4A                568              BRA         update
000012EC                           569  
000012EC                           570              
000012EC                           571  mEffect:
000012EC                           572              ;Male D6 #%111 since the source will always be an immediate value 
000012EC  1C3C 0007                573              MOVE.B      #7,D6
000012F0                           574              ;Make D7 #%100 since the source will always be an immediate value
000012F0  1E3C 0004                575              MOVE.B      #4,D7     
000012F4                           576  
000012F4                           577              ;Print source address
000012F4  6100 056A                578              BSR         addressModeSR
000012F8                           579              
000012F8                           580              ;Print the comma after the source address
000012F8  43F9 00001B4D            581              LEA        printComma,A1
000012FE  103C 000E                582              MOVE.B     #14,D0
00001302  4E4F                     583              TRAP       #15
00001304                           584              
00001304                           585              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001304  6100 0008                586              BSR        isoAddBit0to5
00001308                           587              
00001308                           588              ;Print source address
00001308  6100 0556                589              BSR        addressModeSR
0000130C                           590              
0000130C  4E75                     591              RTS            
0000130E                           592              
0000130E                           593              
0000130E                           594  isoAddBit0to5:
0000130E                           595              ;===Isolate the Destination Mode (M)Bits===
0000130E  4282                     596              CLR.L      D2
00001310                           597              
00001310                           598              ;Copy the address value into a register
00001310  3413                     599              MOVE.W     (A3),D2
00001312                           600              
00001312                           601              ;Passing in parameters for isolating Mode bits
00001312  163C 0003                602              MOVE.B     #3,D3
00001316  183C 0003                603              MOVE.B     #3,D4
0000131A                           604              
0000131A                           605              ;Jumps to getBits and returns with isolated bits in D2
0000131A  4EB8 124A                606              JSR        getBits
0000131E                           607              
0000131E                           608              ;Save M bit into ***D6*** for later use in addressModeSubroutine
0000131E  1C02                     609              MOVE.B     D2,D6
00001320                           610              
00001320                           611              ;===Isolate the Destination Address Register (Xn)Bits===
00001320  4282                     612              CLR.L      D2
00001322                           613              
00001322                           614              ;Copy the address values into a register
00001322  3413                     615              MOVE.W     (A3),D2
00001324                           616              
00001324                           617              ;Passing in parameters for isolating Xn bits
00001324  163C 0000                618              MOVE.B     #0,D3
00001328  183C 0003                619              MOVE.B     #3,D4
0000132C                           620              
0000132C                           621              ;Jumps to getBits and returns with isolated bits in D2
0000132C  4EB8 124A                622              JSR        getBits
00001330                           623              
00001330                           624              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001330  1E02                     625              MOVE.B      D2,D7
00001332                           626  
00001332  4E75                     627              RTS
00001334                           628              
00001334                           629  *-----------------------------------------------------------
00001334                           630  * MOVE INSTRUCTION
00001334                           631  *-----------------------------------------------------------
00001334                           632  M00:
00001334  43F9 00001AB4            633              LEA        printMOVE,A1
0000133A  103C 000E                634              MOVE.B     #14,D0
0000133E  4E4F                     635              TRAP       #15
00001340                           636              
00001340  4202                     637              CLR.B      D2
00001342  4203                     638              CLR.B      D3
00001344                           639              
00001344                           640              ;======Isolate Size (S) Bits=======
00001344                           641              ;Copy the address values into a register
00001344  3412                     642              MOVE.W     (A2),D2
00001346                           643              
00001346                           644              ;Passing in parameters for isolating size bits 12,13
00001346  163C 000C                645              MOVE.B      #12,D3             
0000134A  183C 0002                646              MOVE.B      #2,D4             
0000134E                           647              
0000134E                           648              ;Jumps to getBits and returns with isolated bits in D2
0000134E  6100 FEFA                649              BSR         getBits  
00001352                           650              
00001352                           651              ;Indicate to our print function we are doing this for the MOVE opcode
00001352  163C 0001                652              MOVE.B      #1,D3
00001356                           653              
00001356                           654              ;Jumps to printSizeSubroutine and returns after size has been printed
00001356  6100 04A6                655              BSR         printSizeSubroutine
0000135A                           656              
0000135A                           657              ;Let's store the size indicator since it will help us determine how many times
0000135A                           658              ;we have to iterate through addresses to print out the whole instruction
0000135A                           659              ;We will use A4 as the register to temporary store the size
0000135A  3842                     660              MOVE.W      D2,A4
0000135C  11C2 2000                661              MOVE.B      D2,$2000
00001360                           662  
00001360                           663              ;Clear the register so we can reuse it
00001360  4282                     664              CLR.L       D2
00001362                           665              
00001362  3412                     666              MOVE.W      (A2),D2
00001364                           667              
00001364                           668              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
00001364                           669              ;This is meant so we can use the copy to figure out the destination addressing mode
00001364  264A                     670              MOVE.L      A2,A3
00001366                           671  
00001366  6000 0002                672              BRA         mSourceDest
0000136A                           673              
0000136A                           674            
0000136A                           675  ;======Helper function to find the destination for MOVE======
0000136A                           676  mSourceDest:
0000136A                           677              ;SOURCE
0000136A                           678              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000136A  6100 0454                679              BSR        isolateAddressBit0to5
0000136E                           680              
0000136E                           681              ;Print source address
0000136E  6100 04F0                682              BSR        addressModeSR
00001372                           683              
00001372                           684              ;Print the comma after the source address
00001372  43F9 00001B4D            685              LEA        printComma,A1
00001378  103C 000E                686              MOVE.B     #14,D0
0000137C  4E4F                     687              TRAP       #15
0000137E                           688              
0000137E                           689              ;DESTINATION
0000137E                           690              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000137E  6100 000C                691              BSR        isolateAddressBit6to11
00001382                           692              
00001382                           693              ;Print destination address
00001382  6100 04DC                694              BSR        addressModeSR
00001386                           695              
00001386  4283                     696              CLR.L      D3
00001388                           697              
00001388  6000 FEAA                698              BRA        update
0000138C                           699              
0000138C                           700  
0000138C                           701  isolateAddressBit6to11:
0000138C                           702              ;===Isolate the Destination Mode (M)Bits===
0000138C  4282                     703              CLR.L      D2
0000138E                           704              
0000138E                           705              ;Copy the address value into a register
0000138E  3413                     706              MOVE.W     (A3),D2
00001390                           707              
00001390                           708              ;Passing in parameters for isolating Mode bits
00001390  163C 0006                709              MOVE.B     #6,D3
00001394  183C 0003                710              MOVE.B     #3,D4
00001398                           711              
00001398                           712              ;Jumps to getBits and returns with isolated bits in D2
00001398  4EB8 124A                713              JSR        getBits
0000139C                           714              
0000139C                           715              ;Save M bit into ***D6*** for later use in addressModeSubroutine
0000139C  1C02                     716              MOVE.B     D2,D6
0000139E                           717              
0000139E                           718              ;===Isolate the Destination Address Register (Xn)Bits===
0000139E  4282                     719              CLR.L      D2
000013A0                           720              
000013A0                           721              ;Copy the address values into a register
000013A0  3413                     722              MOVE.W     (A3),D2
000013A2                           723              
000013A2                           724              ;Passing in parameters for isolating Xn bits
000013A2  163C 0009                725              MOVE.B     #9,D3
000013A6  183C 0003                726              MOVE.B     #3,D4
000013AA                           727              
000013AA                           728              ;Jumps to getBits and returns with isolated bits in D2
000013AA  4EB8 124A                729              JSR        getBits
000013AE                           730              
000013AE                           731              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000013AE  1E02                     732              MOVE.B      D2,D7
000013B0                           733  
000013B0  4E75                     734              RTS
000013B2                           735              
000013B2                           736              
000013B2                           737  *-----------------------------------------------------------
000013B2                           738  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
000013B2                           739  *-----------------------------------------------------------
000013B2                           740  M0100:      
000013B2  4282                     741              CLR.L       D2
000013B4  4283                     742              CLR.L       D3
000013B6                           743              
000013B6                           744              ;--------------------------------------------------------
000013B6                           745              ;Check for LEA
000013B6                           746              ;--------------------------------------------------------
000013B6                           747              ;Copy the address values into a register to check for LEA
000013B6  3412                     748              MOVE.W     (A2),D2
000013B8                           749              
000013B8                           750              ;Passing in parameters for isolating bits 6,7,8
000013B8  163C 0006                751              MOVE.B      #6,D3             ;Start bit index = 6
000013BC  183C 0003                752              MOVE.B      #3,D4             ;Number of bits needed = 3
000013C0                           753              
000013C0                           754              ;Jumps to getBits and returns with isolated bits in D2
000013C0  6100 FE88                755              BSR         getBits
000013C4                           756  
000013C4  B43C 0007                757              CMP.B       #%111,D2
000013C8  6700 0056                758              BEQ         MLEA
000013CC                           759  
000013CC                           760              ;--------------------------------------------------------
000013CC                           761              ;Check for NOT
000013CC                           762              ;--------------------------------------------------------
000013CC                           763              ;Clear D2 and recopy it to check for NOT
000013CC  4282                     764              CLR.L       D2
000013CE  3412                     765              MOVE.W      (A2),D2
000013D0                           766              
000013D0                           767              ;Pass in parameters for isolating bits 8,9,10,11
000013D0  163C 0008                768              MOVE.B      #8,D3
000013D4  183C 0004                769              MOVE.B      #4,D4
000013D8                           770              
000013D8                           771              ;Jumps to getBits and returns with isolated bits in D2
000013D8  6100 FE70                772              BSR         getBits
000013DC                           773              
000013DC  B43C 0006                774              CMP.B       #%0110,D2
000013E0  6700 006E                775              BEQ         MNOT      
000013E4                           776              
000013E4                           777              ;--------------------------------------------------------
000013E4                           778              ;Check for JSR
000013E4                           779              ;--------------------------------------------------------
000013E4                           780              ;Clear D2 and recopy it to check for JSR
000013E4  4282                     781              CLR.L       D2
000013E6  3412                     782              MOVE.W     (A2),D2
000013E8                           783              
000013E8                           784              ;Pass in parameters for isolating bits 6-11
000013E8  163C 0006                785              MOVE.B      #6,D3
000013EC  183C 0006                786              MOVE.B      #6,D4
000013F0                           787              
000013F0                           788              ;Jumps to getBits and returns with isolated bits in D2
000013F0  6100 FE58                789              BSR         getBits
000013F4                           790              
000013F4  B43C 003A                791              CMP.B       #%111010,D2
000013F8  6700 0082                792              BEQ         MJSR
000013FC                           793              
000013FC                           794              ;--------------------------------------------------------
000013FC                           795              ;Check for MOVEM
000013FC                           796              ;--------------------------------------------------------
000013FC                           797              ;Clear D2 and recopy it to check for MOVEM
000013FC  4282                     798              CLR.L       D2
000013FE  3412                     799              MOVE.W     (A2),D2
00001400                           800              
00001400                           801              ;Pass in parameters for isolating bit 9
00001400  163C 0009                802              MOVE.B      #9,D3
00001404  183C 0001                803              MOVE.B      #1,D4
00001408                           804              
00001408                           805              ;Jumps to getBits and returns with isolated bits in D2
00001408  6100 FE40                806              BSR         getBits
0000140C                           807              
0000140C  B43C 0000                808              CMP.B       #%0,D2
00001410  6700 0002                809              BEQ         MOVEM
00001414                           810              
00001414                           811         
00001414                           812  MOVEM:
00001414                           813              *******************
00001414                           814              *Must finish!!!!!!
00001414                           815              *******************
00001414                           816              *******************
00001414                           817  
00001414                           818  *******************
00001414                           819  
00001414                           820  *******************
00001414                           821  
00001414                           822  *******************
00001414                           823  
00001414                           824  *******************
00001414                           825  
00001414                           826  
00001414  43F9 00001AB9            827              LEA         printMOVEM,A1
0000141A  1038 0014                828              MOVE.B      $14,D0
0000141E  4E4F                     829              TRAP        #15
00001420                           830  
00001420                           831  
00001420                           832  MLEA:
00001420  43F9 00001AE1            833              LEA         printLEA,A1
00001426  103C 000E                834              MOVE.B      #14,D0
0000142A  4E4F                     835              TRAP        #15
0000142C                           836              
0000142C                           837              ;*SOURCE*
0000142C                           838              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000142C                           839              ;D6 will contain mode & D7 will contain the register after this instruction
0000142C  6100 0392                840              BSR         isolateAddressBit0to5
00001430                           841              
00001430                           842              ;*Print source address*
00001430  6100 042E                843              BSR         addressModeSR
00001434                           844              
00001434                           845              ;Print comma after source address
00001434  43F9 00001B4D            846              LEA         printComma,A1
0000143A  103C 000E                847              MOVE.B      #14,D0
0000143E  4E4F                     848              TRAP        #15
00001440                           849              
00001440                           850              ;*DESTINATION*
00001440                           851              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001440                           852              ;D7 will contain the register after this instruction
00001440  6100 03A4                853              BSR         isolateRegisterBit9to11
00001444                           854              
00001444                           855              ;Save #%001 into D6 to specify address register mode
00001444  1C3C 0001                856              MOVE.B      #1,D6
00001448                           857              
00001448                           858              
00001448                           859              ;*Print destination address*
00001448  6100 0416                860              BSR         addressModeSR
0000144C                           861  
0000144C  6000 FDE6                862              BRA        update
00001450                           863  
00001450                           864  MNOT:
00001450                           865              ;Distinguish NOT from "MOVE to SSR"                 
00001450                           866              
00001450  4282                     867              CLR.L      D2
00001452                           868              ;Move the address into the register to check for size
00001452  3412                     869              MOVE.W     (A2),D2
00001454                           870              
00001454                           871              ;Pass in parameters for isolating bits 6,7
00001454  163C 0006                872              MOVE.B     #6,D3
00001458  183C 0002                873              MOVE.B     #2,D4
0000145C                           874              
0000145C                           875              ;Jump to getbits and return with isolated bits
0000145C  6100 FDEC                876              BSR        getbits
00001460                           877  
00001460                           878              ;This was meant for invalid opcode testing
00001460                           879              ;CMP.B      #%11,D2
00001460                           880              ;BRA        InOpCode     
00001460                           881  
00001460  43F9 00001AEA            882              LEA        printNOT,A1
00001466  103C 000E                883              MOVE.B     #14,D0
0000146A  4E4F                     884              TRAP       #15    
0000146C                           885              
0000146C                           886              ;Jumps to printSizeSubroutine and returns after size has been printed
0000146C  6100 0390                887              BSR        printSizeSubroutine
00001470                           888              
00001470                           889              ;*SOURCE*
00001470                           890              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001470                           891              ;D6 will contain mode & D7 will contain the register after this instruction
00001470  6100 034E                892              BSR        isolateAddressBit0to5
00001474                           893              
00001474                           894              ;*Print source address*
00001474  6100 03EA                895              BSR        addressModeSR
00001478                           896              
00001478  6000 FDBA                897              BRA        update 
0000147C                           898  
0000147C                           899  MJSR:
0000147C  43F9 00001B0A            900              LEA        printJSR,A1
00001482  103C 000E                901              MOVE.B     #14,D0
00001486  4E4F                     902              TRAP       #15
00001488                           903              
00001488                           904              ;*SOURCE*
00001488                           905              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001488                           906              ;D6 will contain mode & D7 will contain the register after this instruction
00001488  6100 0336                907              BSR        isolateAddressBit0to5
0000148C                           908              
0000148C                           909              ;*Print source address*
0000148C  6100 03D2                910              BSR        addressModeSR
00001490                           911              
00001490  6000 FDA2                912              BRA        update 
00001494                           913              
00001494                           914  
00001494                           915  *-----------------------------------------------------------
00001494                           916  * BRA,BLT,BGE,BEQ INSTRUCTIONS
00001494                           917  *-----------------------------------------------------------       
00001494                           918  M0110:
00001494                           919              ;
00001494                           920  MBRA:
00001494                           921  MBLT:
00001494                           922  MBGE:
00001494                           923  MBEQ:            
00001494                           924              
00001494                           925  
00001494                           926  *-----------------------------------------------------------
00001494                           927  * DIVU INSTRUCTION
00001494                           928  *-----------------------------------------------------------           
00001494                           929  M1000:
00001494                           930              
00001494  4282                     931              CLR.L       D2
00001496  4283                     932              CLR.L       D3
00001498                           933              
00001498                           934              ;Copy the address values into a register
00001498  3412                     935              MOVE.W     (A2),D2
0000149A                           936              
0000149A                           937              ;Passing in parameters for isolating bits 6,7,8
0000149A  163C 0006                938              MOVE.B      #6,D3             ;Start bit index = 6
0000149E  183C 0003                939              MOVE.B      #3,D4             ;Number of bits needed = 3
000014A2                           940              
000014A2                           941              ;Jumps to getBits and returns with isolated bits in D2
000014A2  6100 FDA6                942              BSR         getBits
000014A6                           943              
000014A6                           944              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
000014A6  B4BC 00000003            945              CMP.L       #%011,D2
000014AC  6700 0002                946              BEQ         continueDIVU
000014B0                           947              
000014B0                           948              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
000014B0                           949  
000014B0                           950  continueDIVU:
000014B0                           951  
000014B0  43F9 00001AD9            952              LEA         printDIVU,A1
000014B6  103C 000E                953              MOVE.B      #14,D0
000014BA  4E4F                     954              TRAP        #15
000014BC                           955              
000014BC  6000 02BA                956              BRA         dnDest
000014C0                           957              
000014C0                           958              
000014C0                           959  *-----------------------------------------------------------
000014C0                           960  * SUB INSTRUCTION
000014C0                           961  *-----------------------------------------------------------  
000014C0                           962  M1001:
000014C0  43F9 00001AC8            963              LEA        printSUB,A1
000014C6  103C 000E                964              MOVE.B     #14,D0
000014CA  4E4F                     965              TRAP       #15
000014CC                           966              
000014CC  4202                     967              CLR.B      D2
000014CE  4203                     968              CLR.B      D3
000014D0                           969              
000014D0                           970              ;======Isolate Size (S) Bits=======
000014D0                           971              ;Copy the address values into a register
000014D0  3412                     972              MOVE.W     (A2),D2
000014D2                           973              
000014D2                           974              ;Passing in parameters for isolating size bits
000014D2  163C 0006                975              MOVE.B      #6,D3             ;Start bit index = 6
000014D6  183C 0002                976              MOVE.B      #2,D4             ;Number of bits needed = 2
000014DA                           977              
000014DA                           978              ;Jumps to getBits and returns with isolated bits in D2
000014DA  6100 FD6E                979              BSR         getBits  
000014DE                           980              
000014DE                           981              ;Jumps to printSizeSubroutine and returns after size has been printed
000014DE  6100 031E                982              BSR         printSizeSubroutine
000014E2                           983              
000014E2                           984              ;Let's store the size indicator since it will help us determine how many times
000014E2                           985              ;we have to iterate through addresses to print out the whole instruction
000014E2                           986              ;We will use A4 as the register to temporary store the size
000014E2  3842                     987              MOVE.W      D2,A4
000014E4  11C2 2000                988              MOVE.B      D2,$2000
000014E8                           989              
000014E8                           990              ;======Isolate direction (D) Bit=======
000014E8                           991              ; 0 = data register is destination | 1 = Dn is source
000014E8  4282                     992              CLR.L       D2
000014EA                           993              
000014EA                           994              ;Copy the address values into a register
000014EA  3412                     995              MOVE.W      (A2),D2
000014EC                           996              
000014EC                           997              ;Passing in parameters for isolating direction bit
000014EC  163C 0008                998              MOVE.B      #8,D3             ;Start bit index = 8
000014F0  183C 0001                999              MOVE.B      #1,D4             ;Number of bits needed = 1
000014F4                          1000              
000014F4                          1001              ;Jumps to getBits and returns with isolated bit in D2
000014F4  6100 FD54               1002              BSR         getBits
000014F8                          1003              
000014F8                          1004              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000014F8  B43C 0000               1005              CMP.B       #0,D2
000014FC  6700 027A               1006              BEQ         dnDest
00001500  6000 029A               1007              BRA         dnSource
00001504                          1008  
00001504                          1009  
00001504                          1010  *-----------------------------------------------------------
00001504                          1011  * MULS,AND INSTRUCTIONS
00001504                          1012  *-----------------------------------------------------------  
00001504                          1013  M1100:      
00001504  4282                    1014              CLR.L       D2
00001506  4283                    1015              CLR.L       D3
00001508                          1016              
00001508                          1017              ;Copy the address values into a register
00001508  3412                    1018              MOVE.W     (A2),D2
0000150A                          1019              
0000150A                          1020              ;Passing in parameters for isolating bits 6 and 7
0000150A  163C 0006               1021              MOVE.B      #6,D3             ;Start bit index = 6
0000150E  183C 0002               1022              MOVE.B      #2,D4             ;Number of bits needed = 2
00001512                          1023              
00001512                          1024              ;Jumps to getBits and returns with isolated bits in D2
00001512  6100 FD36               1025              BSR         getBits  
00001516                          1026              
00001516                          1027              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
00001516  B43C 0003               1028              CMP.B       #%11,D2
0000151A  6700 0006               1029              BEQ         mulsCheck
0000151E  6000 0028               1030              BRA         MAND
00001522                          1031              
00001522                          1032  mulsCheck:
00001522                          1033              ;Copy the address values into a register
00001522  3412                    1034              MOVE.W     (A2),D2
00001524                          1035              
00001524                          1036              ;Passing in parameters for isolating bit 8
00001524  163C 0008               1037              MOVE.B      #8,D3             ;Start bit index = 8
00001528  183C 0001               1038              MOVE.B      #1,D4             ;Number of bits needed = 1
0000152C                          1039              
0000152C                          1040              ;Jumps to getBits and returns with isolated bits in D2
0000152C  6100 FD1C               1041              BSR         getBits 
00001530                          1042              
00001530                          1043              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
00001530  B43C 0001               1044              CMP.B       #1,D2
00001534  6700 0002               1045              BEQ         MMULS
00001538                          1046              
00001538                          1047              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001538                          1048  
00001538                          1049              
00001538                          1050              
00001538                          1051              
00001538                          1052  MMULS:
00001538  43F9 00001AD1           1053              LEA         printMULS,A1
0000153E  103C 000E               1054              MOVE.B      #14,D0
00001542  4E4F                    1055              TRAP        #15
00001544                          1056              
00001544  6000 0232               1057              BRA         dnDest 
00001548                          1058  
00001548                          1059  
00001548                          1060  MAND:
00001548  43F9 00001AE6           1061              LEA        printAND,A1
0000154E  103C 000E               1062              MOVE.B     #14,D0
00001552  4E4F                    1063              TRAP       #15
00001554                          1064              
00001554                          1065              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
00001554                          1066              ;Jumps to printSizeSubroutine and returns after size has been printed
00001554  6100 02A8               1067              BSR         printSizeSubroutine
00001558                          1068              
00001558                          1069              ;======Isolate direction (D) Bit=======
00001558                          1070              ; 0 = data register is destination | 1 = Dn is source
00001558  4282                    1071              CLR.L       D2
0000155A                          1072              
0000155A                          1073              ;Copy the address values into a register
0000155A  3412                    1074              MOVE.W      (A2),D2
0000155C                          1075              
0000155C                          1076              ;Passing in parameters for isolating direction bit
0000155C  163C 0008               1077              MOVE.B      #8,D3           ;Start bit index = 8
00001560  183C 0001               1078              MOVE.B      #1,D4           ;Number of bits needed = 1
00001564                          1079  
00001564                          1080              ;Jumps to getBits and returns with isolated bit in D2
00001564  6100 FCE4               1081              BSR         getBits
00001568                          1082              
00001568                          1083              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001568  B43C 0000               1084              CMP.B       #0,D2
0000156C  6700 020A               1085              BEQ         dnDest
00001570  6000 022A               1086              BRA         dnSource
00001574                          1087              
00001574                          1088              
00001574  6000 FCBE               1089              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001578                          1090     
00001578                          1091     
00001578                          1092  *-----------------------------------------------------------
00001578                          1093  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001578                          1094  *-----------------------------------------------------------  
00001578                          1095  M1110:
00001578  4282                    1096              CLR.L       D2
0000157A  4283                    1097              CLR.L       D3
0000157C                          1098              
0000157C                          1099              ;Copy the address values into a register
0000157C  3412                    1100              MOVE.W     (A2),D2
0000157E                          1101              
0000157E                          1102              ;Passing in parameters for isolating bits 6-7
0000157E  163C 0006               1103              MOVE.B      #6,D3             ;Start bit index = 6
00001582  183C 0002               1104              MOVE.B      #2,D4             ;Number of bits needed = 2
00001586                          1105              
00001586                          1106              ;Jumps to getBits and returns with isolated bits in D2
00001586  6100 FCC2               1107              BSR         getBits  
0000158A                          1108              
0000158A                          1109              ;Check if Memory Shift
0000158A  B43C 0003               1110              CMP.B       #%11,D2
0000158E  6700 00B8               1111              BEQ         MemShift
00001592                          1112              
00001592                          1113              ;If not Memory Shift, is a Register Shift
00001592                          1114              
00001592                          1115              ;Copy the address values into a register
00001592  3412                    1116              MOVE.W     (A2),D2
00001594                          1117              
00001594                          1118              ;Passing in parameters for isolating bit 3
00001594  163C 0003               1119              MOVE.B      #3,D3             ;Start bit index = 3
00001598  183C 0001               1120              MOVE.B      #1,D4             ;Number of bits needed = 1
0000159C                          1121              
0000159C                          1122              ;Jumps to getBits and returns with isolated bits in D2
0000159C  6100 FCAC               1123              BSR         getBits  
000015A0                          1124              
000015A0                          1125              ;Checks if ASd
000015A0  B43C 0000               1126              CMP.B       #%0,D2
000015A4  6700 00E8               1127              BEQ         RegAS
000015A8                          1128              
000015A8                          1129              ;Checks if LSd
000015A8  B43C 0001               1130              CMP.B       #%1,D2
000015AC  6700 00E8               1131              BEQ         RegLS
000015B0                          1132  RegShift      
000015B0                          1133              ;Copy the address values into a register
000015B0  3412                    1134              MOVE.W     (A2),D2
000015B2                          1135              
000015B2                          1136              ;Passing in parameters for isolating bits 6-7
000015B2  163C 0006               1137              MOVE.B      #6,D3             ;Start bit index = 6
000015B6  183C 0002               1138              MOVE.B      #2,D4             ;Number of bits needed = 2
000015BA                          1139              
000015BA                          1140              ;Jumps to getBits and returns with isolated bits in D2
000015BA  6100 FC8E               1141              BSR         getBits  
000015BE                          1142              
000015BE                          1143              ;Print Size
000015BE  6100 023E               1144              BSR         printSizeSubroutine
000015C2                          1145              
000015C2                          1146              ;Copy the address values into a register
000015C2  3412                    1147              MOVE.W     (A2),D2
000015C4                          1148              
000015C4                          1149              ;Passing in parameters for isolating bit 5
000015C4  163C 0005               1150              MOVE.B      #5,D3             ;Start bit index = 5
000015C8  183C 0001               1151              MOVE.B      #1,D4             ;Number of bits needed = 1
000015CC                          1152              
000015CC                          1153              ;Jumps to getBits and returns with isolated bits in D2
000015CC  6100 FC7C               1154              BSR         getBits  
000015D0                          1155              
000015D0                          1156              ;Checks if shift count is immediate
000015D0  B43C 0000               1157              CMP.B       #%0,D2
000015D4  6700 003C               1158              BEQ         ImmediateCount
000015D8                          1159              
000015D8                          1160              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000015D8                          1161              ;D7 will contain the register after this instruction
000015D8  6100 020C               1162              BSR         isolateRegisterBit9to11
000015DC                          1163              
000015DC                          1164              ;Save #%000 into D6 to specify data register mode
000015DC  1C3C 0000               1165              MOVE.B      #0,D6
000015E0                          1166              
000015E0                          1167              ;*Print Shift Count address*
000015E0  6100 027E               1168              BSR         addressModeSR
000015E4                          1169  
000015E4  6100 0002               1170              BSR         RegShift2
000015E8                          1171  
000015E8                          1172  RegShift2   ;Print comma after shift count
000015E8  43F9 00001B4D           1173              LEA         printComma,A1
000015EE  103C 000E               1174              MOVE.B      #14,D0
000015F2  4E4F                    1175              TRAP        #15
000015F4                          1176              
000015F4                          1177              ;*Data Register to be Shifted*
000015F4  4282                    1178              CLR.L       D2
000015F6                          1179              
000015F6                          1180              ;Copy the address values into a register
000015F6  3412                    1181              MOVE.W      (A2),D2
000015F8                          1182              
000015F8                          1183              ;Passing in parameters for isolating bits 0-2
000015F8  163C 0000               1184              MOVE.B      #0,D3             ;Start bit index = 0
000015FC  183C 0003               1185              MOVE.B      #3,D4             ;Number of bits needed = 3
00001600                          1186              
00001600                          1187              ;Jumps to getBits and returns with isolated bits in D2
00001600  6100 FC48               1188              BSR         getBits
00001604                          1189              
00001604                          1190              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001604  1E02                    1191              MOVE.B      D2,D7
00001606                          1192              
00001606                          1193              ;Save #%000 into D6 to specify data register mode
00001606  1C3C 0000               1194              MOVE.B      #0,D6
0000160A                          1195              
0000160A                          1196              ;*Prints data register to be shifted*
0000160A  6100 0254               1197              BSR         addressModeSR
0000160E                          1198  
0000160E  6000 FC24               1199              BRA         update
00001612                          1200              
00001612                          1201  ImmediateCount
00001612                          1202              ;Print #$
00001612  43F9 00001B3D           1203              LEA        printIA,A1
00001618  103C 000E               1204              MOVE.B     #14,D0
0000161C  4E4F                    1205              TRAP       #15
0000161E                          1206              
0000161E                          1207              ;Copy the address values into a register
0000161E  3412                    1208              MOVE.W     (A2),D2
00001620                          1209              
00001620                          1210              ;Passing in parameters for isolating bits 9-11
00001620  163C 0009               1211              MOVE.B      #9,D3             ;Start bit index = 9
00001624  183C 0003               1212              MOVE.B      #3,D4             ;Number of bits needed = 3
00001628                          1213              
00001628                          1214              ;Jumps to getBits and returns with isolated bits in D2
00001628  6100 FC20               1215              BSR         getBits  
0000162C                          1216              
0000162C                          1217              ;Check if shift count is 8
0000162C  B43C 0000               1218              CMP.B       #%000,D2
00001630  6700 0010               1219              BEQ         ShiftEight
00001634                          1220              
00001634  1202                    1221              MOVE.B      D2, D1
00001636  6100 0002               1222              BSR         ImmediateCount2
0000163A                          1223             
0000163A                          1224  ImmediateCount2
0000163A                          1225              ;Print shift count
0000163A  103C 0003               1226              MOVE.B      #3,D0
0000163E  4E4F                    1227              TRAP        #15
00001640  61A6                    1228              BSR         RegShift2
00001642                          1229   
00001642                          1230  ShiftEight  ;Move 8 into D1    
00001642  123C 0008               1231              MOVE.B      #8, D1
00001646  61F2                    1232              BSR         ImmediateCount2
00001648                          1233                                     
00001648                          1234  MemShift
00001648                          1235              ;Copy the address values into a register
00001648  3412                    1236              MOVE.W     (A2),D2
0000164A                          1237              
0000164A                          1238              ;Passing in parameters for isolating bit 9
0000164A  163C 0009               1239              MOVE.B      #9,D3             ;Start bit index = 9
0000164E  183C 0001               1240              MOVE.B      #1,D4             ;Number of bits needed = 1
00001652                          1241              
00001652                          1242              ;Jumps to getBits and returns with isolated bits in D2
00001652  6100 FBF6               1243              BSR         getBits  
00001656                          1244              
00001656                          1245              ;Checks if ASd
00001656  B43C 0000               1246              CMP.B       #%0,D2
0000165A  6700 0022               1247              BEQ         MemAS
0000165E                          1248              
0000165E                          1249              ;Checks if LSd
0000165E  B43C 0001               1250              CMP.B       #%1,D2
00001662  6700 0022               1251              BEQ         MemLS
00001666                          1252  
00001666                          1253  MemShift2   
00001666                          1254              ;Print Space
00001666  43F9 00001B4F           1255              LEA        printSpace,A1
0000166C  103C 000E               1256              MOVE.B     #14,D0
00001670  4E4F                    1257              TRAP       #15
00001672                          1258              
00001672                          1259              ;*Memory Address*
00001672                          1260              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001672                          1261              ;D6 will contain mode & D7 will contain the register after this instruction
00001672  6100 014C               1262              BSR         isolateAddressBit0to5
00001676                          1263              
00001676                          1264              ;*Print source address*
00001676  6100 01E8               1265              BSR         addressModeSR
0000167A                          1266              
0000167A  6000 FBB8               1267              BRA         update
0000167E                          1268              
0000167E                          1269  MemAS       ;Print AS
0000167E  6100 002C               1270              BSR         MAS      
00001682  6100 0036               1271              BSR         MemDirectionSubroutine                
00001686                          1272  
00001686                          1273              
00001686                          1274  MemLS       ;Print LS
00001686  6100 0016               1275              BSR         MLS      
0000168A  6100 002E               1276              BSR         MemDirectionSubroutine
0000168E                          1277              
0000168E                          1278  RegAS       ;Print AS
0000168E  6100 001C               1279              BSR         MAS      
00001692  6100 0062               1280              BSR         RegDirectionSubroutine                
00001696                          1281  
00001696                          1282              
00001696                          1283  RegLS       ;Print LS
00001696  6100 0006               1284              BSR         MLS      
0000169A  6100 005A               1285              BSR         RegDirectionSubroutine
0000169E                          1286  
0000169E                          1287  MLS:
0000169E  43F9 00001B1A           1288              LEA        printMLS,A1
000016A4  103C 000E               1289              MOVE.B     #14,D0
000016A8  4E4F                    1290              TRAP       #15
000016AA  4E75                    1291              RTS
000016AC                          1292  MAS:
000016AC  43F9 00001B17           1293              LEA        printMAS,A1
000016B2  103C 000E               1294              MOVE.B     #14,D0
000016B6  4E4F                    1295              TRAP       #15
000016B8  4E75                    1296              RTS
000016BA                          1297  
000016BA                          1298  MemDirectionSubroutine
000016BA                          1299              ;Copy the address values into a register
000016BA  3412                    1300              MOVE.W     (A2),D2
000016BC                          1301              
000016BC                          1302              ;Passing in parameters for isolating bit 8
000016BC  163C 0008               1303              MOVE.B      #8,D3             ;Start bit index = 8
000016C0  183C 0001               1304              MOVE.B      #1,D4             ;Number of bits needed = 1
000016C4                          1305              
000016C4                          1306              ;Jumps to getBits and returns with isolated bits in D2
000016C4  6100 FB84               1307              BSR         getBits  
000016C8                          1308              
000016C8                          1309              ;Checks if Right
000016C8  B43C 0000               1310              CMP.B       #%0,D2
000016CC  6700 000A               1311              BEQ         MR
000016D0                          1312              
000016D0                          1313              ;Checks if Left
000016D0  B43C 0001               1314              CMP.B       #%1,D2
000016D4  6700 0010               1315              BEQ         ML
000016D8                          1316                          
000016D8  43F9 00001B1F           1317  MR          LEA        printR,A1
000016DE  103C 000E               1318              MOVE.B     #14,D0
000016E2  4E4F                    1319              TRAP       #15
000016E4  6180                    1320              BSR        MemShift2
000016E6                          1321  
000016E6  43F9 00001B1D           1322  ML          LEA        printL,A1
000016EC  103C 000E               1323              MOVE.B     #14,D0
000016F0  4E4F                    1324              TRAP       #15
000016F2  6100 FF72               1325              BSR        MemShift2
000016F6                          1326              
000016F6                          1327  RegDirectionSubroutine
000016F6                          1328              ;Copy the address values into a register
000016F6  3412                    1329              MOVE.W     (A2),D2
000016F8                          1330              
000016F8                          1331              ;Passing in parameters for isolating bit 8
000016F8  163C 0008               1332              MOVE.B      #8,D3             ;Start bit index = 8
000016FC  183C 0001               1333              MOVE.B      #1,D4             ;Number of bits needed = 1
00001700                          1334              
00001700                          1335              ;Jumps to getBits and returns with isolated bits in D2
00001700  6100 FB48               1336              BSR         getBits  
00001704                          1337              
00001704                          1338              ;Checks if Right
00001704  B43C 0000               1339              CMP.B       #%0,D2
00001708  6700 000A               1340              BEQ         RR
0000170C                          1341              
0000170C                          1342              ;Checks if Left
0000170C  B43C 0001               1343              CMP.B       #%1,D2
00001710  6700 0012               1344              BEQ         RL
00001714                          1345                          
00001714  43F9 00001B1F           1346  RR          LEA        printR,A1
0000171A  103C 000E               1347              MOVE.B     #14,D0
0000171E  4E4F                    1348              TRAP       #15
00001720  6100 FE8E               1349              BSR        RegShift
00001724                          1350  
00001724  43F9 00001B1D           1351  RL          LEA        printL,A1
0000172A  103C 000E               1352              MOVE.B     #14,D0
0000172E  4E4F                    1353              TRAP       #15
00001730  6100 FE7E               1354              BSR        RegShift
00001734                          1355  
00001734                          1356  
00001734                          1357  *-----------------------------------------------------------------------
00001734                          1358  *-----------------------------------------------------------------------
00001734                          1359  *-----------------------------------------------------------------------
00001734                          1360  
00001734                          1361  
00001734                          1362  
00001734                          1363  
00001734                          1364  ;ADD
00001734                          1365  M1101:
00001734  43F9 00001ABF           1366              LEA        printADD,A1
0000173A  103C 000E               1367              MOVE.B     #14,D0
0000173E  4E4F                    1368              TRAP       #15
00001740                          1369              
00001740  4202                    1370              CLR.B      D2
00001742  4203                    1371              CLR.B      D3
00001744                          1372              
00001744                          1373              ;======Isolate Size (S) Bits=======
00001744                          1374              ;Copy the address values into a register
00001744  3412                    1375              MOVE.W     (A2),D2
00001746                          1376              
00001746                          1377              ;Passing in parameters for isolating size bits
00001746  163C 0006               1378              MOVE.B      #6,D3             ;Start bit index = 6
0000174A  183C 0002               1379              MOVE.B      #2,D4             ;Number of bits needed = 2
0000174E                          1380              
0000174E                          1381              ;Jumps to getBits and returns with isolated bits in D2
0000174E  6100 FAFA               1382              BSR         getBits  
00001752                          1383              
00001752                          1384              ;Jumps to printSizeSubroutine and returns after size has been printed
00001752  6100 00AA               1385              BSR         printSizeSubroutine
00001756                          1386         
00001756                          1387              ;Let's store the size indicator since it will help us determine how many times
00001756                          1388              ;we have to iterate through addresses to print out the whole instruction
00001756                          1389              ;We will use A4 as the register to temporary store the size
00001756  3842                    1390              MOVE.W      D2,A4
00001758  11C2 2000               1391              MOVE.B      D2,$2000
0000175C                          1392              
0000175C                          1393              ;======Isolate direction (D) Bit=======
0000175C                          1394              ; 0 = data register is destination | 1 = Dn is source
0000175C  4282                    1395              CLR.L       D2
0000175E                          1396              
0000175E                          1397              ;Copy the address values into a register
0000175E  3412                    1398              MOVE.W      (A2),D2
00001760                          1399              
00001760                          1400              ;Passing in parameters for isolating direction bit
00001760  163C 0008               1401              MOVE.B      #8,D3             ;Start bit index = 8
00001764  183C 0001               1402              MOVE.B      #1,D4             ;Number of bits needed = 1
00001768                          1403              
00001768                          1404              ;Jumps to getBits and returns with isolated bit in D2
00001768  6100 FAE0               1405              BSR         getBits
0000176C                          1406              
0000176C                          1407              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
0000176C  B43C 0000               1408              CMP.B       #0,D2
00001770  6700 0006               1409              BEQ         dnDest
00001774  6000 0026               1410              BRA         dnSource
00001778                          1411              
00001778                          1412  
00001778                          1413  *-----------------------------------------------------------------
00001778                          1414  * dnDest, dnSource, & other subroutines for isolating address bits
00001778                          1415  *-----------------------------------------------------------------
00001778                          1416  ;* dnDest,dnSource *
00001778                          1417  ;For: MULS,AND,ADD,SUB,DIVU
00001778                          1418  ;Used by instructions that require Dn as one of their addressing modes.
00001778                          1419  ;dnDest isolates the addressing bits with Dn being the destination address
00001778                          1420  ;dnSource isolates the addressing bits with Dn being the source address
00001778                          1421  
00001778                          1422  dnDest:
00001778                          1423              ;**Used for isolating addressing bits when Dn is the destination**
00001778                          1424              
00001778                          1425              ;*SOURCE*
00001778                          1426              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001778                          1427              ;D6 will contain mode & D7 will contain the register after this instruction
00001778  6100 0046               1428              BSR         isolateAddressBit0to5
0000177C                          1429              
0000177C                          1430              ;*Print source address*
0000177C  6100 00E2               1431              BSR         addressModeSR
00001780                          1432              
00001780                          1433              ;Print comma after source address
00001780  43F9 00001B4D           1434              LEA         printComma,A1
00001786  103C 000E               1435              MOVE.B      #14,D0
0000178A  4E4F                    1436              TRAP        #15
0000178C                          1437              
0000178C                          1438              ;*DESTINATION*
0000178C                          1439              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000178C                          1440              ;D7 will contain the register after this instruction
0000178C  6100 0058               1441              BSR         isolateRegisterBit9to11
00001790                          1442              
00001790                          1443              ;Save #%000 into D6 to specify data register mode
00001790  1C3C 0000               1444              MOVE.B      #0,D6
00001794                          1445              
00001794                          1446              ;*Print destination address*
00001794  6100 00CA               1447              BSR         addressModeSR
00001798                          1448  
00001798  6000 FA9A               1449              BRA         update
0000179C                          1450              
0000179C                          1451  dnSource:
0000179C                          1452              ;**Used for isolating addressing bits when Dn is the destination**
0000179C                          1453                          
0000179C                          1454              ;*SOURCE*
0000179C                          1455              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000179C                          1456              ;D7 will contain the register after this instruction
0000179C  6100 0048               1457              BSR         isolateRegisterBit9to11
000017A0                          1458              
000017A0                          1459              ;Save #%000 into D6 to specify data register mode
000017A0  1C3C 0000               1460              MOVE.B      #0,D6
000017A4                          1461              
000017A4                          1462              ;*Print Source address*
000017A4  6100 00BA               1463              BSR         addressModeSR
000017A8                          1464              
000017A8                          1465              ;Print comma after source address
000017A8  43F9 00001B4D           1466              LEA         printComma,A1
000017AE  103C 000E               1467              MOVE.B      #14,D0
000017B2  4E4F                    1468              TRAP        #15
000017B4                          1469              
000017B4                          1470              ;*DESTINATION*
000017B4                          1471              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000017B4                          1472              ;D6 will contain mode & D7 will contain the register after this instruction
000017B4  6100 000A               1473              BSR         isolateAddressBit0to5
000017B8                          1474              
000017B8                          1475              ;*Print destination address*
000017B8  6100 00A6               1476              BSR         addressModeSR
000017BC                          1477  
000017BC  6000 FA76               1478              BRA         update
000017C0                          1479                     
000017C0                          1480  isolateAddressBit0to5:
000017C0                          1481  ;Helper subroutine for isolating the address stored within bits 0-5
000017C0                          1482  ;Stores address mode in D6
000017C0                          1483  ;Stores address register in D7
000017C0                          1484  
000017C0                          1485              ;======Isolate Effective Address Mode (M) Bits=======
000017C0  4282                    1486              CLR.L       D2
000017C2                          1487              
000017C2                          1488              ;Copy the address values into a register
000017C2  3412                    1489              MOVE.W      (A2),D2
000017C4                          1490              
000017C4                          1491              ;Passing in parameters for isolating Mode bits
000017C4  163C 0003               1492              MOVE.B      #3,D3             ;Start bit index = 3
000017C8  183C 0003               1493              MOVE.B      #3,D4             ;Number of bits needed = 3
000017CC                          1494              
000017CC                          1495              ;Jumps to getBits and returns with isolated bits in D2
000017CC  4EB8 124A               1496              JSR         getBits
000017D0                          1497              
000017D0                          1498              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000017D0  1C02                    1499              MOVE.B      D2,D6
000017D2                          1500              
000017D2                          1501                       
000017D2                          1502              ;======Isolate Effective Address Register (Xn) Bits=======
000017D2  4282                    1503              CLR.L       D2
000017D4                          1504              
000017D4                          1505              ;Copy the address values into a register
000017D4  3412                    1506              MOVE.W      (A2),D2
000017D6                          1507              
000017D6                          1508              ;Passing in parameters for isolating Xn bits
000017D6  163C 0000               1509              MOVE.B      #0,D3             ;Start bit index = 0
000017DA  183C 0003               1510              MOVE.B      #3,D4             ;Number of bits needed = 3
000017DE                          1511              
000017DE                          1512              ;Jumps to getBits and returns with isolated bits in D2
000017DE  6100 FA6A               1513              BSR         getBits
000017E2                          1514              
000017E2                          1515              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000017E2  1E02                    1516              MOVE.B      D2,D7
000017E4                          1517              
000017E4  4E75                    1518              RTS
000017E6                          1519  
000017E6                          1520  isolateRegisterBit9to11:
000017E6                          1521  ;Helper subroutine for isolating the register stored within bits 9-11
000017E6                          1522  ;Stores the address register in D7
000017E6                          1523  
000017E6                          1524              ;======Isolate Register Bits=======
000017E6  4282                    1525              CLR.L       D2
000017E8  4286                    1526              CLR.L       D6
000017EA  4287                    1527              CLR.L       D7
000017EC                          1528              
000017EC                          1529              ;Copy the address values into a register
000017EC  3412                    1530              MOVE.W      (A2),D2
000017EE                          1531              
000017EE                          1532              ;Passing in parameters for isolating register bits
000017EE  163C 0009               1533              MOVE.B      #9,D3             ;Start bit index = 9
000017F2  183C 0003               1534              MOVE.B      #3,D4             ;Number of bits needed = 3
000017F6                          1535              
000017F6                          1536              ;Jumps to getBits and returns with isolated bit in D2
000017F6  6100 FA52               1537              BSR         getBits
000017FA                          1538              
000017FA                          1539              ;Save register bit into ***D7*** for later use in addressModeSR
000017FA  1E02                    1540              MOVE.B      D2,D7
000017FC                          1541  
000017FC  4E75                    1542              RTS
000017FE                          1543              
000017FE                          1544  *-----------------------------------------------------------
000017FE                          1545  * Print Sizes
000017FE                          1546  *-----------------------------------------------------------
000017FE                          1547  printSizeSubroutine:
000017FE                          1548              ;Prints the apporpriate size
000017FE                          1549              ;PARAMETER:
000017FE                          1550              ;D2 = the size bits
000017FE                          1551              
000017FE                          1552              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
000017FE  B63C 0001               1553              CMP.B      #1,D3
00001802  6700 001A               1554              BEQ        printMOVESize
00001806                          1555              
00001806                          1556              ;Compare to which size is being moved for the opcode
00001806  B43C 0000               1557              CMP.B      #%00,D2
0000180A  6700 002A               1558              BEQ        PByte
0000180E                          1559              
0000180E  B43C 0001               1560              CMP.B      #%01,D2
00001812  6700 0030               1561              BEQ        PWord
00001816                          1562              
00001816  B43C 0002               1563              CMP.B      #%10,D2
0000181A  6700 0036               1564              BEQ        PLong
0000181E                          1565           
0000181E                          1566  printMOVESize:
0000181E                          1567              ;Now that we know we have a MOVE opcode
0000181E                          1568              ;Compare to which size is being moved for the opcode
0000181E  B43C 0001               1569              CMP.B      #%01,D2
00001822  6700 0012               1570              BEQ        PByte
00001826                          1571  
00001826  B43C 0003               1572              CMP.B      #%11,D2
0000182A  6700 0018               1573              BEQ        PWord            
0000182E                          1574    
0000182E  B43C 0002               1575              CMP.B      #%10,D2
00001832  6700 001E               1576              BEQ        PLong
00001836                          1577  
00001836                          1578  PByte:
00001836  43F9 00001B21           1579              LEA        printSIZEB,A1
0000183C  103C 000E               1580              MOVE.B     #14,D0
00001840  4E4F                    1581              TRAP       #15
00001842                          1582              
00001842  4E75                    1583              RTS
00001844                          1584  PWord:
00001844  43F9 00001B26           1585              LEA        printSIZEW,A1
0000184A  103C 000E               1586              MOVE.B     #14,D0
0000184E  4E4F                    1587              TRAP       #15
00001850                          1588              
00001850  4E75                    1589              RTS
00001852                          1590  PLong:            
00001852  43F9 00001B2C           1591              LEA        printSIZEL,A1
00001858  103C 000E               1592              MOVE.B     #14,D0
0000185C  4E4F                    1593              TRAP       #15
0000185E                          1594              
0000185E  4E75                    1595              RTS
00001860                          1596              
00001860                          1597  *-----------------------------------------------------------
00001860                          1598  * Addressing Mode Implementation
00001860                          1599  *-----------------------------------------------------------
00001860                          1600  addressModeSR:
00001860                          1601              ;Prints address according to the parameters passed in
00001860                          1602              ;PARAMETERS:
00001860                          1603              ;D6 = mode
00001860                          1604              ;D7 = register
00001860                          1605  
00001860                          1606              ;Data register direct
00001860  BC3C 0000               1607              CMP.B       #%000,D6
00001864  6700 002A               1608              BEQ         DRD
00001868                          1609              
00001868                          1610              ;Address register direct
00001868  BC3C 0001               1611              CMP.B       #%001,D6
0000186C  6700 0036               1612              BEQ         ARD
00001870                          1613              
00001870                          1614              ;Address register indirect
00001870  BC3C 0002               1615              CMP.B       #%010,D6
00001874  6700 0042               1616              BEQ         ARI
00001878                          1617              
00001878                          1618              ;Post Increment
00001878  BC3C 0003               1619              CMP.B       #%011,D6
0000187C  6700 005A               1620              BEQ         PI
00001880                          1621              
00001880                          1622              ;Pre Decrement
00001880  BC3C 0004               1623              CMP.B       #%100,D6
00001884  6700 0072               1624              BEQ         PD
00001888                          1625              
00001888                          1626              ;Immediate/Absolute Addressing
00001888  BC3C 0007               1627              CMP.B       #%111,D6
0000188C  6700 008A               1628              BEQ         otherModes
00001890                          1629  DRD:
00001890                          1630              ;Print D __
00001890  43F9 00001B34           1631              LEA         printDRD,A1
00001896  103C 000E               1632              MOVE.B      #14,D0
0000189A  4E4F                    1633              TRAP        #15
0000189C                          1634              
0000189C                          1635              ;Print register number
0000189C  7003                    1636              MOVE.L      #3,D0
0000189E  2207                    1637              MOVE.L      D7,D1
000018A0  4E4F                    1638              TRAP        #15
000018A2                          1639              
000018A2  4E75                    1640              RTS
000018A4                          1641  ARD:
000018A4                          1642              ;Print A __
000018A4  43F9 00001B36           1643              LEA         printARD,A1
000018AA  103C 000E               1644              MOVE.B      #14,D0
000018AE  4E4F                    1645              TRAP        #15
000018B0                          1646              
000018B0                          1647              ;Print register number
000018B0  7003                    1648              MOVE.L      #3,D0
000018B2  2207                    1649              MOVE.L      D7,D1
000018B4  4E4F                    1650              TRAP        #15
000018B6                          1651              
000018B6  4E75                    1652              RTS
000018B8                          1653  ARI:
000018B8                          1654              ;Print (A __ )
000018B8  43F9 00001B38           1655              LEA         printARI,A1
000018BE  103C 000E               1656              MOVE.B      #14,D0
000018C2  4E4F                    1657              TRAP        #15
000018C4                          1658              
000018C4                          1659              ;Print register number
000018C4  7003                    1660              MOVE.L      #3,D0
000018C6  2207                    1661              MOVE.L      D7,D1
000018C8  4E4F                    1662              TRAP        #15
000018CA                          1663              
000018CA                          1664              ;Print closing ')'
000018CA  43F9 00001B3B           1665              LEA         printARI2,A1
000018D0  103C 000E               1666              MOVE.B      #14,D0
000018D4  4E4F                    1667              TRAP        #15
000018D6                          1668              
000018D6  4E75                    1669              RTS
000018D8                          1670  PI:
000018D8                          1671              ;Print (A __)+
000018D8  43F9 00001B41           1672              LEA         printPI,A1
000018DE  103C 000E               1673              MOVE.B      #14,D0
000018E2  4E4F                    1674              TRAP        #15
000018E4                          1675              
000018E4                          1676              ;Print register number
000018E4  7003                    1677              MOVE.L      #3,D0
000018E6  2207                    1678              MOVE.L      D7,D1
000018E8  4E4F                    1679              TRAP        #15
000018EA                          1680              
000018EA                          1681              ;Print closing ')+'
000018EA  43F9 00001B44           1682              LEA         printPI2,A1
000018F0  103C 000E               1683              MOVE.B      #14,D0
000018F4  4E4F                    1684              TRAP        #15
000018F6                          1685              
000018F6  4E75                    1686              RTS
000018F8                          1687  PD:
000018F8                          1688              ;Print -(A __)
000018F8  43F9 00001B47           1689              LEA         printPD,A1
000018FE  103C 000E               1690              MOVE.B      #14,D0
00001902  4E4F                    1691              TRAP        #15
00001904                          1692              
00001904                          1693              ;Print register number
00001904  7003                    1694              MOVE.L      #3,D0
00001906  2207                    1695              MOVE.L      D7,D1
00001908  4E4F                    1696              TRAP        #15
0000190A                          1697              
0000190A                          1698              ;Print closing ')'
0000190A  43F9 00001B4B           1699              LEA         printPD2,A1
00001910  103C 000E               1700              MOVE.B      #14,D0
00001914  4E4F                    1701              TRAP        #15
00001916                          1702              
00001916  4E75                    1703              RTS
00001918                          1704  
00001918                          1705  otherModes:
00001918  B4CE                    1706              CMP.W       A6,A2
0000191A                          1707              
0000191A  6D00 0004               1708              BLT         SKIPCOPY  
0000191E                          1709  
0000191E                          1710               *=====Important step for making sure we have access to where A2 orignally points=====*
0000191E  2C4A                    1711              MOVEA.L     A2,A6 
00001920                          1712  
00001920                          1713  
00001920                          1714  SKIPCOPY:            
00001920                          1715              
00001920                          1716              ;Branch to Immediate if register bits are %100       
00001920  BE3C 0004               1717              CMP.B       #%100,D7
00001924  6700 0006               1718              BEQ         Immediate
00001928                          1719              
00001928                          1720              ;Otherwise, branch to Absolute
00001928  6000 0022               1721              BRA         Absolute
0000192C                          1722              
0000192C                          1723          
0000192C                          1724                     
0000192C                          1725  Immediate:
0000192C                          1726              ;Print #
0000192C  43F9 00001B3D           1727              LEA         printIA,A1
00001932  103C 000E               1728              MOVE.B      #14,D0
00001936  4E4F                    1729              TRAP        #15
00001938                          1730              
00001938                          1731              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001938                          1732              ;We will be able to access the contents of either size B or W
00001938  544A                    1733              ADDA.W      #2,A2         
0000193A                          1734  
0000193A                          1735              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
0000193A  0C38 0002 2000          1736              CMP.B       #%10,$2000
00001940  6700 0048               1737              BEQ         IMDLong
00001944                          1738              
00001944                          1739              ;If we don't branch, then we assume we're printing out a byte or word      
00001944  7003                    1740              MOVE.L      #3,D0
00001946  3212                    1741              MOVE.W      (A2),D1
00001948  4E4F                    1742              TRAP        #15
0000194A                          1743              
0000194A  4E75                    1744              RTS
0000194C                          1745              
0000194C                          1746              
0000194C                          1747              
0000194C                          1748  Absolute:
0000194C                          1749              ;Print $
0000194C  43F9 00001B3F           1750              LEA         printA,A1
00001952  103C 000E               1751              MOVE.B      #14,D0
00001956  4E4F                    1752              TRAP        #15
00001958                          1753              
00001958                          1754              ;Point to the next word (contains memory address)
00001958  544E                    1755              ADDA.W      #2,A6
0000195A                          1756              
0000195A                          1757              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
0000195A  BE3C 0001               1758              CMP.B       #%001,D7
0000195E  6700 0012               1759              BEQ         AbsLong
00001962                          1760              
00001962                          1761              ;Print out the value in the address if it's a word
00001962  4281                    1762              CLR.L       D1
00001964                          1763              
00001964  303C 000F               1764              MOVE.W      #15,D0
00001968  343C 0010               1765              MOVE.W      #16,D2
0000196C  3216                    1766              MOVE.W      (A6),D1
0000196E  4E4F                    1767              TRAP        #15
00001970                          1768              
00001970  4E75                    1769              RTS
00001972                          1770              
00001972                          1771  AbsLong:            
00001972                          1772              ;Place the current value into a temp register
00001972  3816                    1773              MOVE.W      (A6),D4
00001974                          1774              
00001974                          1775              ;Shift the bits so we can enter the rest of the values
00001974  1E3C 0010               1776              MOVE.B      #16,D7
00001978  EFAC                    1777              LSL.L       D7,D4
0000197A                          1778              
0000197A                          1779              ;Increment A6 to account for the next values in the instruction
0000197A  544E                    1780              ADDA.W      #2,A6
0000197C                          1781              
0000197C                          1782              ;Move the rest of the machine code into our register
0000197C                          1783              ;This register should have the whole long values
0000197C  3816                    1784              MOVE.W      (A6),D4
0000197E                          1785              
0000197E                          1786              ;Print the Long address
0000197E  4281                    1787              CLR.L       D1
00001980                          1788              
00001980  700F                    1789              MOVE.L      #15,D0
00001982  7410                    1790              MOVE.L      #16,D2
00001984  2204                    1791              MOVE.L      D4,D1
00001986  4E4F                    1792              TRAP        #15
00001988                          1793              
00001988  4E75                    1794              RTS    
0000198A                          1795          
0000198A                          1796  IMDLong:
0000198A                          1797              *********USED FOR IMMEDIATE LONGS ONLY***************
0000198A                          1798              
0000198A                          1799              ;Place the current value into a temp register
0000198A  3812                    1800              MOVE.W      (A2),D4
0000198C                          1801              
0000198C                          1802              ;Shift the bits so we can enter the rest of the values
0000198C  1E3C 0010               1803              MOVE.B      #16,D7
00001990  EFAC                    1804              LSL.L       D7,D4
00001992                          1805              
00001992                          1806              ;Increment A2 to account for the next values in the machine code
00001992  544A                    1807              ADDA.W      #2,A2
00001994                          1808              
00001994                          1809              ;Move the rest of the machine code into our register
00001994                          1810              ;This register should have the whole long values
00001994  3812                    1811              MOVE.W      (A2),D4
00001996                          1812              
00001996                          1813              ;Print out the value in the address
00001996  7003                    1814              MOVE.L      #3,D0
00001998  2204                    1815              MOVE.L      D4,D1
0000199A  4E4F                    1816              TRAP        #15
0000199C                          1817              
0000199C  4E75                    1818              RTS
0000199E                          1819  
0000199E                          1820  
0000199E                          1821  *-----------------------------------------------------------
0000199E                          1822  * Print Instructions for NOP and RTS
0000199E                          1823  *-----------------------------------------------------------
0000199E                          1824  printMNOP:
0000199E  43F9 00001AB0           1825              LEA        printNOP,A1
000019A4  103C 000E               1826              MOVE.B     #14,D0
000019A8  4E4F                    1827              TRAP       #15
000019AA                          1828              
000019AA  6000 F888               1829              BRA        update
000019AE                          1830  
000019AE                          1831  printMRTS:
000019AE  43F9 00001B0F           1832              LEA        printRTS,A1
000019B4  103C 000E               1833              MOVE.B     #14,D0
000019B8  4E4F                    1834              TRAP       #15
000019BA                          1835              
000019BA  6000 F878               1836              BRA        update
000019BE                          1837  ;-----------------------------------------------------------
000019BE                          1838  ;ERROR MESSAGES FOR I/O portion
000019BE                          1839  ;-----------------------------------------------------------
000019BE                          1840  charError:
000019BE                          1841              
000019BE  43F9 00001B72           1842              LEA         invalCh,A1
000019C4  103C 000E               1843              MOVE.B      #14,D0
000019C8  4E4F                    1844              TRAP        #15
000019CA                          1845              
000019CA  6000 F6A0               1846              BRA         startingPrompt
000019CE                          1847            
000019CE                          1848  oddError:
000019CE  43F9 00001B93           1849              LEA         odd,A1
000019D4  103C 000E               1850              MOVE.B      #14,D0
000019D8  4E4F                    1851              TRAP        #15
000019DA                          1852              
000019DA  6000 F690               1853              BRA         startingPrompt
000019DE                          1854              
000019DE                          1855  manyCharError:  
000019DE  43F9 00001BC0           1856              LEA         manyChar, A1
000019E4  103C 000E               1857              MOVE.B      #14,D0
000019E8  4E4F                    1858              TRAP        #15
000019EA                          1859              
000019EA  6000 F680               1860              BRA         startingPrompt
000019EE                          1861           
000019EE                          1862  endGreater:
000019EE  43F9 00001BFB           1863              LEA         endG,A1
000019F4  103C 000E               1864              MOVE.B      #14,D0
000019F8  4E4F                    1865              TRAP        #15
000019FA                          1866              
000019FA  6000 F670               1867              BRA         startingPrompt
000019FE                          1868      
000019FE                          1869  ;-----------------------------------------------------------
000019FE                          1870  ;MESSAGES
000019FE                          1871  ;-----------------------------------------------------------
000019FE= 57 65 6C 63 6F 6D ...   1872  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001A22= 50 6C 65 61 73 65 ...   1873  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001A64= 50 6C 65 61 73 65 ...   1874  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001AA4= 0D 0A 41 64 64 72 ...   1875  AddressNum  DC.B        CR,LF,'Address: ',0
00001AB0                          1876  
00001AB0                          1877  ;-----------------------------------------------------------
00001AB0                          1878  ;OPCODE Messages
00001AB0                          1879  ;-----------------------------------------------------------
00001AB0= 4E 4F 50 00             1880  printNOP    DC.B        'NOP',0
00001AB4= 4D 4F 56 45 00          1881  printMOVE   DC.B        'MOVE',0
00001AB9= 4D 4F 56 45 4D 00       1882  printMOVEM  DC.B        'MOVEM',0
00001ABF= 41 44 44 00             1883  printADD    DC.B        'ADD',0
00001AC3= 41 44 44 49 00          1884  printADDI   DC.B        'ADDI',0
00001AC8= 53 55 42 00             1885  printSUB    DC.B        'SUB',0
00001ACC= 53 55 42 49 00          1886  printSUBI   DC.B        'SUBI',0
00001AD1= 4D 55 4C 53 2E 57 ...   1887  printMULS   DC.B        'MULS.W ',0
00001AD9= 44 49 56 55 2E 57 ...   1888  printDIVU   DC.B        'DIVU.W ',0
00001AE1= 4C 45 41 20 00          1889  printLEA    DC.B        'LEA ',0
00001AE6= 41 4E 44 00             1890  printAND    DC.B        'AND',0
00001AEA= 4E 4F 54 00             1891  printNOT    DC.B        'NOT',0
00001AEE= 4C 53 4C 00             1892  printLSL    DC.B        'LSL',0
00001AF2= 4C 53 52 00             1893  printLSR    DC.B        'LSR',0
00001AF6= 41 53 4C 00             1894  printASL    DC.B        'ASL',0
00001AFA= 41 53 52 00             1895  printASR    DC.B        'ASR',0
00001AFE= 42 4C 54 00             1896  printBLT    DC.B        'BLT',0
00001B02= 42 47 45 00             1897  printBGE    DC.B        'BGE',0
00001B06= 42 45 51 00             1898  printBEQ    DC.B        'BEQ',0
00001B0A= 4A 53 52 20 00          1899  printJSR    DC.B        'JSR ',0
00001B0F= 52 54 53 00             1900  printRTS    DC.B        'RTS',0
00001B13= 42 52 41 00             1901  printBRA    DC.B        'BRA',0
00001B17= 41 53 00                1902  printMAS    DC.B        'AS',0
00001B1A= 4C 53 00                1903  printMLS    DC.B        'LS',0
00001B1D= 4C 00                   1904  printL      DC.B        'L',0    
00001B1F= 52 00                   1905  printR      DC.B        'R',0
00001B21                          1906  ;-----------------------------------------------------------
00001B21                          1907  ;Size Messages
00001B21                          1908  ;-----------------------------------------------------------
00001B21= 2E 42 20 00             1909  printSIZEB  DC.B        '.B ',0
00001B26= 2E57 2000 0000          1910  printSIZEW  DC.W        '.W ',0
00001B2C= 2E4C2000 00000000       1911  printSIZEL  DC.L        '.L ',0
00001B34                          1912  
00001B34                          1913  ;-----------------------------------------------------------
00001B34                          1914  ;Addressing Mode Messages
00001B34                          1915  ;-----------------------------------------------------------
00001B34= 44 00                   1916  printDRD      DC.B        'D',0
00001B36= 41 00                   1917  printARD      DC.B        'A',0
00001B38= 28 41 00                1918  printARI      DC.B        '(A',0
00001B3B= 29 00                   1919  printARI2     DC.B        ')',0
00001B3D= 23 00                   1920  printIA       DC.B        '#',0
00001B3F= 24 00                   1921  printA        DC.B        '$',0
00001B41= 28 41 00                1922  printPI       DC.B        '(A',0
00001B44= 29 2B 00                1923  printPI2      DC.B        ')+',0
00001B47= 2D 28 41 00             1924  printPD       DC.B        '-(A',0
00001B4B= 29 00                   1925  printPD2      DC.B        ')',0
00001B4D                          1926  
00001B4D= 2C 00                   1927  printComma    DC.B        ',',0
00001B4F= 20 00                   1928  printSpace    DC.B        ' ',0
00001B51                          1929  
00001B51= 0D 0A 59 6F 75 20 ...   1930  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001B72                          1931  
00001B72                          1932  ;-----------------------------------------------------------
00001B72                          1933  ;ERRORS
00001B72                          1934  ;-----------------------------------------------------------
00001B72= 45 52 52 4F 52 3A ...   1935  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001B93= 45 52 52 4F 52 3A ...   1936  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001BC0= 45 52 52 4F 52 3A ...   1937  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001BFB= 45 52 52 4F 52 3A ...   1938  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00001C40= 45 52 52 4F 52 3A ...   1939  sizeError   DC.B        'ERROR: Invalid size instruction',0
00001C60= 45 52 52 4F 52 3A ...   1940  invalOpcode DC.B        'ERROR: INVALID OPCODE = ',0
00001C79                          1941  
00001C79                          1942  ;-----------------------------------------------------------
00001C79                          1943  ;Ending function that ends our program 
00001C79                          1944  ;-----------------------------------------------------------
00001C79                          1945  ending:
00001C7A  43F8 1B51               1946              LEA         theEnd,A1
00001C7E  303C 000E               1947              MOVE        #14,D0
00001C82  4E4F                    1948              TRAP        #15
00001C84                          1949              
00001C84                          1950              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1972
ABSOLUTE            194C
ADDRESSMODESR       1860
ADDRESSNUM          1AA4
ARD                 18A4
ARI                 18B8
CHARERROR           19BE
CONTINUEDIVU        14B0
CONVERT             10C0
CR                  D
DNDEST              1778
DNSOURCE            179C
DRD                 1890
ENDG                1BFB
ENDGREATER          19EE
ENDHEX              1004
ENDING              1C79
ENDINGPROMPT        1098
GETBITS             124A
IMDLONG             198A
IMMEDIATE           192C
IMMEDIATECOUNT      1612
IMMEDIATECOUNT2     163A
INOPCODE            121C
INVALCH             1B72
INVALOPCODE         1C60
ISOADDBIT0TO5       130E
ISOLATEADDRESSBIT0TO5  17C0
ISOLATEADDRESSBIT6TO11  138C
ISOLATEREGISTERBIT9TO11  17E6
LETTER              10E4
LF                  A
LOOP                1174
M00                 1334
M0000               1260
M0100               13B2
M0110               1494
M1000               1494
M1001               14C0
M1100               1504
M1101               1734
M1110               1578
MADDI               1280
MAIN                1000
MAND                1548
MANYCHAR            1BC0
MANYCHARERROR       19DE
MAS                 16AC
MBEQ                1494
MBGE                1494
MBLT                1494
MBRA                1494
MEFFECT             12EC
MEMAS               167E
MEMDIRECTIONSUBROUTINE  16BA
MEMLS               1686
MEMSHIFT            1648
MEMSHIFT2           1666
MJSR                147C
ML                  16E6
MLEA                1420
MLS                 169E
MMULS               1538
MNOT                1450
MORECHECKS          1114
MORECHECKS1         1120
MORECHECKS2         1142
MOVEM               1414
MR                  16D8
MSOURCEDEST         136A
MSUBI               12B4
MULSCHECK           1522
NUMBER              10F8
ODD                 1B93
ODDERROR            19CE
OTHERMODES          1918
PBYTE               1836
PD                  18F8
PI                  18D8
PLONG               1852
PRINTA              1B3F
PRINTADD            1ABF
PRINTADDI           1AC3
PRINTAND            1AE6
PRINTARD            1B36
PRINTARI            1B38
PRINTARI2           1B3B
PRINTASL            1AF6
PRINTASR            1AFA
PRINTBEQ            1B06
PRINTBGE            1B02
PRINTBLT            1AFE
PRINTBRA            1B13
PRINTCOMMA          1B4D
PRINTDIVU           1AD9
PRINTDRD            1B34
PRINTIA             1B3D
PRINTJSR            1B0A
PRINTL              1B1D
PRINTLEA            1AE1
PRINTLSL            1AEE
PRINTLSR            1AF2
PRINTMAS            1B17
PRINTMLS            1B1A
PRINTMNOP           199E
PRINTMOVE           1AB4
PRINTMOVEM          1AB9
PRINTMOVESIZE       181E
PRINTMRTS           19AE
PRINTMULS           1AD1
PRINTNOP            1AB0
PRINTNOT            1AEA
PRINTPD             1B47
PRINTPD2            1B4B
PRINTPI             1B41
PRINTPI2            1B44
PRINTR              1B1F
PRINTRTS            1B0F
PRINTSIZEB          1B21
PRINTSIZEL          1B2C
PRINTSIZESUBROUTINE  17FE
PRINTSIZEW          1B26
PRINTSPACE          1B4F
PRINTSUB            1AC8
PRINTSUBI           1ACC
PWORD               1844
REGAS               168E
REGDIRECTIONSUBROUTINE  16F6
REGLS               1696
REGSHIFT            15B0
REGSHIFT2           15E8
RL                  1724
RR                  1714
SHIFTEIGHT          1642
SIZEERROR           1C40
SKIPA6              123C
SKIPCOPY            1920
STAHEX              1000
STARTINGPROMPT      106C
TESTING             101A
THEEND              1B51
UPDATE              1234
USEREA              1A64
USERSA              1A22
WELCOME             19FE
