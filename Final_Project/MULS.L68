00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/1/2021 3:00:23 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 000010B8             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29    
00001014                            30  startingPrompt:
00001014                            31            
00001014                            32              ;Ask the user for the starting hex
00001014  43F9 000010DC             33              LEA         userSA,A1
0000101A  103C 000E                 34              MOVE.B      #14,D0
0000101E  4E4F                      35              TRAP        #15
00001020                            36              
00001020                            37              ;Input for the hex (D1 equals number of chars)
00001020  303C 0002                 38              MOVE.W      #2,D0
00001024  4E4F                      39              TRAP        #15
00001026                            40              
00001026  2449                      41              MOVEA.L     A1,A2
00001028                            42         
00001028                            43  convert:    
00001028                            44              ;See if our counter variable is 0
00001028  B23C 0000                 45              CMP.B       #0,D1
0000102C                            46              ;This means that we have gone through all the characters
0000102C  6700 003E                 47              BEQ         moreChecks
00001030                            48              
00001030                            49              ;Decrement the counter, this means we're about to go through another char
00001030  5301                      50              SUB.B       #1,D1
00001032                            51  
00001032                            52              ;Let's move the byte stored at A1, and post increment A1
00001032  1611                      53              MOVE.B      (A1),D3
00001034                            54              
00001034                            55              ;If the byte is greater than or equal to hex $40, then it's a letter
00001034  B63C 0041                 56              CMP.B       #$41,D3
00001038  6C00 000A                 57              BGE         letter
0000103C                            58              
0000103C                            59              ;If the byte is less than or equal to hex $39, then it's a number
0000103C  B63C 0040                 60              CMP.B       #$40,D3
00001040  6F00 0012                 61              BLE         number
00001044                            62              
00001044                            63  letter:
00001044                            64              ;We do this check to see if the character is greater than or equal 'G'
00001044  B63C 0047                 65              CMP.B       #$47,D3
00001048                            66              ;If so, then display an error and ask the user to enter startingAdd again
00001048  6C00 004E                 67              BGE         charError
0000104C                            68              
0000104C                            69              ;Subtract the Ascii value to convert to hex
0000104C  0403 0037                 70              SUB.B       #$37,D3
00001050                            71              ;Move the value back to our register
00001050  12C3                      72              MOVE.B      D3,(A1)+
00001052                            73              
00001052  60D4                      74              BRA         convert
00001054                            75              
00001054                            76  
00001054                            77  number:          
00001054                            78             ;We do this check to see if the character is less than or equal to '/'  
00001054  B63C 002F                 79             CMP.B        #$2F,D3
00001058                            80             ;If so, then display an error and ask the user to enter startingAdd again
00001058  6F00 003E                 81             BLE          charError     
0000105C                            82   
0000105C                            83             ;Check to see if the character is greater than or equal to ':'
0000105C  B63C 003A                 84             CMP.B        #$3A,D3
00001060                            85             ;If so, then display an error and ask the user to enter startingAdd again
00001060  6C00 0036                 86             BGE          charError
00001064                            87            
00001064                            88             ;Subtract the Ascii value to convert to hex
00001064  0403 0030                 89             SUB.B        #$30,D3
00001068                            90             ;Move the value back to our register
00001068  12C3                      91             MOVE.B       D3,(A1)+
0000106A                            92   
0000106A  60BC                      93             BRA convert
0000106C                            94   
0000106C                            95  
0000106C                            96  moreChecks:
0000106C                            97              
0000106C                            98              ;Move the actual hex value into our variable
0000106C  21D2 1000                 99              MOVE.L      (A2),staHex
00001070                           100              
00001070                           101              ;Copy the hex value into a temp register
00001070  2812                     102              MOVE.L      (A2),D4
00001072                           103              
00001072                           104              
00001072  1A3C 001F                105              MOVE.B      #31,D5
00001076                           106              
00001076  EBAC                     107              LSL.L       D5,D4
00001078                           108  
00001078  EAAC                     109              LSR.L       D5,D4
0000107A                           110  
0000107A  B83C 0001                111              CMP.B       #1,D4
0000107E  6700 0028                112              BEQ         oddError
00001082                           113                    
00001082                           114                          
00001082                           115              
00001082                           116              
00001082                           117              ;A42A
00001082                           118              ;0000 0000 0000 0000 1010 0100 0010 1010
00001082                           119              ;shift left 31 (1010 0000.....)   
00001082                           120              ;shift right 31 times (0000..... 1010)
00001082                           121              ;compare 1,3,5,7,9,B,D,F with A
00001082                           122              ;if even continue work
00001082                           123              ;if odd
00001082                           124              ;   return error
00001082                           125              ;   BRA startingPrompt
00001082                           126              
00001082                           127              
00001082                           128              ;If more than 8 bytes
00001082                           129              ;      return error
00001082                           130              ;      BRA      startingPrompt
00001082                           131              ;
00001082                           132              
00001082                           133              ;Reaches here if the hex number is good
00001082                           134              ;BRA       endingPrompt
00001082                           135              
00001082                           136              
00001082                           137  endingPrompt:
00001082                           138              
00001082                           139              ;Ask the user for the ending hex
00001082  43F9 0000111E            140              LEA         userEA,A1
00001088  103C 000E                141              MOVE.B      #14,D0
0000108C  4E4F                     142              TRAP        #15
0000108E                           143              
0000108E                           144              ;Input for the hex (D1 equals number of chars)
0000108E  303C 000E                145              MOVE.W      #14,D0
00001092  4E4F                     146              TRAP        #15
00001094                           147              
00001094  31C1 1004                148              MOVE.W      D1,endHex
00001098                           149              
00001098                           150              ;Place one character on a stack, if end of stack, then go to endingPrompt
00001098                           151              ;   if between $41 and $46 [included] (Meaning the character is a letter)
00001098                           152              ;        BRA    letter
00001098                           153              ;
00001098                           154              ;   if between $30 and $39 [included] (Meaning the character is a number)
00001098                           155              ;        BRA    number
00001098                           156              ;
00001098                           157              ;   Else, the characters is a special one, 
00001098                           158              ;        return error
00001098                           159              ;        BRA    startingPrompt
00001098                           160              ;
00001098                           161              ;Loop byte-by-byte through the hex until the end (Right-most digit)
00001098                           162              
00001098                           163              ;Move the converted hex into staHex
00001098                           164              
00001098                           165              ;Compare the ending address w/ starting
00001098                           166              ;if endAdd is less than staAdd
00001098                           167              ;    return error
00001098                           168              ;    BRA    endingPrompt
00001098                           169      
00001098                           170              ;A42A
00001098                           171              ;0000 0000 0000 0000 1010 0100 0010 1010
00001098                           172              ;shift left 28 (1010 0000.....)
00001098                           173              ;shift right 28 times (0000..... 1010)
00001098                           174              ;compare 1,3,5,7,9,B,D,F with A
00001098                           175              ;if even continue work
00001098                           176              ;if odd
00001098                           177              ;   return error
00001098                           178              ;   BRA startingPrompt
00001098                           179  
00001098                           180              ;If more than 8 bytes
00001098                           181              ;      return error
00001098                           182              ;      BRA      startingPrompt
00001098                           183              ;
00001098                           184  
00001098                           185      
00001098                           186  
00001098                           187  charError:
00001098                           188              
00001098  43F9 0000117E            189              LEA         invalCh,A1
0000109E  103C 000E                190              MOVE.B      #14,D0
000010A2  4E4F                     191              TRAP        #15
000010A4                           192              
000010A4  6000 FF6E                193              BRA         startingPrompt
000010A8                           194            
000010A8                           195  oddError:
000010A8  43F9 0000119F            196              LEA         odd,A1
000010AE  103C 000E                197              MOVE.B      #14,D0
000010B2  4E4F                     198              TRAP        #15
000010B4                           199              
000010B4  6000 FF5E                200              BRA         startingPrompt
000010B8                           201              
000010B8                           202  ;-----------------------------------------------------------
000010B8                           203  ;MESSAGES
000010B8                           204  ;-----------------------------------------------------------
000010B8= 57 65 6C 63 6F 6D ...    205  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
000010DC= 50 6C 65 61 73 65 ...    206  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
0000111E= 50 6C 65 61 73 65 ...    207  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
0000115E                           208  
0000115E                           209  ;-----------------------------------------------------------
0000115E                           210  ;ERRORS
0000115E                           211  ;-----------------------------------------------------------
0000115E= 45 52 52 4F 52 3A ...    212  toobig      DC.B        'ERROR: The address is too big',CR,LF,0
0000117E= 45 52 52 4F 52 3A ...    213  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
0000119F= 45 52 52 4F 52 3A ...    214  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
000011CC                           215  
000011CC                           216  
000011CC                           217  
000011CC                           218  *-----------------------------------------------------------
000011CC                           219  * OpCode Implementation
000011CC                           220  *-----------------------------------------------------------
000011CC                           221  *-----------------------------------------------------------
000011CC                           222  * Addressing Mode Implementation
000011CC                           223  *-----------------------------------------------------------
000011CC                           224  
000011CC                           225      END    MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CHARERROR           1098
CONVERT             1028
CR                  D
ENDHEX              1004
ENDINGPROMPT        1082
INVALCH             117E
LETTER              1044
LF                  A
MAIN                1000
MORECHECKS          106C
NUMBER              1054
ODD                 119F
ODDERROR            10A8
STAHEX              1000
STARTINGPROMPT      1014
TOOBIG              115E
USEREA              111E
USERSA              10DC
WELCOME             10B8
