00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/4/2021 10:10:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  
00001008                            15  ;Used for MOVEM
00001008= 00                        16  counter:    DC.B        $0
00001009= 00                        17  totalCount: DC.B        $0
0000100A= 00                        18  dORa:       DC.B        $0
0000100C= 0000                      19  curAdd:     DC.W        $0
0000100E= 00                        20  movemAdd:   DC.B        $0
0000100F= 00                        21  listSize:   DC.B        $0
00001010                            22  *-----------------------------------------------------------
00001010                            23  * I/O Implementation
00001010                            24  ;1. Prompt user for start and ending addresses (In hex)
00001010                            25  ;2. User inputs their values
00001010                            26  ;3. Check for errors
00001010                            27  ;        Check to see if hex is too big
00001010                            28  ;        Check to see value doesn't contain G-Z
00001010                            29  ;        Check to see if there are no commas/special chars
00001010                            30  ;        Check to see that starting loc, is before ending loc
00001010                            31  ;        Check to see if value starts at odd mem location
00001010                            32  *-----------------------------------------------------------
00001010                            33  
00001010                            34             ;Show welcome to user
00001010  43F9 00001DCA             35              LEA         Welcome,A1
00001016  103C 000E                 36              MOVE.B      #14,D0
0000101A  4E4F                      37              TRAP        #15                                  
0000101C                            38              
0000101C                            39              
0000101C  8AF8 1234                 40              DIVU.W   $1234, D5
00001020                            41  
00001020                            42  ;==========================            
00001020                            43              
00001020                            44  startingPrompt:
00001020                            45              ;Ask the user for the starting hex3
00001020  43F9 00001DEE             46              LEA         userSA,A1
00001026  103C 000E                 47              MOVE.B      #14,D0
0000102A  4E4F                      48              TRAP        #15        
0000102C                            49              
0000102C                            50              ;Clear the registers in case we had an error
0000102C  227C 00000000             51              MOVE.L      #0,A1
00001032  247C 00000000             52              MOVE.L      #0,A2
00001038  4283                      53              CLR.L       D3
0000103A  4284                      54              CLR.L       D4
0000103C  4285                      55              CLR.L       D5
0000103E  4286                      56              CLR.L       D6
00001040                            57             
00001040                            58              
00001040                            59              ;Input for the hex (D1 equals number of chars)
00001040  303C 0002                 60              MOVE.W      #2,D0
00001044  4E4F                      61              TRAP        #15
00001046                            62              
00001046                            63              ;Moves A1 into A2      
00001046                            64              ;MOVEA.L     A1,A2
00001046                            65              
00001046                            66              ;Makes sure D7 is clear incase we're looping back after an error.
00001046  4207                      67              CLR.B       D7
00001048                            68              
00001048  6000 002A                 69              BRA         convert  
0000104C                            70              
0000104C                            71  endingPrompt:
0000104C                            72              ;D7 is if we're working with the first or second prompt, used in the more checks section. 
0000104C  1E3C 0001                 73              MOVE.B       #1,D7
00001050                            74              
00001050                            75              ;Ask the user for the ending hex
00001050  43F9 00001E30             76              LEA         userEA,A1
00001056  103C 000E                 77              MOVE.B      #14,D0
0000105A  4E4F                      78              TRAP        #15
0000105C                            79              
0000105C                            80              ;Clearing the registers so we can reuse them for the ending address
0000105C  227C 00000000             81              MOVE.L      #0,A1
00001062  247C 00000000             82              MOVE.L      #0,A2
00001068  4286                      83              CLR.L       D6
0000106A                            84  
0000106A                            85              ;Input for the hex (D1 equals number of chars)
0000106A  303C 0002                 86              MOVE.W      #2,D0
0000106E  4E4F                      87              TRAP        #15
00001070                            88              
00001070                            89              ;Moves A1 into A2      
00001070                            90              ;MOVEA.L     A1,A2
00001070                            91              
00001070  6000 0002                 92              BRA         convert
00001074                            93  
00001074                            94  convert:    
00001074                            95              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001074  B23C 0008                 96              CMP.B       #8, D1
00001078  6E00 0D30                 97              BGT         manyCharError  
0000107C                            98              
0000107C                            99              ;See if our counter variable is 0
0000107C  B23C 0000                100              CMP.B       #0,D1
00001080                           101              
00001080                           102              ;This means that we have gone through all the characters
00001080  6700 0046                103              BEQ         moreChecks
00001084                           104              
00001084                           105              ;Decrement the counter, this means we're about to go through another char
00001084  5301                     106              SUB.B       #1,D1
00001086                           107  
00001086                           108              ;Let's move the byte stored at A1
00001086  1612                     109              MOVE.B      (A2),D3
00001088                           110              
00001088                           111              ;If the byte is greater than or equal to hex $40, then it's a letter
00001088  B63C 0041                112              CMP.B       #$41,D3
0000108C  6C00 000A                113              BGE         letter
00001090                           114              
00001090                           115              ;If the byte is less than or equal to hex $39, then it's a number
00001090  B63C 0040                116              CMP.B       #$40,D3
00001094  6F00 0016                117              BLE         number
00001098                           118              
00001098                           119  letter:
00001098                           120              ;We do this check to see if the character is greater than or equal 'G'
00001098  B63C 0047                121              CMP.B       #$47,D3
0000109C                           122              ;If so, then display an error and ask the user to enter startingAdd again
0000109C  6C00 0CEC                123              BGE         charError
000010A0                           124              
000010A0                           125              ;Subtract the Ascii value to convert to hex
000010A0  0403 0037                126              SUB.B       #$37,D3
000010A4                           127              ;Move the value back to our register
000010A4  14C3                     128              MOVE.B      D3,(A2)+
000010A6                           129              
000010A6                           130              ;Shift D5 left to make room for next hex value
000010A6  E986                     131              ASL.L       #4, D6
000010A8                           132              ;Move value to D5
000010A8  DC03                     133              ADD.B      D3, D6
000010AA                           134              
000010AA  60C8                     135              BRA         convert
000010AC                           136             
000010AC                           137  
000010AC                           138  number:          
000010AC                           139             ;We do this check to see if the character is less than or equal to '/'  
000010AC  B63C 002F                140             CMP.B        #$2F,D3
000010B0                           141             ;If so, then display an error and ask the user to enter startingAdd again
000010B0  6F00 0CD8                142             BLE          charError     
000010B4                           143   
000010B4                           144             ;Check to see if the character is greater than or equal to ':'
000010B4  B63C 003A                145             CMP.B        #$3A,D3
000010B8                           146             ;If so, then display an error and ask the user to enter startingAdd again
000010B8  6C00 0CD0                147             BGE          charError
000010BC                           148            
000010BC                           149             ;Subtract the Ascii value to convert to hex
000010BC  0403 0030                150             SUB.B        #$30,D3
000010C0                           151             ;Move the value back to our register
000010C0  14C3                     152             MOVE.B       D3,(A2)+
000010C2                           153   
000010C2                           154             ;Shift D5 left to make room for next hex value
000010C2  E986                     155             ASL.L        #4, D6
000010C4                           156             ;Move value to D5
000010C4  DC03                     157             ADD.B        D3, D6
000010C6                           158              
000010C6  60AC                     159             BRA          convert
000010C8                           160   
000010C8                           161            
000010C8                           162  moreChecks:
000010C8                           163              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010C8  BE3C 0001                164              CMP.B      #1,D7
000010CC  6700 0028                165              BEQ        moreChecks2
000010D0                           166              
000010D0  6000 0002                167              BRA        moreChecks1
000010D4                           168   
000010D4                           169  moreChecks1:
000010D4                           170              
000010D4                           171              ;Copy the hex value into a temp register
000010D4  2806                     172              MOVE.L      D6,D4
000010D6                           173              
000010D6                           174              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010D6  1A3C 001F                175              MOVE.B      #31,D5
000010DA                           176              
000010DA                           177              ;Shifts 31 bits, isolates last bit. 
000010DA  EBAC                     178              LSL.L       D5,D4
000010DC                           179  
000010DC                           180              ;Shifts it back 31 bit, isolating the last bit. 
000010DC  EAAC                     181              LSR.L       D5,D4
000010DE                           182  
000010DE                           183              ;If the last bit is 1, address was odd, and throw an error. 
000010DE  B83C 0001                184              CMP.B       #1,D4
000010E2  6700 0CB6                185              BEQ         oddError   
000010E6                           186                          
000010E6                           187              ;Reset address registers.
000010E6  247C 00000000            188              MOVE.L      #0,A2
000010EC                           189              
000010EC                           190              ;Copy the value to our staHex variable
000010EC  21C6 1000                191              MOVE.L      D6,staHex 
000010F0                           192              
000010F0  4286                     193              CLR.L       D6
000010F2  6000 FF58                194              BRA         endingPrompt     
000010F6                           195              
000010F6                           196  moreChecks2:       
000010F6                           197              
000010F6                           198              ;Copy the hex value into a temp register
000010F6  2806                     199              MOVE.L      D6,D4
000010F8                           200              
000010F8                           201              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010F8  1A3C 001F                202              MOVE.B      #31,D5
000010FC                           203              
000010FC                           204              ;Shifts 31 bits, isolates last bit. 
000010FC  EBAC                     205              LSL.L       D5,D4
000010FE                           206  
000010FE                           207              ;Shifts it back 31 bit, isolating the last bit. 
000010FE  EAAC                     208              LSR.L       D5,D4
00001100                           209  
00001100                           210              ;If the last bit is 1, address was odd, and throw an error. 
00001100  B83C 0001                211              CMP.B       #1,D4
00001104  6700 0C94                212              BEQ         oddError   
00001108                           213                          
00001108                           214              ;Reset address registers.
00001108  247C 00000000            215              MOVE.L      #0,A2
0000110E                           216              
0000110E                           217              ;Place the value in our ending hex variable
0000110E  21C6 1004                218              MOVE.L      D6,endHex 
00001112                           219              
00001112                           220              ;Make D7 a temp location to compare our starting hex
00001112  2E38 1000                221              MOVE.L      staHex,D7
00001116                           222           
00001116                           223              
00001116                           224              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001116  BC87                     225              CMP.L       D7,D6
00001118  6B00 0CA0                226              BMI         endGreater
0000111C                           227              
0000111C                           228              ;done, start reading memory. 
0000111C                           229              
0000111C                           230              ;Clear all the registers since we have the addresses stored in our variables
0000111C  4283                     231              CLR.L       D3
0000111E  4285                     232              CLR.L       D5
00001120  4286                     233              CLR.L       D6
00001122  4287                     234              CLR.L       D7  
00001124                           235              
00001124                           236              ;Copy the value of our starting hex to A2 (temp register)
00001124  2478 1000                237              MOVEA.L     staHex,A2
00001128                           238                          
00001128                           239              
00001128                           240  LOOP:   
00001128                           241              ;We will be printing out the address, regardless if the opcode is valid or not
00001128  43F9 00001E70            242              LEA         AddressNum,A1
0000112E  103C 000E                243              MOVE.B      #14,D0
00001132  4E4F                     244              TRAP        #15
00001134                           245              
00001134                           246              ;Print out the address
00001134  220A                     247              MOVE.L      A2,D1
00001136  6100 0C26                248              BSR         hex_L
0000113A                           249              
0000113A                           250              
0000113A  43F9 00001F29            251              LEA         printSpace,A1
00001140  103C 000E                252              MOVE.B      #14,D0
00001144  4E4F                     253              TRAP        #15
00001146                           254  
00001146                           255              ;--------------------------------------------------------
00001146                           256              ;Check for NOP or RTS
00001146                           257              ;--------------------------------------------------------
00001146                           258              
00001146                           259              ;Move the NOP binary value for comparing
00001146  243C 00004E71            260              MOVE.L      #%0100111001110001,D2
0000114C                           261              
0000114C                           262              ;Check and see i the instruction is NOP
0000114C  B452                     263              CMP.W       (A2),D2
0000114E  6700 0BEE                264              BEQ         printMNOP
00001152                           265              
00001152                           266              ;Move the RTS binary value for comparing
00001152  243C 00004E75            267              MOVE.L      #%0100111001110101,D2
00001158                           268              
00001158                           269              ;Check and see if the instruction is RTS
00001158  B452                     270              CMP.W       (A2),D2
0000115A  6700 0BF2                271              BEQ         printMRTS
0000115E                           272              
0000115E                           273              ;Clear the contents for reusing
0000115E  4282                     274              CLR.L       D2
00001160                           275              
00001160                           276              ;--------------------------------------------------------
00001160                           277              ;Check for ADDI or SUBI, check for four 0's since it's the only
00001160                           278              ;opcode with this pattern
00001160                           279              ;--------------------------------------------------------  
00001160                           280              ;Move the value in A2 to a temp register
00001160  3412                     281              MOVE.W      (A2),D2
00001162                           282              
00001162                           283              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001162  163C 000C                284              MOVE.B      #12,D3
00001166  183C 0004                285              MOVE.B      #4,D4
0000116A                           286              
0000116A                           287              ;Jumps to getBits and returns with isolated bits in D2
0000116A  6100 009C                288              BSR         getBits
0000116E                           289              
0000116E  B43C 0000                290              CMP.B       #%0000,D2
00001172  6700 00AA                291              BEQ         M0000
00001176                           292              
00001176                           293              ;--------------------------------------------------------
00001176                           294              ;Check for MOVE, since it's the only word starting with 00
00001176                           295              ;--------------------------------------------------------            
00001176                           296              ;Move the value in A2 to a temp register
00001176  1412                     297              MOVE.B      (A2),D2
00001178                           298              
00001178                           299              ;Shift 6 bits to the right to isolate the left-most digits
00001178  EC8A                     300              LSR.L       #6,D2
0000117A                           301              
0000117A                           302              ;If the first two bits (left-most) are 00, then the instruction is MOVE
0000117A  B43C 0000                303              CMP.B       #00,D2
0000117E  6F00 018C                304              BLE         M00
00001182                           305              
00001182                           306              ;Reuse the register
00001182  4282                     307              CLR.L       D2
00001184                           308              
00001184                           309              
00001184                           310              ;--------------------------------------------------------
00001184                           311              ;Check for other OpCodes
00001184                           312              ;--------------------------------------------------------
00001184                           313              ;Move the word into a temp register 
00001184  3412                     314              MOVE.W      (A2),D2
00001186                           315              
00001186                           316              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001186  163C 000C                317              MOVE.B        #12,D3            ;Start bit index = 12
0000118A  183C 0004                318              MOVE.B        #4,D4             ;Number of bits needed = 4
0000118E                           319              
0000118E                           320              ;Jumps to getBits and returns with isolated bits in D2
0000118E  6100 0078                321              BSR           getBits            
00001192                           322  
00001192                           323              
00001192                           324              ;MOVEM,LEA,NOT,JSR
00001192  B43C 0004                325              CMP.B       #%0100,D2
00001196  6700 01FC                326              BEQ         M0100
0000119A                           327              
0000119A                           328              ;BRA,BLT,BGE,BEQ
0000119A  B43C 0006                329              CMP.B       #%0110,D2
0000119E  6700 04E4                330              BEQ         M0110
000011A2                           331              
000011A2                           332              ;DIVU
000011A2  B43C 0008                333              CMP.B       #%1000,D2
000011A6  6700 0658                334              BEQ         M1000
000011AA                           335              
000011AA                           336              ;SUB
000011AA  B43C 0009                337              CMP.B       #%1001,D2
000011AE  6700 0680                338              BEQ         M1001
000011B2                           339              
000011B2                           340              ;MULS,AND
000011B2  B43C 000C                341              CMP.B       #%1100,D2
000011B6  6700 06BC                342              BEQ         M1100
000011BA                           343              
000011BA                           344              ;LSL,LSR,ASL,ASR
000011BA  B43C 000E                345              CMP.B       #%1110,D2
000011BE  6700 072C                346              BEQ         M1110
000011C2                           347              
000011C2                           348              ;ADD
000011C2  B43C 000D                349              CMP.B       #%1101,D2
000011C6  6700 0904                350              BEQ         M1101
000011CA                           351              
000011CA                           352              ;If the first 4 bits do not match any of the opcodes listed
000011CA                           353              ;then we must have an invalid opcode
000011CA  6100 0006                354              BSR         invalid
000011CE                           355              
000011CE  6000 0E8A                356              BRA         ending                    
000011D2                           357              
000011D2                           358  invalid:
000011D2  43F9 0000203E            359              LEA         invalOpcode,A1
000011D8  103C 000E                360              MOVE.B      #14,D0
000011DC  4E4F                     361              TRAP        #15
000011DE                           362  
000011DE                           363              ;Clear any previous data that might have been there
000011DE  4281                     364              CLR.L      D1
000011E0                           365  
000011E0                           366              ;Print out the hex value from the address
000011E0  320A                     367              MOVE.W      A2,D1
000011E2  6100 0B7A                368              BSR         hex_L
000011E6                           369  
000011E6                           370  
000011E6  6000 0002                371              BRA         update
000011EA                           372             
000011EA                           373  update:
000011EA                           374              *=====Important if we've done any Immediate or Absolute addressing=====*
000011EA                           375              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
000011EA                           376              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
000011EA                           377              ;because A2 always points at the the first word in an instruction (opcode).
000011EA  B5CE                     378              CMP.L       A6,A2
000011EC  6C00 0004                379              BGE         skipA6
000011F0                           380              
000011F0                           381              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
000011F0  244E                     382              MOVEA.L     A6,A2
000011F2                           383              
000011F2                           384  skipA6:
000011F2                           385              ;Check and see if we are at the ending hex
000011F2  B5F8 1004                386              CMP.L      endHex,A2
000011F6  6E00 0E62                387              BGT        ending
000011FA                           388  
000011FA                           389              ;Update address in A2
000011FA  544A                     390              ADD.W      #2,A2
000011FC                           391              
000011FC                           392              ;Clear size storage 
000011FC  21FC 00000000 2000       393              MOVE.L     #$00000000,$2000
00001204                           394              
00001204  6000 FF22                395              BRA        LOOP
00001208                           396              
00001208                           397              
00001208                           398  getBits:
00001208                           399              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
00001208                           400              ;PARAMETERS:
00001208                           401              ;D2 = the value the bits are extracted from & saved back in
00001208                           402              ;D3 = the start bit index (starting from 0)
00001208                           403              ;D4 = the number of bits we want to extract
00001208                           404              
00001208                           405              ;Calculate left shift
00001208  3A3C 0010                406              MOVE.W      #16,D5
0000120C                           407              
0000120C  D843                     408              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
0000120E  9A44                     409              SUB.W       D4,D5             ; 16 - X = leftShift
00001210                           410              
00001210  EB6A                     411              LSL.W       D5,D2
00001212                           412              
00001212                           413              
00001212                           414              ;Calculate right shift
00001212  DA43                     415              ADD.W       D3,D5             ; start bit + leftShift = X
00001214  EA6A                     416              LSR.W       D5,D2
00001216                           417              
00001216  4283                     418              CLR.L       D3
00001218  4284                     419              CLR.L       D4
0000121A  4285                     420              CLR.L       D5   
0000121C  4E75                     421              RTS
0000121E                           422  
0000121E                           423  *-----------------------------------------------------------
0000121E                           424  * 
0000121E                           425  *
0000121E                           426  *
0000121E                           427  * OpCode Implementation
0000121E                           428  *
0000121E                           429  *
0000121E                           430  *
0000121E                           431  *-----------------------------------------------------------
0000121E                           432  
0000121E                           433  
0000121E                           434  *-----------------------------------------------------------
0000121E                           435  * ADDI/SUBI INSTRUCTION
0000121E                           436  *-----------------------------------------------------------
0000121E                           437  M0000:
0000121E  4282                     438              CLR.L       D2
00001220  4283                     439              CLR.L       D3
00001222                           440              
00001222                           441              ;Copy the address values into a register to check for ADDI or SUBI
00001222  3412                     442              MOVE.W      (A2),D2
00001224                           443              
00001224                           444              ;Passing in paramters for isolating bits
00001224  163C 0008                445              MOVE.B      #8,D3
00001228  183C 0004                446              MOVE.B      #4,D4
0000122C                           447              
0000122C                           448              ;Jumps to getBits and returns with isolated bits in D2
0000122C  61DA                     449              BSR         getBits
0000122E                           450              
0000122E                           451              ;--------------------------------------------------------
0000122E                           452              ;Check for ADDI
0000122E                           453              ;--------------------------------------------------------
0000122E  B43C 0006                454              CMP.B       #%0110,D2
00001232  6700 0022                455              BEQ         MADDI
00001236                           456             
00001236                           457              ;--------------------------------------------------------
00001236                           458              ;Check for SUBI
00001236                           459              ;--------------------------------------------------------
00001236  B43C 0004                460              CMP.B       #%0100,D2
0000123A  6700 0050                461              BEQ         MSUBI
0000123E                           462              
0000123E                           463              ;--------------------------------------------------------
0000123E                           464              ;Check for ANDI
0000123E                           465              ;--------------------------------------------------------
0000123E  B43C 0002                466              CMP.B       #%0010,D2
00001242  6700 0002                467              BEQ         MANDI
00001246                           468              
00001246                           469              MANDI:
00001246  43F9 00001EB6            470              LEA         printANDI,A1
0000124C  103C 000E                471              MOVE.B      #14,D0
00001250  4E4F                     472              TRAP        #15
00001252                           473              
00001252  6000 000E                474              BRA         continueI
00001256                           475  
00001256                           476  
00001256                           477  MADDI:
00001256  43F9 00001E8F            478              LEA         printADDI,A1
0000125C  103C 000E                479              MOVE.B      #14,D0
00001260  4E4F                     480              TRAP        #15
00001262                           481  
00001262                           482  continueI:            
00001262  4282                     483              CLR.L       D2
00001264  4283                     484              CLR.L       D3
00001266                           485              
00001266                           486              ;======Isolate Size (S) Bits======
00001266                           487              ;Copy the address values into a register
00001266  3412                     488              MOVE.W      (A2),D2
00001268                           489              
00001268                           490              ;Passing in parameters for isolating size bits
00001268  163C 0006                491              MOVE.B      #6,D3
0000126C  183C 0002                492              MOVE.B      #2,D4
00001270                           493              
00001270                           494              ;Jumps to getBits and returns with isolated bits in D2
00001270  6196                     495              BSR         getBits
00001272                           496              
00001272                           497              ;Jumps to printSizeSubroutine and returns after size has been printed
00001272  6100 0922                498              BSR         printSizeSubroutine
00001276                           499              
00001276                           500              ;Let's store the size indicator since it will help us determine how many times
00001276                           501              ;we have to iterate through addresses to print out the whole instruction
00001276                           502              ;We will use A4 as the register to temporary store the size
00001276  3842                     503              MOVE.W      D2,A4
00001278  11C2 2000                504              MOVE.B      D2,$2000
0000127C                           505              
0000127C                           506              ;Clear the register so we can reuse it
0000127C  4282                     507              CLR.L       D2
0000127E                           508              
0000127E  1412                     509              MOVE.B      (A2),D2
00001280                           510              
00001280                           511              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001280                           512              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001280  264A                     513              MOVE.L      A2,A3
00001282                           514              
00001282  6100 0040                515              BSR         mEffect
00001286                           516              
00001286  4283                     517              CLR.L       D3
00001288                           518              
00001288  6000 FF60                519              BRA         update
0000128C                           520              
0000128C                           521              
0000128C                           522  MSUBI:
0000128C  43F9 00001E98            523              LEA         printSUBI,A1
00001292  103C 000E                524              MOVE.B      #14,D0
00001296  4E4F                     525              TRAP        #15
00001298                           526              
00001298  4282                     527              CLR.L       D2
0000129A  4283                     528              CLR.L       D3
0000129C                           529              
0000129C                           530              ;======Isolate Size (S) Bits======
0000129C                           531              ;Copy the address values into a register
0000129C  3412                     532              MOVE.W      (A2),D2
0000129E                           533              
0000129E                           534              ;Passing in parameters for isolating size bits
0000129E  163C 0006                535              MOVE.B      #6,D3
000012A2  183C 0002                536              MOVE.B      #2,D4
000012A6                           537              
000012A6                           538              ;Jumps to getBits and returns with isolated bits in D2
000012A6  6100 FF60                539              BSR         getBits
000012AA                           540              
000012AA                           541              ;Jumps to printSizeSubroutine and returns after size has been printed
000012AA  6100 08EA                542              BSR         printSizeSubroutine
000012AE                           543              
000012AE                           544              ;Let's store the size indicator since it will help us determine how many times
000012AE                           545              ;we have to iterate through addresses to print out the whole instruction
000012AE                           546              ;We will use A4 as the register to temporary store the size
000012AE  3842                     547              MOVE.W      D2,A4
000012B0  11C2 2000                548              MOVE.B      D2,$2000
000012B4                           549              
000012B4                           550              ;Clear the register so we can reuse it
000012B4  4282                     551              CLR.L       D2
000012B6                           552              
000012B6  1412                     553              MOVE.B      (A2),D2
000012B8                           554              
000012B8                           555              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012B8                           556              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012B8  264A                     557              MOVE.L      A2,A3
000012BA                           558              
000012BA  6100 0008                559              BSR         mEffect
000012BE                           560              
000012BE  4283                     561              CLR.L       D3
000012C0                           562              
000012C0  6000 FF28                563              BRA         update
000012C4                           564  
000012C4                           565              
000012C4                           566  mEffect:
000012C4                           567              ;Male D6 #%111 since the source will always be an immediate value 
000012C4  1C3C 0007                568              MOVE.B      #7,D6
000012C8                           569              ;Make D7 #%100 since the source will always be an immediate value
000012C8  1E3C 0004                570              MOVE.B      #4,D7     
000012CC                           571  
000012CC                           572              ;Print source address
000012CC  6100 093A                573              BSR         addressModeSR
000012D0                           574              
000012D0                           575              ;Print the comma after the source address
000012D0  43F9 00001F27            576              LEA        printComma,A1
000012D6  103C 000E                577              MOVE.B     #14,D0
000012DA  4E4F                     578              TRAP       #15
000012DC                           579              
000012DC                           580              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
000012DC  6100 0008                581              BSR        isoAddBit0to5
000012E0                           582              
000012E0                           583              ;Print source address
000012E0  6100 0926                584              BSR        addressModeSR
000012E4                           585              
000012E4  4E75                     586              RTS            
000012E6                           587              
000012E6                           588              
000012E6                           589  isoAddBit0to5:
000012E6                           590              ;===Isolate the Destination Mode (M)Bits===
000012E6  4282                     591              CLR.L      D2
000012E8                           592              
000012E8                           593              ;Copy the address value into a register
000012E8  3413                     594              MOVE.W     (A3),D2
000012EA                           595              
000012EA                           596              ;Passing in parameters for isolating Mode bits
000012EA  163C 0003                597              MOVE.B     #3,D3
000012EE  183C 0003                598              MOVE.B     #3,D4
000012F2                           599              
000012F2                           600              ;Jumps to getBits and returns with isolated bits in D2
000012F2  4EB8 1208                601              JSR        getBits
000012F6                           602              
000012F6                           603              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000012F6  1C02                     604              MOVE.B     D2,D6
000012F8                           605              
000012F8                           606              ;===Isolate the Destination Address Register (Xn)Bits===
000012F8  4282                     607              CLR.L      D2
000012FA                           608              
000012FA                           609              ;Copy the address values into a register
000012FA  3413                     610              MOVE.W     (A3),D2
000012FC                           611              
000012FC                           612              ;Passing in parameters for isolating Xn bits
000012FC  163C 0000                613              MOVE.B     #0,D3
00001300  183C 0003                614              MOVE.B     #3,D4
00001304                           615              
00001304                           616              ;Jumps to getBits and returns with isolated bits in D2
00001304  4EB8 1208                617              JSR        getBits
00001308                           618              
00001308                           619              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001308  1E02                     620              MOVE.B      D2,D7
0000130A                           621  
0000130A  4E75                     622              RTS
0000130C                           623              
0000130C                           624  *-----------------------------------------------------------
0000130C                           625  * MOVE INSTRUCTION
0000130C                           626  *-----------------------------------------------------------
0000130C                           627  M00:
0000130C  43F9 00001E80            628              LEA        printMOVE,A1
00001312  103C 000E                629              MOVE.B     #14,D0
00001316  4E4F                     630              TRAP       #15
00001318                           631              
00001318  4202                     632              CLR.B      D2
0000131A  4203                     633              CLR.B      D3
0000131C                           634              
0000131C                           635              ;======Isolate Size (S) Bits=======
0000131C                           636              ;Copy the address values into a register
0000131C  3412                     637              MOVE.W     (A2),D2
0000131E                           638              
0000131E                           639              ;Passing in parameters for isolating size bits 12,13
0000131E  163C 000C                640              MOVE.B      #12,D3             
00001322  183C 0002                641              MOVE.B      #2,D4             
00001326                           642              
00001326                           643              ;Jumps to getBits and returns with isolated bits in D2
00001326  6100 FEE0                644              BSR         getBits  
0000132A                           645              
0000132A                           646              ;Check and see if we have the MOVE opcode since it shares with others
0000132A  B43C 0000                647              CMP.B       #0,D2
0000132E  6700 FEA2                648              BEQ         invalid
00001332                           649              
00001332  4283                     650              CLR.L       D3
00001334                           651              
00001334                           652              ;Indicate to our print function we are doing this for the MOVE opcode
00001334  163C 0001                653              MOVE.B      #1,D3
00001338                           654              
00001338                           655              ;Jumps to printSizeSubroutine and returns after size has been printed
00001338  6100 085C                656              BSR         printSizeSubroutine
0000133C                           657              
0000133C                           658              ;Let's store the size indicator since it will help us determine how many times
0000133C                           659              ;we have to iterate through addresses to print out the whole instruction
0000133C                           660              ;We will use A4 as the register to temporary store the size
0000133C  3842                     661              MOVE.W      D2,A4
0000133E  11C2 2000                662              MOVE.B      D2,$2000
00001342                           663  
00001342                           664              ;Clear the register so we can reuse it
00001342  4282                     665              CLR.L       D2
00001344                           666              
00001344  3412                     667              MOVE.W      (A2),D2
00001346                           668              
00001346                           669              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
00001346                           670              ;This is meant so we can use the copy to figure out the destination addressing mode
00001346  264A                     671              MOVE.L      A2,A3
00001348                           672  
00001348  6000 0002                673              BRA         mSourceDest
0000134C                           674              
0000134C                           675            
0000134C                           676  ;======Helper function to find the destination for MOVE======
0000134C                           677  mSourceDest:
0000134C                           678              ;SOURCE
0000134C                           679              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000134C  6100 080A                680              BSR        isolateAddressBit0to5
00001350                           681              
00001350                           682              ;Print source address
00001350  6100 08B6                683              BSR        addressModeSR
00001354                           684              
00001354                           685              ;Print the comma after the source address
00001354  43F9 00001F27            686              LEA        printComma,A1
0000135A  103C 000E                687              MOVE.B     #14,D0
0000135E  4E4F                     688              TRAP       #15
00001360                           689              
00001360                           690              ;DESTINATION
00001360                           691              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001360  6100 000C                692              BSR        isolateAddressBit6to11
00001364                           693              
00001364                           694              ;Print destination address
00001364  6100 08A2                695              BSR        addressModeSR
00001368                           696              
00001368  4283                     697              CLR.L      D3
0000136A                           698              
0000136A  6000 FE7E                699              BRA        update
0000136E                           700              
0000136E                           701  
0000136E                           702  isolateAddressBit6to11:
0000136E                           703              ;===Isolate the Destination Mode (M)Bits===
0000136E  4282                     704              CLR.L      D2
00001370                           705              
00001370                           706              ;Copy the address value into a register
00001370  3413                     707              MOVE.W     (A3),D2
00001372                           708              
00001372                           709              ;Passing in parameters for isolating Mode bits
00001372  163C 0006                710              MOVE.B     #6,D3
00001376  183C 0003                711              MOVE.B     #3,D4
0000137A                           712              
0000137A                           713              ;Jumps to getBits and returns with isolated bits in D2
0000137A  4EB8 1208                714              JSR        getBits
0000137E                           715              
0000137E                           716              ;Save M bit into ***D6*** for later use in addressModeSubroutine
0000137E  1C02                     717              MOVE.B     D2,D6
00001380                           718              
00001380                           719              ;===Isolate the Destination Address Register (Xn)Bits===
00001380  4282                     720              CLR.L      D2
00001382                           721              
00001382                           722              ;Copy the address values into a register
00001382  3413                     723              MOVE.W     (A3),D2
00001384                           724              
00001384                           725              ;Passing in parameters for isolating Xn bits
00001384  163C 0009                726              MOVE.B     #9,D3
00001388  183C 0003                727              MOVE.B     #3,D4
0000138C                           728              
0000138C                           729              ;Jumps to getBits and returns with isolated bits in D2
0000138C  4EB8 1208                730              JSR        getBits
00001390                           731              
00001390                           732              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001390  1E02                     733              MOVE.B      D2,D7
00001392                           734  
00001392  4E75                     735              RTS
00001394                           736              
00001394                           737              
00001394                           738  *-----------------------------------------------------------
00001394                           739  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
00001394                           740  *-----------------------------------------------------------
00001394                           741  M0100:      
00001394  4282                     742              CLR.L       D2
00001396  4283                     743              CLR.L       D3
00001398                           744              
00001398                           745              ;--------------------------------------------------------
00001398                           746              ;Check for LEA
00001398                           747              ;--------------------------------------------------------
00001398                           748              ;Copy the address values into a register to check for LEA
00001398  3412                     749              MOVE.W     (A2),D2
0000139A                           750              
0000139A                           751              ;Passing in parameters for isolating bits 6,7,8
0000139A  163C 0006                752              MOVE.B      #6,D3             ;Start bit index = 6
0000139E  183C 0003                753              MOVE.B      #3,D4             ;Number of bits needed = 3
000013A2                           754              
000013A2                           755              ;Jumps to getBits and returns with isolated bits in D2
000013A2  6100 FE64                756              BSR         getBits
000013A6                           757  
000013A6  B43C 0007                758              CMP.B       #%111,D2
000013AA  6700 0264                759              BEQ         MLEA
000013AE                           760  
000013AE                           761              ;--------------------------------------------------------
000013AE                           762              ;Check for NOT
000013AE                           763              ;--------------------------------------------------------
000013AE                           764              ;Clear D2 and recopy it to check for NOT
000013AE  4282                     765              CLR.L       D2
000013B0  3412                     766              MOVE.W      (A2),D2
000013B2                           767              
000013B2                           768              ;Pass in parameters for isolating bits 8,9,10,11
000013B2  163C 0008                769              MOVE.B      #8,D3
000013B6  183C 0004                770              MOVE.B      #4,D4
000013BA                           771              
000013BA                           772              ;Jumps to getBits and returns with isolated bits in D2
000013BA  6100 FE4C                773              BSR         getBits
000013BE                           774              
000013BE  B43C 0006                775              CMP.B       #%0110,D2
000013C2  6700 027C                776              BEQ         MNOT      
000013C6                           777              
000013C6                           778              ;--------------------------------------------------------
000013C6                           779              ;Check for JSR
000013C6                           780              ;--------------------------------------------------------
000013C6                           781              ;Clear D2 and recopy it to check for JSR
000013C6  4282                     782              CLR.L       D2
000013C8  3412                     783              MOVE.W     (A2),D2
000013CA                           784              
000013CA                           785              ;Pass in parameters for isolating bits 6-11
000013CA  163C 0006                786              MOVE.B      #6,D3
000013CE  183C 0006                787              MOVE.B      #6,D4
000013D2                           788              
000013D2                           789              ;Jumps to getBits and returns with isolated bits in D2
000013D2  6100 FE34                790              BSR         getBits
000013D6                           791              
000013D6  B43C 003A                792              CMP.B       #%111010,D2
000013DA  6700 0290                793              BEQ         MJSR
000013DE                           794              
000013DE                           795              ;--------------------------------------------------------
000013DE                           796              ;Check for MOVEM
000013DE                           797              ;--------------------------------------------------------
000013DE                           798              ;Clear D2 and recopy it to check for MOVEM
000013DE  4282                     799              CLR.L       D2
000013E0  3412                     800              MOVE.W     (A2),D2
000013E2                           801              
000013E2                           802              ;Pass in parameters for isolating bit 9
000013E2  163C 0009                803              MOVE.B      #9,D3
000013E6  183C 0001                804              MOVE.B      #1,D4
000013EA                           805              
000013EA                           806              ;Jumps to getBits and returns with isolated bits in D2
000013EA  6100 FE1C                807              BSR         getBits
000013EE                           808              
000013EE  B43C 0000                809              CMP.B       #%0,D2
000013F2  6700 0002                810              BEQ         MOVEM
000013F6                           811              
000013F6                           812         
000013F6                           813  MOVEM:
000013F6  43F9 00001E85            814              LEA         printMOVEM,A1
000013FC  103C 000E                815              MOVE.B      #14,D0
00001400  4E4F                     816              TRAP        #15
00001402                           817              
00001402                           818              ***Isolate Size Bit***
00001402                           819              ;Clear D2 and recopy it to check for Size bit
00001402  4282                     820              CLR.L       D2
00001404  3412                     821              MOVE.W      (A2),D2
00001406                           822              
00001406                           823              ;Pass in paramters for isolating bit 6
00001406  163C 0006                824              MOVE.B      #6,D3
0000140A  183C 0001                825              MOVE.B      #1,D4
0000140E                           826              
0000140E                           827              ;Jumps to getBits and returns with isolated bits in D2
0000140E  6100 FDF8                828              BSR         getBits
00001412                           829              
00001412                           830              ;Print size
00001412  4EB9 00001BCE            831              JSR         printMOVEMSize
00001418                           832              
00001418                           833              ;Clear any value in our gloabal variable just in case
00001418  11FC 0000 100E           834              MOVE.B      #0,movemAdd
0000141E                           835              
0000141E                           836              ;Next we are going to get the addressing mode to determine how we print the register list
0000141E                           837              ;Isolate bits 0 to 5
0000141E  4EB9 00001B58            838              JSR         isolateAddressBit0to5
00001424                           839              ;Let's store the addressing mode in our global variable
00001424  11C6 100E                840              MOVE.B      D6,movemAdd
00001428                           841              
00001428  4283                     842              CLR.L       D3
0000142A  4284                     843              CLR.L       D4
0000142C  4286                     844              CLR.L       D6
0000142E                           845              
0000142E                           846              
0000142E                           847              ***Isolate Direction bit
0000142E                           848              ;Clear D2 and recopy it to check for D bit
0000142E  4282                     849              CLR.L       D2
00001430  3412                     850              MOVE.W      (A2),D2
00001432                           851              
00001432                           852              ;Pass in parameters for isolating bit 10
00001432  163C 000A                853              MOVE.B      #10,D3
00001436  183C 0001                854              MOVE.B      #1,D4
0000143A                           855              
0000143A                           856              ;Jumps to getBits and returns with isolated bits in D2
0000143A  6100 FDCC                857              BSR         getBits
0000143E                           858  
0000143E                           859              ***Determine the direction of the instruction***
0000143E  B43C 0000                860              CMP.B       #0,D2
00001442  6700 000A                861              BEQ         ListToMem
00001446                           862  
00001446                           863              ;Memory to Register List
00001446  B43C 0001                864              CMP.B       #1,D2
0000144A  6700 004E                865              BEQ         MemToList  
0000144E                           866                         
0000144E                           867  ListToMem:
0000144E                           868              ***SOURCE(Register List)  
0000144E  4282                     869              CLR.L       D2
00001450                           870  
00001450                           871              ;A3 will act as our temp variable 
00001450  2678 0000                872              MOVE.L      $00000000,A3
00001454  364A                     873              MOVEA.W     A2,A3
00001456                           874              
00001456                           875              ;Reset 
00001456  11FC 0000 1009           876              MOVE.B     #$00,totalCount
0000145C  11FC 0000 100F           877              MOVE.B     #$00,listSize
00001462                           878           
00001462  11FC 0001 100C           879              MOVE.B      #1,curAdd
00001468                           880              
00001468                           881              ;Go find the register list
00001468  6100 007A                882              BSR         check
0000146C                           883              
0000146C                           884  ListToMem2:
0000146C                           885              ;Print the comma after the source address
0000146C  43F9 00001F27            886              LEA         printComma,A1
00001472  103C 000E                887              MOVE.B      #14,D0
00001476  4E4F                     888              TRAP        #15
00001478                           889              
00001478                           890              ***DESTINATION(Memory)
00001478                           891              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
00001478  4282                     892              CLR.L       D2
0000147A                           893              
0000147A  3412                     894              MOVE.W      (A2),D2
0000147C                           895              
0000147C                           896              ;Isolate bits 0 to 5
0000147C  4EB9 00001B58            897              JSR         isolateAddressBit0to5
00001482                           898              
00001482  BC3C 0007                899              CMP.B       #%111,D6
00001486  6100 0058                900              BSR         absoluteAddressMOVEM
0000148A                           901              
0000148A                           902              ;Clear A6 since we will need this for later
0000148A  2C7C 00000000            903              MOVE.L      #00000000,A6
00001490                           904              
00001490                           905              ;Print memory address
00001490  6100 0776                906              BSR         addressModeSR
00001494                           907              
00001494  4283                     908              CLR.L      D3
00001496                           909              
00001496  6000 FD52                910              BRA        update
0000149A                           911  
0000149A                           912  
0000149A                           913  MemToList:
0000149A                           914              ***SOURCE(Memory)***
0000149A                           915              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
0000149A  4282                     916              CLR.L       D2            
0000149C                           917              
0000149C  3412                     918              MOVE.W      (A2),D2
0000149E                           919              
0000149E                           920              ;Use A3 as a temp address to be able to access the memory address
0000149E  267C 00000000            921              MOVE.L      #00000000,A3
000014A4  364A                     922              MOVEA.W     A2,A3
000014A6                           923  
000014A6                           924              ;Isolate addressing bits 0 to 5
000014A6  4EB9 00001B58            925              JSR         isolateAddressBit0to5
000014AC                           926              
000014AC  BC3C 0007                927              CMP.B       #%111,D6
000014B0  6100 002E                928              BSR         absoluteAddressMOVEM
000014B4                           929             
000014B4                           930              ;Clear A6 since we will need this for later
000014B4  2C7C 00000000            931              MOVE.L      #00000000,A6
000014BA                           932              
000014BA                           933              ;Print memory address
000014BA  6100 074C                934              BSR         addressModeSR
000014BE                           935              
000014BE                           936              ;Print the comma after the source address
000014BE  43F9 00001F27            937              LEA         printComma,A1
000014C4  103C 000E                938              MOVE.B      #14,D0
000014C8  4E4F                     939              TRAP        #15
000014CA                           940                          
000014CA                           941              ;Reset 
000014CA  11FC 0000 1009           942              MOVE.B      #$00,totalCount
000014D0  11FC 0000 100F           943              MOVE.B      #$00,listSize
000014D6                           944              
000014D6  11FC 0000 100C           945              MOVE.B      #0,curAdd
000014DC                           946              
000014DC                           947              ;Go find the register list
000014DC  6100 0006                948              BSR         check
000014E0                           949      
000014E0                           950              
000014E0                           951  absoluteAddressMOVEM:
000014E0  544A                     952              ADDA.W      #2,A2
000014E2                           953  
000014E2  4E75                     954              RTS                     
000014E4                           955                
000014E4                           956  check:
000014E4  0C38 0000 1009           957              CMP.B       #0,(totalCount)
000014EA  6700 001C                958              BEQ         findList
000014EE                           959  
000014EE  0C38 0008 1009           960              CMP.B       #8,(totalCount)
000014F4  6700 0034                961              BEQ         findList2
000014F8                           962     
000014F8                           963              ;We go back to ListToMem which was our starting point
000014F8  0C38 0001 100C           964              CMP.B       #1,(curAdd)
000014FE  6700 FF6C                965              BEQ         ListToMem2
00001502                           966               
00001502                           967              ;If we arrive here, we assume that we started in MemToList      
00001502  4283                     968              CLR.L      D3
00001504                           969              
00001504  6000 FCE4                970              BRA        update
00001508                           971  
00001508                           972  
00001508                           973  findList:
00001508                           974              ;Set up the temp register to the register list
00001508  544B                     975              ADDA.W      #2,A3
0000150A                           976  
0000150A  3413                     977              MOVE.W      (A3),D2
0000150C                           978  
0000150C                           979              ;Clear some registers so we can have a counter
0000150C                           980              ;and two registers to hold a beginning index and then ending index
0000150C  4284                     981              CLR.L       D4
0000150E  4285                     982              CLR.L       D5
00001510  4286                     983              CLR.L       D6
00001512  4287                     984              CLR.L       D7  ;Holds the actual value for manipulation
00001514                           985              
00001514                           986              ;Set D7 to indicate we are doing the first bit check
00001514  3E13                     987              MOVE.W      (A3),D7
00001516                           988              
00001516                           989              
00001516                           990              ;===Setting Up Variables===            
00001516                           991              ;Indicate we are at the start of the word for our counter
00001516  11FC 0000 1008           992              MOVE.B      #0,counter
0000151C                           993              ;==========================
0000151C                           994              
0000151C                           995              ;The (dORa) variable changes because it must be the opposite of findList 
0000151C  0C38 0004 100E           996              CMP.B       #4,movemAdd
00001522  6700 0028                997              BEQ         setA
00001526                           998              
00001526  6000 001A                999              BRA         setD
0000152A                          1000  
0000152A                          1001           
0000152A                          1002  findList2:           
0000152A  4287                    1003              CLR.L       D7
0000152C  1E13                    1004              MOVE.B      (A3),D7
0000152E                          1005              
0000152E                          1006              ;===Setting Up Variables===
0000152E                          1007              ;Indicate we are at the start of the word for our counter
0000152E  11FC 0000 1008          1008              MOVE.B      #0,counter
00001534                          1009              ;==========================
00001534                          1010              
00001534                          1011              ;The (dORa) variable changes because it must be the opposite of findList            
00001534  0C38 0004 100E          1012              CMP.B       #4,movemAdd
0000153A  6700 0006               1013              BEQ         setD
0000153E                          1014              
0000153E  6000 000C               1015              BRA         setA
00001542                          1016             
00001542                          1017   
00001542                          1018  setD:
00001542  11FC 0000 100A          1019              MOVE.B      #0,dORa
00001548                          1020              
00001548                          1021              ;Go through a loop and rotate bits twice for the D registers
00001548  6100 000C               1022              BSR         bitLoop
0000154C                          1023   
0000154C                          1024  setA:
0000154C  11FC 0001 100A          1025              MOVE.B      #1,dORa
00001552                          1026              
00001552                          1027              ;Go through a loop and rotate bits twice for the D registers
00001552  6100 0002               1028              BSR         bitLoop
00001556                          1029  
00001556                          1030  bitLoop:
00001556                          1031  
00001556                          1032              ;If our counter is 8, then we must finish printing the list
00001556  0C38 0008 1008          1033              CMP.B       #8,counter
0000155C  6786                    1034              BEQ         check
0000155E                          1035  
0000155E  3407                    1036              MOVE.W      D7,D2
00001560                          1037              
00001560                          1038              ;We will use getBits to get the right-most bit (Stored in D2)
00001560  163C 0000               1039              MOVE.B      #0,D3  ;The starting index of the word
00001564  183C 0001               1040              MOVE.B      #1,D4  ;How many bits we want
00001568                          1041  
00001568  6100 FC9E               1042              BSR         getBits
0000156C                          1043              
0000156C                          1044              ;If the bit is 0, then that means we must print out some values
0000156C  B43C 0000               1045              CMP.B       #0,D2
00001570  6700 0006               1046              BEQ         skipBit
00001574                          1047  
00001574  6100 000E               1048              BSR         printSingle
00001578                          1049              
00001578                          1050  skipBit:
00001578                          1051              ;Increment the rest of our variables to set up the loop again
00001578  5238 1008               1052              ADD.B       #1,counter
0000157C  5238 1009               1053              ADD.B       #1,totalCount
00001580                          1054              
00001580  E28F                    1055              LSR.L       #1,D7
00001582                          1056              
00001582  60D2                    1057              BRA         bitLoop
00001584                          1058   
00001584                          1059  
00001584                          1060  printSingle:
00001584                          1061              ;update number of registers included in the list
00001584  5238 100F               1062              ADD.B       #1,listSize
00001588                          1063              ;Check and see if we should print D or A
00001588  0C38 0000 100A          1064              CMP.B       #0,(dORa)
0000158E  6700 000C               1065              BEQ         singleDReg
00001592                          1066              
00001592  0C38 0001 100A          1067              CMP.B       #1,(dORa)
00001598  6700 0034               1068              BEQ         singleAReg
0000159C                          1069  
0000159C                          1070  singleDReg:
0000159C  0C38 0001 100F          1071              CMP.B       #1,listSize
000015A2  6700 0006               1072              BEQ         skipSlashD
000015A6                          1073         
000015A6  6100 005A               1074              BSR         pSlash
000015AA                          1075              
000015AA                          1076  skipSlashD:
000015AA  43F9 00001F0E           1077              LEA         printDRD,A1
000015B0  103C 000E               1078              MOVE.B      #14,D0
000015B4  4E4F                    1079              TRAP        #15
000015B6                          1080  
000015B6                          1081              ;Print out the register number
000015B6  4281                    1082              CLR.L       D1
000015B8  1238 1008               1083              MOVE.B      (counter),D1
000015BC  103C 0003               1084              MOVE.B      #3,D0
000015C0  4E4F                    1085              TRAP        #15           
000015C2                          1086              
000015C2  5238 1008               1087              ADD.B       #1,counter
000015C6  5238 1009               1088              ADD.B       #1,totalCount
000015CA                          1089              
000015CA  E28F                    1090              LSR.L       #1,D7
000015CC                          1091              
000015CC  6088                    1092              BRA         bitLoop
000015CE                          1093   
000015CE                          1094  
000015CE                          1095  
000015CE                          1096  singleAReg:
000015CE  0C38 0001 100F          1097              CMP.B       #1,listSize
000015D4  6700 0006               1098              BEQ         skipSlashA
000015D8                          1099         
000015D8  6100 0028               1100              BSR         pSlash
000015DC                          1101              
000015DC                          1102  skipSlashA:
000015DC  43F9 00001F10           1103              LEA         printARD,A1
000015E2  103C 000E               1104              MOVE.B      #14,D0
000015E6  4E4F                    1105              TRAP        #15
000015E8                          1106  
000015E8                          1107              ;Print out the register number
000015E8  4281                    1108              CLR.L       D1
000015EA  1238 1008               1109              MOVE.B      (counter),D1
000015EE  103C 0003               1110              MOVE.B      #3,D0
000015F2  4E4F                    1111              TRAP        #15
000015F4                          1112  
000015F4  5238 1008               1113              ADD.B       #1,counter
000015F8  5238 1009               1114              ADD.B       #1,totalCount
000015FC                          1115              
000015FC  E28F                    1116              LSR.L       #1,D7
000015FE                          1117              
000015FE  6000 FF56               1118              BRA         bitLoop
00001602                          1119           
00001602                          1120  pSlash:
00001602  43F9 00001F2B           1121              LEA         printSlash,A1
00001608  103C 000E               1122              MOVE.B      #14,D0
0000160C  4E4F                    1123              TRAP        #15
0000160E                          1124              
0000160E  4E75                    1125              RTS       
00001610                          1126          
00001610                          1127         
00001610                          1128  MLEA:
00001610  43F9 00001EAD           1129              LEA         printLEA,A1
00001616  103C 000E               1130              MOVE.B      #14,D0
0000161A  4E4F                    1131              TRAP        #15
0000161C                          1132              
0000161C                          1133              ;*SOURCE*
0000161C                          1134              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000161C                          1135              ;D6 will contain mode & D7 will contain the register after this instruction
0000161C  6100 053A               1136              BSR         isolateAddressBit0to5
00001620                          1137              
00001620                          1138              ;*Print source address*
00001620  6100 05E6               1139              BSR         addressModeSR
00001624                          1140              
00001624                          1141              ;Print comma after source address
00001624  43F9 00001F27           1142              LEA         printComma,A1
0000162A  103C 000E               1143              MOVE.B      #14,D0
0000162E  4E4F                    1144              TRAP        #15
00001630                          1145              
00001630                          1146              ;*DESTINATION*
00001630                          1147              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001630                          1148              ;D7 will contain the register after this instruction
00001630  6100 054C               1149              BSR         isolateRegisterBit9to11
00001634                          1150              
00001634                          1151              ;Save #%001 into D6 to specify address register mode
00001634  1C3C 0001               1152              MOVE.B      #1,D6
00001638                          1153              
00001638                          1154              
00001638                          1155              ;*Print destination address*
00001638  6100 05CE               1156              BSR         addressModeSR
0000163C                          1157  
0000163C  6000 FBAC               1158              BRA        update
00001640                          1159  
00001640                          1160  MNOT:
00001640                          1161              ;Distinguish NOT from "MOVE to SSR"                 
00001640                          1162              
00001640  4282                    1163              CLR.L      D2
00001642                          1164              ;Move the address into the register to check for size
00001642  3412                    1165              MOVE.W     (A2),D2
00001644                          1166              
00001644                          1167              ;Pass in parameters for isolating bits 6,7
00001644  163C 0006               1168              MOVE.B     #6,D3
00001648  183C 0002               1169              MOVE.B     #2,D4
0000164C                          1170              
0000164C                          1171              ;Jump to getbits and return with isolated bits
0000164C  6100 FBBA               1172              BSR        getbits
00001650                          1173  
00001650                          1174              ;This was meant for invalid opcode testing
00001650                          1175              ;CMP.B      #%11,D2
00001650                          1176              ;BRA        InOpCode     
00001650                          1177  
00001650  43F9 00001EBB           1178              LEA        printNOT,A1
00001656  103C 000E               1179              MOVE.B     #14,D0
0000165A  4E4F                    1180              TRAP       #15    
0000165C                          1181              
0000165C                          1182              ;Jumps to printSizeSubroutine and returns after size has been printed
0000165C  6100 0538               1183              BSR        printSizeSubroutine
00001660                          1184              
00001660                          1185              ;*SOURCE*
00001660                          1186              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001660                          1187              ;D6 will contain mode & D7 will contain the register after this instruction
00001660  6100 04F6               1188              BSR        isolateAddressBit0to5
00001664                          1189              
00001664                          1190              ;*Print source address*
00001664  6100 05A2               1191              BSR        addressModeSR
00001668                          1192              
00001668  6000 FB80               1193              BRA        update 
0000166C                          1194  
0000166C                          1195  MJSR:
0000166C  43F9 00001EE3           1196              LEA        printJSR,A1
00001672  103C 000E               1197              MOVE.B     #14,D0
00001676  4E4F                    1198              TRAP       #15
00001678                          1199              
00001678                          1200              ;*SOURCE*
00001678                          1201              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001678                          1202              ;D6 will contain mode & D7 will contain the register after this instruction
00001678  6100 04DE               1203              BSR        isolateAddressBit0to5
0000167C                          1204              
0000167C                          1205              ;*Print source address*
0000167C  6100 058A               1206              BSR        addressModeSR
00001680                          1207              
00001680  6000 FB68               1208              BRA        update 
00001684                          1209              
00001684                          1210  
00001684                          1211  *-----------------------------------------------------------
00001684                          1212  * BRA,BLT,BGE,BEQ INSTRUCTIONS
00001684                          1213  *-----------------------------------------------------------       
00001684                          1214  M0110:
00001684  4280                    1215              CLR.L       D0
00001686  4281                    1216              CLR.L       D1
00001688  4282                    1217              CLR.L       D2
0000168A  4283                    1218              CLR.L       D3
0000168C  4284                    1219              CLR.L       D4
0000168E                          1220        
0000168E                          1221              ;Moves the instruction into D2
0000168E  3412                    1222              MOVE.W     (A2),D2
00001690                          1223              
00001690                          1224              ;Setting up parameters for getBits - isolating bits 11-8
00001690  163C 0008               1225              MOVE.B      #8,D3             ;Start bit index = 8
00001694  183C 0004               1226              MOVE.B      #4,D4             ;Number of bits needed = 4
00001698                          1227              
00001698                          1228              ;calls getBits subroutine, D2 now has the four condition bits of the Bcc/BRA instruction. 
00001698  6100 FB6E               1229              BSR         getBits
0000169C                          1230              
0000169C                          1231              ;If the condition bits are 0000, the instruction is a BRA instruction. 
0000169C  B4BC 00000000           1232              CMP.L       #%0000,D2
000016A2  6700 002A               1233              BEQ         MBRA
000016A6                          1234              
000016A6                          1235              ;0100 = BCC
000016A6  B4BC 00000004           1236              CMP.L       #%0100,D2
000016AC  6700 0030               1237              BEQ         MBCC
000016B0                          1238              
000016B0                          1239              ;1101 = BLT
000016B0  B4BC 0000000D           1240              CMP.L       #%1101,D2
000016B6  6700 0036               1241              BEQ         MBLT
000016BA                          1242              
000016BA                          1243              ;1100 = BGE
000016BA  B4BC 0000000C           1244              CMP.L       #%1100,D2
000016C0  6700 003C               1245              BEQ         MBGE
000016C4                          1246              
000016C4                          1247              ;0111 = BEQ
000016C4  B4BC 00000007           1248              CMP.L       #%0111,D2
000016CA  6700 0042               1249              BEQ         MBEQ
000016CE                          1250  
000016CE                          1251  MBRA:
000016CE                          1252      ;condition bits (11-8) are 0000
000016CE  43F9 00001EEC           1253              LEA         printBRA,A1
000016D4  103C 000E               1254              MOVE.B      #14,D0
000016D8  4E4F                    1255              TRAP        #15
000016DA                          1256              
000016DA  6000 0042               1257              BRA         bccOffset
000016DE                          1258  
000016DE                          1259  MBCC:
000016DE                          1260      ;condition bits (11-8) are 0100     
000016DE  43F9 00001EDE           1261              LEA         printBCC,A1
000016E4  103C 000E               1262              MOVE.B      #14,D0
000016E8  4E4F                    1263              TRAP        #15
000016EA                          1264  
000016EA  6000 0032               1265              BRA         bccOffset
000016EE                          1266  
000016EE                          1267  MBLT:
000016EE                          1268      ;condition bits (11-8) are 1101
000016EE  43F9 00001ECF           1269              LEA         printBLT,A1
000016F4  103C 000E               1270              MOVE.B      #14,D0
000016F8  4E4F                    1271              TRAP        #15
000016FA                          1272              
000016FA  6000 0022               1273              BRA         bccOffset
000016FE                          1274  
000016FE                          1275  MBGE:
000016FE                          1276      ;condition bits (11-8) are 1100
000016FE  43F9 00001ED4           1277              LEA         printBGE,A1
00001704  103C 000E               1278              MOVE.B      #14,D0
00001708  4E4F                    1279              TRAP        #15
0000170A                          1280              
0000170A  6000 0012               1281              BRA         bccOffset
0000170E                          1282  
0000170E                          1283  MBEQ:            
0000170E                          1284      ;condition bits (11-8) are 0111
0000170E  43F9 00001ED9           1285              LEA         printBEQ,A1
00001714  103C 000E               1286              MOVE.B      #14,D0
00001718  4E4F                    1287              TRAP        #15
0000171A                          1288              
0000171A  6000 0002               1289              BRA         bccOffset         
0000171E                          1290  
0000171E                          1291  bccOffset:
0000171E                          1292      ;each variation of Bcc, BLT, BEQ, BRA, etc has the same format for the offset bits. Bits 0-7 are either the offset themself, or
0000171E                          1293      ;tell us where to look. If it contains $00, then 16-bit offset. If it contains $FF, 32-bit offset.
0000171E                          1294      
0000171E                          1295              ;Moves the branch family instruction into D2
0000171E  3412                    1296              MOVE.W     (A2),D2
00001720                          1297              
00001720                          1298              ;Setting up parameters for getBits - isolating bits 0-7
00001720  163C 0000               1299              MOVE.B      #0,D3             ;Start bit index = 0
00001724  183C 0008               1300              MOVE.B      #8,D4             ;Number of bits needed = 8
00001728                          1301  
00001728                          1302              ;calls getBits subroutine, D2 now has the offset bits
00001728  6100 FADE               1303              BSR         getBits
0000172C                          1304              
0000172C                          1305              ;If the offset bits are $00, we need to look at the next 16 bits for the offset.
0000172C  B4BC 00000000           1306              CMP.L       #%00000000,D2
00001732  6700 0048               1307              BEQ         bit16Displacement
00001736                          1308              
00001736                          1309              ;If the offset bits are $FF, we need to look at the next 32 bits for the offset.
00001736  B4BC 000000FF           1310              CMP.L       #%11111111,D2
0000173C  6700 0080               1311              BEQ         bit32Displacement
00001740                          1312              
00001740                          1313              ;If neither of the above two cases are true, we continue to 8bitDisplacement. 
00001740                          1314              
00001740                          1315  bit8Displacement:
00001740                          1316              ;We're here if the 8-bit displacement isn't $00 or $FF, and D2 already has the offset bits.
00001740                          1317              ;D2 is a twos complement integer specifying the number of bytes between the branch instruction 
00001740                          1318              ;and the next instruction to be executed (if the condition is met) 
00001740                          1319              
00001740                          1320              ;A2 is the address of the current instruction we're working with
00001740  2C4A                    1321              MOVEA.L      A2,A6
00001742                          1322            
00001742  B43C 0080               1323              CMP.B       #$80,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
00001746  6C00 000E               1324              BGE         sub8Bits
0000174A                          1325              
0000174A  6000 0002               1326              BRA         add8Bits
0000174E                          1327  
0000174E                          1328  add8Bits:
0000174E  5442                    1329              ADD.W       #2,D2
00001750  DCC2                    1330              ADD.W       D2,A6
00001752  6000 000C               1331              BRA         continue8Bits
00001756                          1332  sub8Bits:
00001756                          1333              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
00001756  4602                    1334              NOT.B       D2      ;inverts D2
00001758  5302                    1335              SUB.B       #1, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000175A                          1336                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
0000175A  9CC2                    1337              SUB.W       D2,A6   
0000175C                          1338              
0000175C  6000 0002               1339              BRA         continue8Bits
00001760                          1340  
00001760                          1341  continue8Bits:
00001760                          1342              
00001760                          1343              ;Output $
00001760  43F9 00001F19           1344              LEA         printA,A1
00001766  103C 000E               1345              MOVE.B      #14,D0
0000176A  4E4F                    1346              TRAP        #15
0000176C                          1347              
0000176C                          1348              ;Output destination address
0000176C  220E                    1349              MOVE.L      A6,D1
0000176E  6100 05EE               1350              BSR         hex_L
00001772                          1351              
00001772  2C7C 00000000           1352              MOVE.L      #$0,A6
00001778  6000 FA70               1353              BRA         update
0000177C                          1354  bit16Displacement:
0000177C                          1355              ;Getting the next 16 bits
0000177C  2C4A                    1356              MOVEA.L      A2,A6
0000177E  341A                    1357              MOVE.W      (A2)+,D2
00001780  3412                    1358              MOVE.W      (A2),D2
00001782                          1359                        
00001782  B4BC 00008000           1360              CMP.L       #$8000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
00001788  6C00 000E               1361              BGE         sub16Bits
0000178C                          1362              
0000178C  6000 0002               1363              BRA         add16Bits
00001790                          1364  
00001790                          1365              
00001790                          1366  add16Bits: 
00001790  5442                    1367              ADD.W       #2,D2
00001792  DCC2                    1368              ADD.W       D2,A6
00001794  6000 000C               1369              BRA         continue16Bits
00001798                          1370  
00001798                          1371  sub16Bits:  
00001798                          1372              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
00001798  4642                    1373              NOT.W       D2      ;inverts D2
0000179A  5342                    1374              SUB.W       #1, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000179C                          1375                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
0000179C  9CC2                    1376              SUB.W       D2,A6   
0000179E  6000 0002               1377              BRA         continue16Bits
000017A2                          1378              
000017A2                          1379  continue16Bits:
000017A2                          1380              ;Output $
000017A2  43F9 00001F19           1381              LEA         printA,A1
000017A8  103C 000E               1382              MOVE.B      #14,D0
000017AC  4E4F                    1383              TRAP        #15
000017AE                          1384              
000017AE                          1385              ;Output destination addres
000017AE  220E                    1386              MOVE.L      A6,D1
000017B0  6100 05AC               1387              BSR         hex_L
000017B4                          1388              
000017B4  2C7C 00000000           1389              MOVE.L      #$0,A6
000017BA  6000 FA2E               1390              BRA         update
000017BE                          1391              
000017BE                          1392  bit32Displacement:      ;Getting the next 32 bits
000017BE  2C4A                    1393              MOVEA.L     A2,A6
000017C0  241A                    1394              MOVE.L      (A2)+,D2
000017C2  2412                    1395              MOVE.L      (A2),D2
000017C4                          1396              
000017C4                          1397            
000017C4  B4BC 80000000           1398              CMP.L       #$80000000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000017CA  6C00 000E               1399              BGE         sub32Bits
000017CE                          1400              
000017CE  6000 0002               1401              BRA         add32Bits
000017D2                          1402  
000017D2                          1403  add32Bits:
000017D2  5442                    1404              ADD.W       #2,D2
000017D4  DDC2                    1405              ADD.L       D2,A6
000017D6  6000 000C               1406              BRA         continue32Bits
000017DA                          1407  
000017DA                          1408  sub32Bits:              ;If the displacement is negative, convert it into a regular value and subtract it from the address. 
000017DA  4682                    1409              NOT.L       D2      ;inverts D2
000017DC  5382                    1410              SUB.L       #1,D2   ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
000017DE                          1411                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
000017DE  9DC2                    1412              SUB.L       D2,A6   
000017E0  6000 0002               1413              BRA         continue32Bits
000017E4                          1414  
000017E4                          1415  continue32Bits:      
000017E4                          1416              ;Output $
000017E4  43F9 00001F19           1417              LEA         printA,A1
000017EA  103C 000E               1418              MOVE.B      #14,D0
000017EE  4E4F                    1419              TRAP        #15
000017F0                          1420              
000017F0                          1421              ;Output destination addres
000017F0  220E                    1422              MOVE.L      A6,D1
000017F2  6100 056A               1423              BSR         hex_L
000017F6                          1424        
000017F6  2C7C 00000000           1425              MOVE.L      #$0,A6      
000017FC  6000 F9EC               1426              BRA         update
00001800                          1427  
00001800                          1428  
00001800                          1429  *-----------------------------------------------------------
00001800                          1430  * DIVU INSTRUCTION
00001800                          1431  *-----------------------------------------------------------           
00001800                          1432  M1000:
00001800                          1433              
00001800  4282                    1434              CLR.L       D2
00001802  4283                    1435              CLR.L       D3
00001804                          1436              
00001804                          1437              ;Copy the address values into a register
00001804  3412                    1438              MOVE.W     (A2),D2
00001806                          1439              
00001806                          1440              ;Passing in parameters for isolating bits 6,7,8
00001806  163C 0006               1441              MOVE.B      #6,D3             ;Start bit index = 6
0000180A  183C 0003               1442              MOVE.B      #3,D4             ;Number of bits needed = 3
0000180E                          1443              
0000180E                          1444              ;Jumps to getBits and returns with isolated bits in D2
0000180E  6100 F9F8               1445              BSR         getBits
00001812                          1446              
00001812                          1447              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
00001812  B4BC 00000003           1448              CMP.L       #%011,D2
00001818  6700 0006               1449              BEQ         continueDIVU
0000181C                          1450              
0000181C                          1451              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
0000181C  6000 F9B4               1452              BRA         invalid
00001820                          1453  continueDIVU:
00001820                          1454  
00001820  43F9 00001EA5           1455              LEA         printDIVU,A1
00001826  103C 000E               1456              MOVE.B      #14,D0
0000182A  4E4F                    1457              TRAP        #15
0000182C                          1458              
0000182C  6000 02E2               1459              BRA         dnDest
00001830                          1460              
00001830                          1461              
00001830                          1462  *-----------------------------------------------------------
00001830                          1463  * SUB INSTRUCTION
00001830                          1464  *-----------------------------------------------------------  
00001830                          1465  M1001:
00001830  43F9 00001E94           1466              LEA        printSUB,A1
00001836  103C 000E               1467              MOVE.B     #14,D0
0000183A  4E4F                    1468              TRAP       #15
0000183C                          1469              
0000183C  4202                    1470              CLR.B      D2
0000183E  4203                    1471              CLR.B      D3
00001840                          1472              
00001840                          1473              ;======Isolate Size (S) Bits=======
00001840                          1474              ;Copy the address values into a register
00001840  3412                    1475              MOVE.W     (A2),D2
00001842                          1476              
00001842                          1477              ;Passing in parameters for isolating size bits
00001842  163C 0006               1478              MOVE.B      #6,D3             ;Start bit index = 6
00001846  183C 0002               1479              MOVE.B      #2,D4             ;Number of bits needed = 2
0000184A                          1480              
0000184A                          1481              ;Jumps to getBits and returns with isolated bits in D2
0000184A  6100 F9BC               1482              BSR         getBits  
0000184E                          1483              
0000184E                          1484              ;Jumps to printSizeSubroutine and returns after size has been printed
0000184E  6100 0346               1485              BSR         printSizeSubroutine
00001852                          1486              
00001852                          1487              ;Let's store the size indicator since it will help us determine how many times
00001852                          1488              ;we have to iterate through addresses to print out the whole instruction
00001852                          1489              ;We will use A4 as the register to temporary store the size
00001852  3842                    1490              MOVE.W      D2,A4
00001854  11C2 2000               1491              MOVE.B      D2,$2000
00001858                          1492              
00001858                          1493              ;======Isolate direction (D) Bit=======
00001858                          1494              ; 0 = data register is destination | 1 = Dn is source
00001858  4282                    1495              CLR.L       D2
0000185A                          1496              
0000185A                          1497              ;Copy the address values into a register
0000185A  3412                    1498              MOVE.W      (A2),D2
0000185C                          1499              
0000185C                          1500              ;Passing in parameters for isolating direction bit
0000185C  163C 0008               1501              MOVE.B      #8,D3             ;Start bit index = 8
00001860  183C 0001               1502              MOVE.B      #1,D4             ;Number of bits needed = 1
00001864                          1503              
00001864                          1504              ;Jumps to getBits and returns with isolated bit in D2
00001864  6100 F9A2               1505              BSR         getBits
00001868                          1506              
00001868                          1507              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001868  B43C 0000               1508              CMP.B       #0,D2
0000186C  6700 02A2               1509              BEQ         dnDest
00001870  6000 02C2               1510              BRA         dnSource
00001874                          1511  
00001874                          1512  
00001874                          1513  *-----------------------------------------------------------
00001874                          1514  * MULS,AND INSTRUCTIONS
00001874                          1515  *-----------------------------------------------------------  
00001874                          1516  M1100:      
00001874  4282                    1517              CLR.L       D2
00001876  4283                    1518              CLR.L       D3
00001878                          1519              
00001878                          1520              ;Copy the address values into a register
00001878  3412                    1521              MOVE.W     (A2),D2
0000187A                          1522              
0000187A                          1523              ;Passing in parameters for isolating bits 6 and 7
0000187A  163C 0006               1524              MOVE.B      #6,D3             ;Start bit index = 6
0000187E  183C 0002               1525              MOVE.B      #2,D4             ;Number of bits needed = 2
00001882                          1526              
00001882                          1527              ;Jumps to getBits and returns with isolated bits in D2
00001882  6100 F984               1528              BSR         getBits  
00001886                          1529              
00001886                          1530              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
00001886  B43C 0003               1531              CMP.B       #%11,D2
0000188A  6700 0006               1532              BEQ         mulsCheck
0000188E  6000 0028               1533              BRA         MAND
00001892                          1534              
00001892                          1535  mulsCheck:
00001892                          1536              ;Copy the address values into a register
00001892  3412                    1537              MOVE.W     (A2),D2
00001894                          1538              
00001894                          1539              ;Passing in parameters for isolating bit 8
00001894  163C 0008               1540              MOVE.B      #8,D3             ;Start bit index = 8
00001898  183C 0001               1541              MOVE.B      #1,D4             ;Number of bits needed = 1
0000189C                          1542              
0000189C                          1543              ;Jumps to getBits and returns with isolated bits in D2
0000189C  6100 F96A               1544              BSR         getBits 
000018A0                          1545              
000018A0                          1546              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
000018A0  B43C 0001               1547              CMP.B       #1,D2
000018A4  6700 0002               1548              BEQ         MMULS
000018A8                          1549              
000018A8                          1550              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
000018A8                          1551  
000018A8                          1552              
000018A8                          1553              
000018A8                          1554              
000018A8                          1555  MMULS:
000018A8  43F9 00001E9D           1556              LEA         printMULS,A1
000018AE  103C 000E               1557              MOVE.B      #14,D0
000018B2  4E4F                    1558              TRAP        #15
000018B4                          1559              
000018B4  6000 025A               1560              BRA         dnDest 
000018B8                          1561  
000018B8                          1562  
000018B8                          1563  MAND:
000018B8  43F9 00001EB2           1564              LEA        printAND,A1
000018BE  103C 000E               1565              MOVE.B     #14,D0
000018C2  4E4F                    1566              TRAP       #15
000018C4                          1567              
000018C4                          1568              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
000018C4                          1569              ;Jumps to printSizeSubroutine and returns after size has been printed
000018C4  6100 02D0               1570              BSR         printSizeSubroutine
000018C8                          1571              
000018C8                          1572              ;save size bit in $2000 incase needed for immediate addressing
000018C8  11C2 2000               1573              MOVE.B      D2,$2000
000018CC                          1574              
000018CC                          1575              ;======Isolate direction (D) Bit=======
000018CC                          1576              ; 0 = data register is destination | 1 = Dn is source
000018CC  4282                    1577              CLR.L       D2
000018CE                          1578              
000018CE                          1579              ;Copy the address values into a register
000018CE  3412                    1580              MOVE.W      (A2),D2
000018D0                          1581              
000018D0                          1582              ;Passing in parameters for isolating direction bit
000018D0  163C 0008               1583              MOVE.B      #8,D3           ;Start bit index = 8
000018D4  183C 0001               1584              MOVE.B      #1,D4           ;Number of bits needed = 1
000018D8                          1585  
000018D8                          1586              ;Jumps to getBits and returns with isolated bit in D2
000018D8  6100 F92E               1587              BSR         getBits
000018DC                          1588              
000018DC                          1589              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000018DC  B43C 0000               1590              CMP.B       #0,D2
000018E0  6700 022E               1591              BEQ         dnDest
000018E4  6000 024E               1592              BRA         dnSource
000018E8                          1593              
000018E8                          1594              
000018E8  6000 F900               1595              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
000018EC                          1596     
000018EC                          1597     
000018EC                          1598  *-----------------------------------------------------------
000018EC                          1599  * LSL,LSR,ASL,ASR INSTRUCTIONS
000018EC                          1600  *-----------------------------------------------------------  
000018EC                          1601  ; Subroutine to enter when the instruction begins with 1110
000018EC                          1602  M1110:
000018EC  4282                    1603              CLR.L       D2
000018EE  4283                    1604              CLR.L       D3
000018F0                          1605              
000018F0                          1606              ;Let's first check and see if the opcode might be ROXd or ROd
000018F0                          1607              ;since they share the same first 4 bits
000018F0  3412                    1608              MOVE.W      (A2),D2
000018F2                          1609              
000018F2                          1610              ;Passing in parameters for isolating bits 9-11
000018F2  163C 0009               1611              MOVE.B      #9,D3
000018F6  183C 0003               1612              MOVE.B      #3,D4
000018FA                          1613              
000018FA                          1614              ;These next two checks help us know if we have the right opcode
000018FA  B43C 0002               1615              CMP.B       #%010,D2
000018FE  6700 F8D2               1616              BEQ         invalid
00001902                          1617              
00001902  B43C 0007               1618              CMP.B       #%111,D2
00001906  6700 F8CA               1619              BEQ         invalid
0000190A                          1620              
0000190A                          1621              ;Now that we know we have the right opcode, we can continue as normal
0000190A  4282                    1622              CLR.L       D2
0000190C  4283                    1623              CLR.L       D3
0000190E  4284                    1624              CLR.L       D4            
00001910                          1625              
00001910                          1626              ;Copy the address values into a register
00001910  3412                    1627              MOVE.W     (A2),D2
00001912                          1628              
00001912                          1629              ;Passing in parameters for isolating bits 6-7
00001912  163C 0006               1630              MOVE.B      #6,D3             ;Start bit index = 6
00001916  183C 0002               1631              MOVE.B      #2,D4             ;Number of bits needed = 2
0000191A                          1632              
0000191A                          1633              ;Jumps to getBits and returns with isolated bits in D2
0000191A  6100 F8EC               1634              BSR         getBits  
0000191E                          1635              
0000191E                          1636              ;Check if Memory Shift
0000191E  B43C 0003               1637              CMP.B       #%11,D2
00001922  6700 00BC               1638              BEQ         MemShift
00001926                          1639              
00001926                          1640              ;If not Memory Shift, is a Register Shift
00001926                          1641              
00001926                          1642              ;Copy the address values into a register
00001926  3412                    1643              MOVE.W     (A2),D2
00001928                          1644              
00001928                          1645              ;Passing in parameters for isolating bit 3
00001928  163C 0003               1646              MOVE.B      #3,D3             ;Start bit index = 3
0000192C  183C 0001               1647              MOVE.B      #1,D4             ;Number of bits needed = 1
00001930                          1648              
00001930                          1649              ;Jumps to getBits and returns with isolated bits in D2
00001930  6100 F8D6               1650              BSR         getBits  
00001934                          1651              
00001934                          1652              ;Checks if ASd
00001934  B43C 0000               1653              CMP.B       #%0,D2
00001938  6700 00EC               1654              BEQ         RegAS
0000193C                          1655              
0000193C                          1656              ;Checks if LSd
0000193C  B43C 0001               1657              CMP.B       #%1,D2
00001940  6700 00EC               1658              BEQ         RegLS
00001944                          1659  
00001944                          1660  ; Subroutine to enter if instruction is given data register to shift
00001944                          1661  RegShift      
00001944                          1662              ;Copy the address values into a register
00001944  3412                    1663              MOVE.W     (A2),D2
00001946                          1664              
00001946                          1665              ;Passing in parameters for isolating bits 6-7
00001946  163C 0006               1666              MOVE.B      #6,D3             ;Start bit index = 6
0000194A  183C 0002               1667              MOVE.B      #2,D4             ;Number of bits needed = 2
0000194E                          1668              
0000194E                          1669              ;Jumps to getBits and returns with isolated bits in D2
0000194E  6100 F8B8               1670              BSR         getBits  
00001952                          1671              
00001952                          1672              ;Print Size
00001952  6100 0242               1673              BSR         printSizeSubroutine
00001956                          1674              
00001956                          1675              ;Copy the address values into a register
00001956  3412                    1676              MOVE.W     (A2),D2
00001958                          1677              
00001958                          1678              ;Passing in parameters for isolating bit 5
00001958  163C 0005               1679              MOVE.B      #5,D3             ;Start bit index = 5
0000195C  183C 0001               1680              MOVE.B      #1,D4             ;Number of bits needed = 1
00001960                          1681              
00001960                          1682              ;Jumps to getBits and returns with isolated bits in D2
00001960  6100 F8A6               1683              BSR         getBits  
00001964                          1684              
00001964                          1685              ;Checks if shift count is immediate
00001964  B43C 0000               1686              CMP.B       #%0,D2
00001968  6700 003C               1687              BEQ         ImmediateCount
0000196C                          1688              
0000196C                          1689              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000196C                          1690              ;D7 will contain the register after this instruction
0000196C  6100 0210               1691              BSR         isolateRegisterBit9to11
00001970                          1692              
00001970                          1693              ;Save #%000 into D6 to specify data register mode
00001970  1C3C 0000               1694              MOVE.B      #0,D6
00001974                          1695              
00001974                          1696              ;*Print Shift Count address*
00001974  6100 0292               1697              BSR         addressModeSR
00001978                          1698  
00001978  6100 0002               1699              BSR         RegShift2
0000197C                          1700  
0000197C                          1701  
0000197C                          1702  ; Resumes printing data register shift instruction after printing AS or LS
0000197C                          1703  RegShift2   ;Print comma after shift count
0000197C  43F9 00001F27           1704              LEA         printComma,A1
00001982  103C 000E               1705              MOVE.B      #14,D0
00001986  4E4F                    1706              TRAP        #15
00001988                          1707              
00001988                          1708              ;*Data Register to be Shifted*
00001988  4282                    1709              CLR.L       D2
0000198A                          1710              
0000198A                          1711              ;Copy the address values into a register
0000198A  3412                    1712              MOVE.W      (A2),D2
0000198C                          1713              
0000198C                          1714              ;Passing in parameters for isolating bits 0-2
0000198C  163C 0000               1715              MOVE.B      #0,D3             ;Start bit index = 0
00001990  183C 0003               1716              MOVE.B      #3,D4             ;Number of bits needed = 3
00001994                          1717              
00001994                          1718              ;Jumps to getBits and returns with isolated bits in D2
00001994  6100 F872               1719              BSR         getBits
00001998                          1720              
00001998                          1721              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001998  1E02                    1722              MOVE.B      D2,D7
0000199A                          1723              
0000199A                          1724              ;Save #%000 into D6 to specify data register mode
0000199A  1C3C 0000               1725              MOVE.B      #0,D6
0000199E                          1726              
0000199E                          1727              ;*Prints data register to be shifted*
0000199E  6100 0268               1728              BSR         addressModeSR
000019A2                          1729  
000019A2  6000 F846               1730              BRA         update
000019A6                          1731  
000019A6                          1732  ;Subroutine to enter if amount to shift is an immediate address            
000019A6                          1733  ImmediateCount
000019A6                          1734              ;Print #$
000019A6  43F9 00001F17           1735              LEA        printIA,A1
000019AC  103C 000E               1736              MOVE.B     #14,D0
000019B0  4E4F                    1737              TRAP       #15
000019B2                          1738              
000019B2                          1739              ;*Data Register to be Shifted*
000019B2  4282                    1740              CLR.L       D2
000019B4                          1741              
000019B4                          1742              ;Copy the address values into a register
000019B4  3412                    1743              MOVE.W     (A2),D2
000019B6                          1744              
000019B6                          1745              ;Passing in parameters for isolating bits 9-11
000019B6  163C 0009               1746              MOVE.B      #9,D3             ;Start bit index = 9
000019BA  183C 0003               1747              MOVE.B      #3,D4             ;Number of bits needed = 3
000019BE                          1748              
000019BE                          1749              ;Jumps to getBits and returns with isolated bits in D2
000019BE  6100 F848               1750              BSR         getBits  
000019C2                          1751              
000019C2                          1752              ;Check if shift count is 8
000019C2  B43C 0000               1753              CMP.B       #%000,D2
000019C6  6700 0010               1754              BEQ         ShiftEight
000019CA                          1755              
000019CA  2202                    1756              MOVE.L      D2, D1
000019CC  6100 0002               1757              BSR         ImmediateCount2
000019D0                          1758  ;Subroutine to print shift count           
000019D0                          1759  ImmediateCount2
000019D0                          1760              ;Print shift count
000019D0  103C 0003               1761              MOVE.B      #3,D0
000019D4  4E4F                    1762              TRAP        #15
000019D6  61A4                    1763              BSR         RegShift2
000019D8                          1764  ;Subroutine to enter if shift count is 8
000019D8                          1765  ShiftEight  
000019D8  4281                    1766              CLR.L       D1
000019DA                          1767              
000019DA                          1768              ;Move 8 into D1    
000019DA  123C 0008               1769              MOVE.B      #8, D1
000019DE  61F0                    1770              BSR         ImmediateCount2
000019E0                          1771              
000019E0                          1772  ; Subroutine to enter when the instruction is given a memory address to shift                         
000019E0                          1773  MemShift
000019E0                          1774              ;Copy the address values into a register
000019E0  3412                    1775              MOVE.W     (A2),D2
000019E2                          1776              
000019E2                          1777              ;Passing in parameters for isolating bit 9
000019E2  163C 0009               1778              MOVE.B      #9,D3             ;Start bit index = 9
000019E6  183C 0001               1779              MOVE.B      #1,D4             ;Number of bits needed = 1
000019EA                          1780              
000019EA                          1781              ;Jumps to getBits and returns with isolated bits in D2
000019EA  6100 F81C               1782              BSR         getBits  
000019EE                          1783              
000019EE                          1784              ;Checks if ASd
000019EE  B43C 0000               1785              CMP.B       #%0,D2
000019F2  6700 0022               1786              BEQ         MemAS
000019F6                          1787              
000019F6                          1788              ;Checks if LSd
000019F6  B43C 0001               1789              CMP.B       #%1,D2
000019FA  6700 0022               1790              BEQ         MemLS
000019FE                          1791              
000019FE                          1792  ; Continues memory address shift after printing AS or LS
000019FE                          1793  MemShift2   
000019FE                          1794              ;Print Space
000019FE  43F9 00001F29           1795              LEA        printSpace,A1
00001A04  103C 000E               1796              MOVE.B     #14,D0
00001A08  4E4F                    1797              TRAP       #15
00001A0A                          1798              
00001A0A                          1799              ;*Memory Address*
00001A0A                          1800              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001A0A                          1801              ;D6 will contain mode & D7 will contain the register after this instruction
00001A0A  6100 014C               1802              BSR         isolateAddressBit0to5
00001A0E                          1803              
00001A0E                          1804              ;*Print source address*
00001A0E  6100 01F8               1805              BSR         addressModeSR
00001A12                          1806              
00001A12  6000 F7D6               1807              BRA         update
00001A16                          1808  
00001A16                          1809  MemAS       ;Print AS
00001A16  6100 002C               1810              BSR         MAS      
00001A1A  6100 0036               1811              BSR         MemDirectionSubroutine                
00001A1E                          1812  
00001A1E                          1813              
00001A1E                          1814  MemLS       ;Print LS
00001A1E  6100 0016               1815              BSR         MLS      
00001A22  6100 002E               1816              BSR         MemDirectionSubroutine
00001A26                          1817              
00001A26                          1818  RegAS       ;Print AS
00001A26  6100 001C               1819              BSR         MAS      
00001A2A  6100 0062               1820              BSR         RegDirectionSubroutine                
00001A2E                          1821  
00001A2E                          1822  RegLS       ;Print LS
00001A2E  6100 0006               1823              BSR         MLS      
00001A32  6100 005A               1824              BSR         RegDirectionSubroutine
00001A36                          1825  
00001A36                          1826  ; Prints LS
00001A36                          1827  MLS:
00001A36  43F9 00001EF4           1828              LEA        printMLS,A1
00001A3C  103C 000E               1829              MOVE.B     #14,D0
00001A40  4E4F                    1830              TRAP       #15
00001A42  4E75                    1831              RTS
00001A44                          1832  ; Prints AS
00001A44                          1833  MAS:
00001A44  43F9 00001EF1           1834              LEA        printMAS,A1
00001A4A  103C 000E               1835              MOVE.B     #14,D0
00001A4E  4E4F                    1836              TRAP       #15
00001A50  4E75                    1837              RTS
00001A52                          1838  
00001A52                          1839  ;Subroutine for the direction if shifting a memory address
00001A52                          1840  MemDirectionSubroutine
00001A52                          1841              ;Copy the address values into a register
00001A52  3412                    1842              MOVE.W     (A2),D2
00001A54                          1843              
00001A54                          1844              ;Passing in parameters for isolating bit 8
00001A54  163C 0008               1845              MOVE.B      #8,D3             ;Start bit index = 8
00001A58  183C 0001               1846              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A5C                          1847              
00001A5C                          1848              ;Jumps to getBits and returns with isolated bits in D2
00001A5C  6100 F7AA               1849              BSR         getBits  
00001A60                          1850              
00001A60                          1851              ;Checks if Right
00001A60  B43C 0000               1852              CMP.B       #%0,D2
00001A64  6700 000A               1853              BEQ         MR
00001A68                          1854              
00001A68                          1855              ;Checks if Left
00001A68  B43C 0001               1856              CMP.B       #%1,D2
00001A6C  6700 0010               1857              BEQ         ML
00001A70                          1858                          
00001A70  43F9 00001EF9           1859  MR          LEA        printR,A1
00001A76  103C 000E               1860              MOVE.B     #14,D0
00001A7A  4E4F                    1861              TRAP       #15
00001A7C  6180                    1862              BSR        MemShift2
00001A7E                          1863  
00001A7E  43F9 00001EF7           1864  ML          LEA        printL,A1
00001A84  103C 000E               1865              MOVE.B     #14,D0
00001A88  4E4F                    1866              TRAP       #15
00001A8A  6100 FF72               1867              BSR        MemShift2
00001A8E                          1868  
00001A8E                          1869  ;Subroutine for the direction if shifting a data register        
00001A8E                          1870  RegDirectionSubroutine
00001A8E                          1871              ;Copy the address values into a register
00001A8E  3412                    1872              MOVE.W     (A2),D2
00001A90                          1873              
00001A90                          1874              ;Passing in parameters for isolating bit 8
00001A90  163C 0008               1875              MOVE.B      #8,D3             ;Start bit index = 8
00001A94  183C 0001               1876              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A98                          1877              
00001A98                          1878              ;Jumps to getBits and returns with isolated bits in D2
00001A98  6100 F76E               1879              BSR         getBits  
00001A9C                          1880              
00001A9C                          1881              ;Checks if Right
00001A9C  B43C 0000               1882              CMP.B       #%0,D2
00001AA0  6700 000A               1883              BEQ         RR
00001AA4                          1884              
00001AA4                          1885              ;Checks if Left
00001AA4  B43C 0001               1886              CMP.B       #%1,D2
00001AA8  6700 0012               1887              BEQ         RL
00001AAC                          1888                          
00001AAC  43F9 00001EF9           1889  RR          LEA        printR,A1
00001AB2  103C 000E               1890              MOVE.B     #14,D0
00001AB6  4E4F                    1891              TRAP       #15
00001AB8  6100 FE8A               1892              BSR        RegShift
00001ABC                          1893  
00001ABC  43F9 00001EF7           1894  RL          LEA        printL,A1
00001AC2  103C 000E               1895              MOVE.B     #14,D0
00001AC6  4E4F                    1896              TRAP       #15
00001AC8  6100 FE7A               1897              BSR        RegShift
00001ACC                          1898  
00001ACC                          1899  
00001ACC                          1900  *-----------------------------------------------------------------------
00001ACC                          1901  *-----------------------------------------------------------------------
00001ACC                          1902  *-----------------------------------------------------------------------
00001ACC                          1903  
00001ACC                          1904  
00001ACC                          1905  ;ADD
00001ACC                          1906  M1101:
00001ACC  43F9 00001E8B           1907              LEA        printADD,A1
00001AD2  103C 000E               1908              MOVE.B     #14,D0
00001AD6  4E4F                    1909              TRAP       #15
00001AD8                          1910              
00001AD8  4202                    1911              CLR.B      D2
00001ADA  4203                    1912              CLR.B      D3
00001ADC                          1913              
00001ADC                          1914              ;======Isolate Size (S) Bits=======
00001ADC                          1915              ;Copy the address values into a register
00001ADC  3412                    1916              MOVE.W     (A2),D2
00001ADE                          1917              
00001ADE                          1918              ;Passing in parameters for isolating size bits
00001ADE  163C 0006               1919              MOVE.B      #6,D3             ;Start bit index = 6
00001AE2  183C 0002               1920              MOVE.B      #2,D4             ;Number of bits needed = 2
00001AE6                          1921              
00001AE6                          1922              ;Jumps to getBits and returns with isolated bits in D2
00001AE6  6100 F720               1923              BSR         getBits  
00001AEA                          1924              
00001AEA                          1925              ;Jumps to printSizeSubroutine and returns after size has been printed
00001AEA  6100 00AA               1926              BSR         printSizeSubroutine
00001AEE                          1927         
00001AEE                          1928              ;Let's store the size indicator since it will help us determine how many times
00001AEE                          1929              ;we have to iterate through addresses to print out the whole instruction
00001AEE                          1930              ;We will use A4 as the register to temporary store the size
00001AEE  3842                    1931              MOVE.W      D2,A4
00001AF0  11C2 2000               1932              MOVE.B      D2,$2000
00001AF4                          1933              
00001AF4                          1934              ;======Isolate direction (D) Bit=======
00001AF4                          1935              ; 0 = data register is destination | 1 = Dn is source
00001AF4  4282                    1936              CLR.L       D2
00001AF6                          1937              
00001AF6                          1938              ;Copy the address values into a register
00001AF6  3412                    1939              MOVE.W      (A2),D2
00001AF8                          1940              
00001AF8                          1941              ;Passing in parameters for isolating direction bit
00001AF8  163C 0008               1942              MOVE.B      #8,D3             ;Start bit index = 8
00001AFC  183C 0001               1943              MOVE.B      #1,D4             ;Number of bits needed = 1
00001B00                          1944              
00001B00                          1945              ;Jumps to getBits and returns with isolated bit in D2
00001B00  6100 F706               1946              BSR         getBits
00001B04                          1947              
00001B04                          1948              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001B04  B43C 0000               1949              CMP.B       #0,D2
00001B08  6700 0006               1950              BEQ         dnDest
00001B0C  6000 0026               1951              BRA         dnSource
00001B10                          1952              
00001B10                          1953  
00001B10                          1954  *-----------------------------------------------------------------
00001B10                          1955  * dnDest, dnSource, & other subroutines for isolating address bits
00001B10                          1956  *-----------------------------------------------------------------
00001B10                          1957  ;* dnDest,dnSource *
00001B10                          1958  ;For: MULS,AND,ADD,SUB,DIVU
00001B10                          1959  ;Used by instructions that require Dn as one of their addressing modes.
00001B10                          1960  ;dnDest isolates the addressing bits with Dn being the destination address
00001B10                          1961  ;dnSource isolates the addressing bits with Dn being the source address
00001B10                          1962  
00001B10                          1963  dnDest:
00001B10                          1964              ;**Used for isolating addressing bits when Dn is the destination**
00001B10                          1965              
00001B10                          1966              ;*SOURCE*
00001B10                          1967              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B10                          1968              ;D6 will contain mode & D7 will contain the register after this instruction
00001B10  6100 0046               1969              BSR         isolateAddressBit0to5
00001B14                          1970              
00001B14                          1971              ;*Print source address*
00001B14  6100 00F2               1972              BSR         addressModeSR
00001B18                          1973              
00001B18                          1974              ;Print comma after source address
00001B18  43F9 00001F27           1975              LEA         printComma,A1
00001B1E  103C 000E               1976              MOVE.B      #14,D0
00001B22  4E4F                    1977              TRAP        #15
00001B24                          1978              
00001B24                          1979              ;*DESTINATION*
00001B24                          1980              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B24                          1981              ;D7 will contain the register after this instruction
00001B24  6100 0058               1982              BSR         isolateRegisterBit9to11
00001B28                          1983              
00001B28                          1984              ;Save #%000 into D6 to specify data register mode
00001B28  1C3C 0000               1985              MOVE.B      #0,D6
00001B2C                          1986              
00001B2C                          1987              ;*Print destination address*
00001B2C  6100 00DA               1988              BSR         addressModeSR
00001B30                          1989  
00001B30  6000 F6B8               1990              BRA         update
00001B34                          1991              
00001B34                          1992  dnSource:
00001B34                          1993              ;**Used for isolating addressing bits when Dn is the destination**
00001B34                          1994                          
00001B34                          1995              ;*SOURCE*
00001B34                          1996              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B34                          1997              ;D7 will contain the register after this instruction
00001B34  6100 0048               1998              BSR         isolateRegisterBit9to11
00001B38                          1999              
00001B38                          2000              ;Save #%000 into D6 to specify data register mode
00001B38  1C3C 0000               2001              MOVE.B      #0,D6
00001B3C                          2002              
00001B3C                          2003              ;*Print Source address*
00001B3C  6100 00CA               2004              BSR         addressModeSR
00001B40                          2005              
00001B40                          2006              ;Print comma after source address
00001B40  43F9 00001F27           2007              LEA         printComma,A1
00001B46  103C 000E               2008              MOVE.B      #14,D0
00001B4A  4E4F                    2009              TRAP        #15
00001B4C                          2010              
00001B4C                          2011              ;*DESTINATION*
00001B4C                          2012              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B4C                          2013              ;D6 will contain mode & D7 will contain the register after this instruction
00001B4C  6100 000A               2014              BSR         isolateAddressBit0to5
00001B50                          2015              
00001B50                          2016              ;*Print destination address*
00001B50  6100 00B6               2017              BSR         addressModeSR
00001B54                          2018  
00001B54  6000 F694               2019              BRA         update
00001B58                          2020                     
00001B58                          2021  isolateAddressBit0to5:
00001B58                          2022  ;Helper subroutine for isolating the address stored within bits 0-5
00001B58                          2023  ;Stores address mode in D6
00001B58                          2024  ;Stores address register in D7
00001B58                          2025  
00001B58                          2026              ;======Isolate Effective Address Mode (M) Bits=======
00001B58  4282                    2027              CLR.L       D2
00001B5A                          2028              
00001B5A                          2029              ;Copy the address values into a register
00001B5A  3412                    2030              MOVE.W      (A2),D2
00001B5C                          2031              
00001B5C                          2032              ;Passing in parameters for isolating Mode bits
00001B5C  163C 0003               2033              MOVE.B      #3,D3             ;Start bit index = 3
00001B60  183C 0003               2034              MOVE.B      #3,D4             ;Number of bits needed = 3
00001B64                          2035              
00001B64                          2036              ;Jumps to getBits and returns with isolated bits in D2
00001B64  4EB8 1208               2037              JSR         getBits
00001B68                          2038              
00001B68                          2039              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001B68  1C02                    2040              MOVE.B      D2,D6
00001B6A                          2041              
00001B6A                          2042                       
00001B6A                          2043              ;======Isolate Effective Address Register (Xn) Bits=======
00001B6A  4282                    2044              CLR.L       D2
00001B6C                          2045              
00001B6C                          2046              ;Copy the address values into a register
00001B6C  3412                    2047              MOVE.W      (A2),D2
00001B6E                          2048              
00001B6E                          2049              ;Passing in parameters for isolating Xn bits
00001B6E  163C 0000               2050              MOVE.B      #0,D3             ;Start bit index = 0
00001B72  183C 0003               2051              MOVE.B      #3,D4             ;Number of bits needed = 3
00001B76                          2052              
00001B76                          2053              ;Jumps to getBits and returns with isolated bits in D2
00001B76  6100 F690               2054              BSR         getBits
00001B7A                          2055              
00001B7A                          2056              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001B7A  1E02                    2057              MOVE.B      D2,D7
00001B7C                          2058              
00001B7C  4E75                    2059              RTS
00001B7E                          2060  
00001B7E                          2061  isolateRegisterBit9to11:
00001B7E                          2062  ;Helper subroutine for isolating the register stored within bits 9-11
00001B7E                          2063  ;Stores the address register in D7
00001B7E                          2064  
00001B7E                          2065              ;======Isolate Register Bits=======
00001B7E  4282                    2066              CLR.L       D2
00001B80  4286                    2067              CLR.L       D6
00001B82  4287                    2068              CLR.L       D7
00001B84                          2069              
00001B84                          2070              ;Copy the address values into a register
00001B84  3412                    2071              MOVE.W      (A2),D2
00001B86                          2072              
00001B86                          2073              ;Passing in parameters for isolating register bits
00001B86  163C 0009               2074              MOVE.B      #9,D3             ;Start bit index = 9
00001B8A  183C 0003               2075              MOVE.B      #3,D4             ;Number of bits needed = 3
00001B8E                          2076              
00001B8E                          2077              ;Jumps to getBits and returns with isolated bit in D2
00001B8E  6100 F678               2078              BSR         getBits
00001B92                          2079              
00001B92                          2080              ;Save register bit into ***D7*** for later use in addressModeSR
00001B92  1E02                    2081              MOVE.B      D2,D7
00001B94                          2082  
00001B94  4E75                    2083              RTS
00001B96                          2084              
00001B96                          2085  *-----------------------------------------------------------
00001B96                          2086  * Print Sizes
00001B96                          2087  *-----------------------------------------------------------
00001B96                          2088  printSizeSubroutine:
00001B96                          2089              ;Prints the apporpriate size
00001B96                          2090              ;PARAMETER:
00001B96                          2091              ;D2 = the size bits
00001B96                          2092              
00001B96                          2093              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
00001B96  B63C 0001               2094              CMP.B      #1,D3
00001B9A  6700 001A               2095              BEQ        printMOVESize
00001B9E                          2096              
00001B9E                          2097              ;Compare to which size is being moved for the opcode
00001B9E  B43C 0000               2098              CMP.B      #%00,D2
00001BA2  6700 003A               2099              BEQ        PByte
00001BA6                          2100              
00001BA6  B43C 0001               2101              CMP.B      #%01,D2
00001BAA  6700 0040               2102              BEQ        PWord
00001BAE                          2103              
00001BAE  B43C 0002               2104              CMP.B      #%10,D2
00001BB2  6700 0046               2105              BEQ        PLong
00001BB6                          2106           
00001BB6                          2107  printMOVESize:
00001BB6                          2108              ;Now that we know we have a MOVE opcode
00001BB6                          2109              ;Compare to which size is being moved for the opcode
00001BB6  B43C 0001               2110              CMP.B      #%01,D2
00001BBA  6700 0022               2111              BEQ        PByte
00001BBE                          2112  
00001BBE  B43C 0003               2113              CMP.B      #%11,D2
00001BC2  6700 0028               2114              BEQ        PWord            
00001BC6                          2115    
00001BC6  B43C 0002               2116              CMP.B      #%10,D2
00001BCA  6700 002E               2117              BEQ        PLong
00001BCE                          2118              
00001BCE                          2119  printMOVEMSize:
00001BCE                          2120              ;Now that we know we have a MOVEM opcode
00001BCE                          2121              ;Compare to which size is being moved for the opcode
00001BCE  B43C 0000               2122              CMP.B      #%0,D2
00001BD2  6700 0018               2123              BEQ        PWord
00001BD6                          2124              
00001BD6  B43C 0001               2125              CMP.B      #%1,D2
00001BDA  6700 001E               2126              BEQ        PLong
00001BDE                          2127  
00001BDE                          2128  PByte:
00001BDE  43F9 00001EFB           2129              LEA        printSIZEB,A1
00001BE4  103C 000E               2130              MOVE.B     #14,D0
00001BE8  4E4F                    2131              TRAP       #15
00001BEA                          2132              
00001BEA  4E75                    2133              RTS
00001BEC                          2134  PWord:
00001BEC  43F9 00001F00           2135              LEA        printSIZEW,A1
00001BF2  103C 000E               2136              MOVE.B     #14,D0
00001BF6  4E4F                    2137              TRAP       #15
00001BF8                          2138              
00001BF8  4E75                    2139              RTS
00001BFA                          2140  PLong:            
00001BFA  43F9 00001F06           2141              LEA        printSIZEL,A1
00001C00  103C 000E               2142              MOVE.B     #14,D0
00001C04  4E4F                    2143              TRAP       #15
00001C06                          2144              
00001C06  4E75                    2145              RTS
00001C08                          2146              
00001C08                          2147  *-----------------------------------------------------------
00001C08                          2148  * Addressing Mode Implementation
00001C08                          2149  *-----------------------------------------------------------
00001C08                          2150  addressModeSR:
00001C08                          2151              ;Prints address according to the parameters passed in
00001C08                          2152              ;PARAMETERS:
00001C08                          2153              ;D6 = mode
00001C08                          2154              ;D7 = register
00001C08                          2155  
00001C08                          2156              ;Data register direct
00001C08  BC3C 0000               2157              CMP.B       #%000,D6
00001C0C  6700 002A               2158              BEQ         DRD
00001C10                          2159              
00001C10                          2160              ;Address register direct
00001C10  BC3C 0001               2161              CMP.B       #%001,D6
00001C14  6700 0036               2162              BEQ         ARD
00001C18                          2163              
00001C18                          2164              ;Address register indirect
00001C18  BC3C 0002               2165              CMP.B       #%010,D6
00001C1C  6700 0042               2166              BEQ         ARI
00001C20                          2167              
00001C20                          2168              ;Post Increment
00001C20  BC3C 0003               2169              CMP.B       #%011,D6
00001C24  6700 005A               2170              BEQ         PI
00001C28                          2171              
00001C28                          2172              ;Pre Decrement
00001C28  BC3C 0004               2173              CMP.B       #%100,D6
00001C2C  6700 0072               2174              BEQ         PD
00001C30                          2175              
00001C30                          2176              ;Immediate/Absolute Addressing
00001C30  BC3C 0007               2177              CMP.B       #%111,D6
00001C34  6700 008A               2178              BEQ         otherModes
00001C38                          2179  DRD:
00001C38                          2180              ;Print D __
00001C38  43F9 00001F0E           2181              LEA         printDRD,A1
00001C3E  103C 000E               2182              MOVE.B      #14,D0
00001C42  4E4F                    2183              TRAP        #15
00001C44                          2184              
00001C44                          2185              ;Print register number
00001C44  7003                    2186              MOVE.L      #3,D0
00001C46  2207                    2187              MOVE.L      D7,D1
00001C48  4E4F                    2188              TRAP        #15
00001C4A                          2189              
00001C4A  4E75                    2190              RTS
00001C4C                          2191  ARD:
00001C4C                          2192              ;Print A __
00001C4C  43F9 00001F10           2193              LEA         printARD,A1
00001C52  103C 000E               2194              MOVE.B      #14,D0
00001C56  4E4F                    2195              TRAP        #15
00001C58                          2196              
00001C58                          2197              ;Print register number
00001C58  7003                    2198              MOVE.L      #3,D0
00001C5A  2207                    2199              MOVE.L      D7,D1
00001C5C  4E4F                    2200              TRAP        #15
00001C5E                          2201              
00001C5E  4E75                    2202              RTS
00001C60                          2203  ARI:
00001C60                          2204              ;Print (A __ )
00001C60  43F9 00001F12           2205              LEA         printARI,A1
00001C66  103C 000E               2206              MOVE.B      #14,D0
00001C6A  4E4F                    2207              TRAP        #15
00001C6C                          2208              
00001C6C                          2209              ;Print register number
00001C6C  7003                    2210              MOVE.L      #3,D0
00001C6E  2207                    2211              MOVE.L      D7,D1
00001C70  4E4F                    2212              TRAP        #15
00001C72                          2213              
00001C72                          2214              ;Print closing ')'
00001C72  43F9 00001F15           2215              LEA         printARI2,A1
00001C78  103C 000E               2216              MOVE.B      #14,D0
00001C7C  4E4F                    2217              TRAP        #15
00001C7E                          2218              
00001C7E  4E75                    2219              RTS
00001C80                          2220  PI:
00001C80                          2221              ;Print (A __)+
00001C80  43F9 00001F1B           2222              LEA         printPI,A1
00001C86  103C 000E               2223              MOVE.B      #14,D0
00001C8A  4E4F                    2224              TRAP        #15
00001C8C                          2225              
00001C8C                          2226              ;Print register number
00001C8C  7003                    2227              MOVE.L      #3,D0
00001C8E  2207                    2228              MOVE.L      D7,D1
00001C90  4E4F                    2229              TRAP        #15
00001C92                          2230              
00001C92                          2231              ;Print closing ')+'
00001C92  43F9 00001F1E           2232              LEA         printPI2,A1
00001C98  103C 000E               2233              MOVE.B      #14,D0
00001C9C  4E4F                    2234              TRAP        #15
00001C9E                          2235              
00001C9E  4E75                    2236              RTS
00001CA0                          2237  PD:
00001CA0                          2238              ;Print -(A __)
00001CA0  43F9 00001F21           2239              LEA         printPD,A1
00001CA6  103C 000E               2240              MOVE.B      #14,D0
00001CAA  4E4F                    2241              TRAP        #15
00001CAC                          2242              
00001CAC                          2243              ;Print register number
00001CAC  7003                    2244              MOVE.L      #3,D0
00001CAE  2207                    2245              MOVE.L      D7,D1
00001CB0  4E4F                    2246              TRAP        #15
00001CB2                          2247              
00001CB2                          2248              ;Print closing ')'
00001CB2  43F9 00001F25           2249              LEA         printPD2,A1
00001CB8  103C 000E               2250              MOVE.B      #14,D0
00001CBC  4E4F                    2251              TRAP        #15
00001CBE                          2252              
00001CBE  4E75                    2253              RTS
00001CC0                          2254  
00001CC0                          2255  otherModes:
00001CC0  B4CE                    2256              CMP.W       A6,A2
00001CC2                          2257              
00001CC2  6D00 0004               2258              BLT         SKIPCOPY  
00001CC6                          2259  
00001CC6                          2260               *=====Important step for making sure we have access to where A2 orignally points=====*
00001CC6  2C4A                    2261              MOVEA.L     A2,A6 
00001CC8                          2262  
00001CC8                          2263  
00001CC8                          2264  SKIPCOPY:            
00001CC8                          2265              
00001CC8                          2266              ;Branch to Immediate if register bits are %100       
00001CC8  BE3C 0004               2267              CMP.B       #%100,D7
00001CCC  6700 0006               2268              BEQ         Immediate
00001CD0                          2269              
00001CD0                          2270              ;Otherwise, branch to Absolute
00001CD0  6000 0022               2271              BRA         Absolute
00001CD4                          2272              
00001CD4                          2273          
00001CD4                          2274                     
00001CD4                          2275  Immediate:
00001CD4                          2276              ;Print #
00001CD4  43F9 00001F17           2277              LEA         printIA,A1
00001CDA  103C 000E               2278              MOVE.B      #14,D0
00001CDE  4E4F                    2279              TRAP        #15
00001CE0                          2280              
00001CE0                          2281              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001CE0                          2282              ;We will be able to access the contents of either size B or W
00001CE0  544E                    2283              ADDA.W      #2,A6         
00001CE2                          2284  
00001CE2                          2285              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
00001CE2  0C38 0002 2000          2286              CMP.B       #%10,$2000
00001CE8  6700 0040               2287              BEQ         IMDLong
00001CEC                          2288              
00001CEC                          2289              ;If we don't branch, then we assume we're printing out a byte or word      
00001CEC  7003                    2290              MOVE.L      #3,D0
00001CEE  3216                    2291              MOVE.W      (A6),D1
00001CF0  4E4F                    2292              TRAP        #15
00001CF2                          2293              
00001CF2  4E75                    2294              RTS
00001CF4                          2295              
00001CF4                          2296              
00001CF4                          2297              
00001CF4                          2298  Absolute:
00001CF4                          2299              ;Print $
00001CF4  43F9 00001F19           2300              LEA         printA,A1
00001CFA  103C 000E               2301              MOVE.B      #14,D0
00001CFE  4E4F                    2302              TRAP        #15
00001D00                          2303              
00001D00                          2304              ;Point to the next word (contains memory address)
00001D00  544E                    2305              ADDA.W      #2,A6
00001D02                          2306              
00001D02                          2307              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
00001D02  BE3C 0001               2308              CMP.B       #%001,D7
00001D06  6700 000C               2309              BEQ         AbsLong
00001D0A                          2310              
00001D0A                          2311              ;Print out the value in the address if it's a word
00001D0A  4281                    2312              CLR.L       D1
00001D0C                          2313              
00001D0C  3216                    2314              MOVE.W      (A6),D1
00001D0E  6100 004E               2315              BSR         hex_L
00001D12                          2316              
00001D12  4E75                    2317              RTS
00001D14                          2318              
00001D14                          2319  AbsLong:            
00001D14                          2320              ;Place the current value into a temp register
00001D14  3816                    2321              MOVE.W      (A6),D4
00001D16                          2322              
00001D16                          2323              ;Shift the bits so we can enter the rest of the values
00001D16  1E3C 0010               2324              MOVE.B      #16,D7
00001D1A  EFAC                    2325              LSL.L       D7,D4
00001D1C                          2326              
00001D1C                          2327              ;Increment A6 to account for the next values in the instruction
00001D1C  544E                    2328              ADDA.W      #2,A6
00001D1E                          2329              
00001D1E                          2330              ;Move the rest of the machine code into our register
00001D1E                          2331              ;This register should have the whole long values
00001D1E  3816                    2332              MOVE.W      (A6),D4
00001D20                          2333              
00001D20                          2334              ;Print the Long address
00001D20  4281                    2335              CLR.L       D1
00001D22                          2336              
00001D22  2204                    2337              MOVE.L      D4,D1
00001D24  6100 0038               2338              BSR         hex_L
00001D28                          2339              
00001D28  4E75                    2340              RTS    
00001D2A                          2341          
00001D2A                          2342          
00001D2A                          2343  IMDLong:
00001D2A                          2344              *********USED FOR IMMEDIATE LONGS ONLY***************
00001D2A                          2345              
00001D2A                          2346              ;Place the current value into a temp register
00001D2A  3816                    2347              MOVE.W      (A6),D4
00001D2C                          2348              
00001D2C                          2349              ;Shift the bits so we can enter the rest of the values
00001D2C  1E3C 0010               2350              MOVE.B      #16,D7
00001D30  EFAC                    2351              LSL.L       D7,D4
00001D32                          2352              
00001D32                          2353              ;Increment A2 to account for the next values in the machine code
00001D32  544E                    2354              ADDA.W      #2,A6
00001D34                          2355              
00001D34                          2356              ;Move the rest of the machine code into our register
00001D34                          2357              ;This register should have the whole long values
00001D34  3816                    2358              MOVE.W      (A6),D4
00001D36                          2359              
00001D36                          2360              ;Print out the value in the address
00001D36  7003                    2361              MOVE.L      #3,D0
00001D38  2204                    2362              MOVE.L      D4,D1
00001D3A  4E4F                    2363              TRAP        #15
00001D3C                          2364              
00001D3C  4E75                    2365              RTS
00001D3E                          2366  
00001D3E                          2367  *-----------------------------------------------------------
00001D3E                          2368  * Print Instructions for NOP and RTS
00001D3E                          2369  *-----------------------------------------------------------
00001D3E                          2370  printMNOP:
00001D3E  43F9 00001E7C           2371              LEA        printNOP,A1
00001D44  103C 000E               2372              MOVE.B     #14,D0
00001D48  4E4F                    2373              TRAP       #15
00001D4A                          2374              
00001D4A  6000 F49E               2375              BRA        update
00001D4E                          2376  
00001D4E                          2377  printMRTS:
00001D4E  43F9 00001EE8           2378              LEA        printRTS,A1
00001D54  103C 000E               2379              MOVE.B     #14,D0
00001D58  4E4F                    2380              TRAP       #15
00001D5A                          2381              
00001D5A  6000 F48E               2382              BRA        update
00001D5E                          2383              
00001D5E                          2384  *---------------------------------------------------------------------------------
00001D5E                          2385  * Subroutine for printing D1.L in hex:
00001D5E                          2386  *---------------------------------------------------------------------------------
00001D5E  3F3C 0000               2387  hex_L:  MOVE.W  #0, -(A7) ; Push a null termination for the string to be printed.
00001D62  224F                    2388          MOVEA.L A7, A1    ; Initialize A1 to the current value of stack pointer.
00001D64  2001                    2389          MOVE.L  D1, D0    ; Copy source value into D0, so that D1 is preserved.
00001D66  1400                    2390  hex_1L: MOVE.B  D0, D2    ; Beginning of the loop; copy the current byte into D2.
00001D68  0202 000F               2391          ANDI.B  #$F, D2   ; Apply a mask to isolate the current hex digit.
00001D6C  B43C 0009               2392          CMP.B   #$9, D2   ; Compare the current hex value to $9.
00001D70  6F00 0004               2393          BLE     hex_2L    ; If value is between $0 and $9, skip the next line.
00001D74  5E02                    2394          ADDI.B  #7, D2    ; If value is above $9, add an extra 7 to its ASCII.
00001D76  0602 0030               2395  hex_2L: ADDI.B  #48, D2   ; Add 48 to get ASCII code of the current hex digit.
00001D7A  5389                    2396          SUBA.L  #1, A1    ; Shift the address pointer back by one byte.
00001D7C  1282                    2397          MOVE.B  D2, (A1)  ; Copy ASCII value of the current digit to the stack.
00001D7E  E888                    2398          LSR.L   #4, D0    ; Shift the remainder to the right by one hex digit.
00001D80  66E4                    2399          BNE     hex_1L    ; If remainder is nonzero, loop to get the next digit.
00001D82  700E                    2400          MOVE.L  #14, D0   ; Task ID #14 for printing a null-terminated string.
00001D84  4E4F                    2401          TRAP    #15       ; Print the hex string equivalent of the source value.
00001D86  548F                    2402          ADDA.L  #2, A7    ; Point the stack pointer back at the return address.
00001D88  4E75                    2403          RTS               ; Exit the subroutine
00001D8A                          2404  *---------------------------------------------------------------------------------
00001D8A                          2405  
00001D8A                          2406  ;-----------------------------------------------------------
00001D8A                          2407  ;ERROR MESSAGES FOR I/O portion
00001D8A                          2408  ;-----------------------------------------------------------
00001D8A                          2409  charError:
00001D8A                          2410              
00001D8A  43F9 00001F50           2411              LEA         invalCh,A1
00001D90  103C 000E               2412              MOVE.B      #14,D0
00001D94  4E4F                    2413              TRAP        #15
00001D96                          2414              
00001D96  6000 F288               2415              BRA         startingPrompt
00001D9A                          2416            
00001D9A                          2417  oddError:
00001D9A  43F9 00001F71           2418              LEA         odd,A1
00001DA0  103C 000E               2419              MOVE.B      #14,D0
00001DA4  4E4F                    2420              TRAP        #15
00001DA6                          2421              
00001DA6  6000 F278               2422              BRA         startingPrompt
00001DAA                          2423              
00001DAA                          2424  manyCharError:  
00001DAA  43F9 00001F9E           2425              LEA         manyChar, A1
00001DB0  103C 000E               2426              MOVE.B      #14,D0
00001DB4  4E4F                    2427              TRAP        #15
00001DB6                          2428              
00001DB6  6000 F268               2429              BRA         startingPrompt
00001DBA                          2430           
00001DBA                          2431  endGreater:
00001DBA  43F9 00001FD9           2432              LEA         endG,A1
00001DC0  103C 000E               2433              MOVE.B      #14,D0
00001DC4  4E4F                    2434              TRAP        #15
00001DC6                          2435              
00001DC6  6000 F258               2436              BRA         startingPrompt
00001DCA                          2437         
00001DCA                          2438  ;-----------------------------------------------------------
00001DCA                          2439  ;MESSAGES
00001DCA                          2440  ;-----------------------------------------------------------
00001DCA= 57 65 6C 63 6F 6D ...   2441  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001DEE= 50 6C 65 61 73 65 ...   2442  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001E30= 50 6C 65 61 73 65 ...   2443  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001E70= 0D 0A 41 64 64 72 ...   2444  AddressNum  DC.B        CR,LF,'Address: ',0
00001E7C                          2445  
00001E7C                          2446  ;-----------------------------------------------------------
00001E7C                          2447  ;OPCODE Messages
00001E7C                          2448  ;-----------------------------------------------------------
00001E7C= 4E 4F 50 00             2449  printNOP    DC.B        'NOP',0
00001E80= 4D 4F 56 45 00          2450  printMOVE   DC.B        'MOVE',0
00001E85= 4D 4F 56 45 4D 00       2451  printMOVEM  DC.B        'MOVEM',0
00001E8B= 41 44 44 00             2452  printADD    DC.B        'ADD',0
00001E8F= 41 44 44 49 00          2453  printADDI   DC.B        'ADDI',0
00001E94= 53 55 42 00             2454  printSUB    DC.B        'SUB',0
00001E98= 53 55 42 49 00          2455  printSUBI   DC.B        'SUBI',0
00001E9D= 4D 55 4C 53 2E 57 ...   2456  printMULS   DC.B        'MULS.W ',0
00001EA5= 44 49 56 55 2E 57 ...   2457  printDIVU   DC.B        'DIVU.W ',0
00001EAD= 4C 45 41 20 00          2458  printLEA    DC.B        'LEA ',0
00001EB2= 41 4E 44 00             2459  printAND    DC.B        'AND',0
00001EB6= 41 4E 44 49 00          2460  printANDI   DC.B        'ANDI',0
00001EBB= 4E 4F 54 00             2461  printNOT    DC.B        'NOT',0
00001EBF= 4C 53 4C 00             2462  printLSL    DC.B        'LSL',0
00001EC3= 4C 53 52 00             2463  printLSR    DC.B        'LSR',0
00001EC7= 41 53 4C 00             2464  printASL    DC.B        'ASL',0
00001ECB= 41 53 52 00             2465  printASR    DC.B        'ASR',0
00001ECF= 42 4C 54 20 00          2466  printBLT    DC.B        'BLT ',0
00001ED4= 42 47 45 20 00          2467  printBGE    DC.B        'BGE ',0
00001ED9= 42 45 51 20 00          2468  printBEQ    DC.B        'BEQ ',0
00001EDE= 42 43 43 20 00          2469  printBCC    DC.B        'BCC ',0
00001EE3= 4A 53 52 20 00          2470  printJSR    DC.B        'JSR ',0
00001EE8= 52 54 53 00             2471  printRTS    DC.B        'RTS',0
00001EEC= 42 52 41 20 00          2472  printBRA    DC.B        'BRA ',0
00001EF1= 41 53 00                2473  printMAS    DC.B        'AS',0
00001EF4= 4C 53 00                2474  printMLS    DC.B        'LS',0
00001EF7= 4C 00                   2475  printL      DC.B        'L',0    
00001EF9= 52 00                   2476  printR      DC.B        'R',0
00001EFB                          2477  ;-----------------------------------------------------------
00001EFB                          2478  ;Size Messages
00001EFB                          2479  ;-----------------------------------------------------------
00001EFB= 2E 42 20 00             2480  printSIZEB  DC.B        '.B ',0
00001F00= 2E57 2000 0000          2481  printSIZEW  DC.W        '.W ',0
00001F06= 2E4C2000 00000000       2482  printSIZEL  DC.L        '.L ',0
00001F0E                          2483  
00001F0E                          2484  ;-----------------------------------------------------------
00001F0E                          2485  ;Addressing Mode Messages
00001F0E                          2486  ;-----------------------------------------------------------
00001F0E= 44 00                   2487  printDRD      DC.B        'D',0
00001F10= 41 00                   2488  printARD      DC.B        'A',0
00001F12= 28 41 00                2489  printARI      DC.B        '(A',0
00001F15= 29 00                   2490  printARI2     DC.B        ')',0
00001F17= 23 00                   2491  printIA       DC.B        '#',0
00001F19= 24 00                   2492  printA        DC.B        '$',0
00001F1B= 28 41 00                2493  printPI       DC.B        '(A',0
00001F1E= 29 2B 00                2494  printPI2      DC.B        ')+',0
00001F21= 2D 28 41 00             2495  printPD       DC.B        '-(A',0
00001F25= 29 00                   2496  printPD2      DC.B        ')',0
00001F27                          2497  
00001F27= 2C 00                   2498  printComma    DC.B        ',',0
00001F29= 20 00                   2499  printSpace    DC.B        ' ',0
00001F2B= 2F 00                   2500  printSlash    DC.B        '/',0
00001F2D= 2D 00                   2501  printDash     DC.B        '-',0
00001F2F                          2502  
00001F2F= 0D 0A 59 6F 75 20 ...   2503  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001F50                          2504  
00001F50                          2505  ;-----------------------------------------------------------
00001F50                          2506  ;ERRORS
00001F50                          2507  ;-----------------------------------------------------------
00001F50= 45 52 52 4F 52 3A ...   2508  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001F71= 45 52 52 4F 52 3A ...   2509  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001F9E= 45 52 52 4F 52 3A ...   2510  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001FD9= 45 52 52 4F 52 3A ...   2511  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
0000201E= 45 52 52 4F 52 3A ...   2512  sizeError   DC.B        'ERROR: Invalid size instruction',0
0000203E= 45 52 52 4F 52 3A ...   2513  invalOpcode DC.B        'ERROR: Invalid opcode = ',0
00002057                          2514  
00002058  4283                    2515              CLR.L       D3     
0000205A                          2516  
0000205A                          2517  ;-----------------------------------------------------------
0000205A                          2518  ;Ending function that ends our program 
0000205A                          2519  ;-----------------------------------------------------------
0000205A                          2520  ending:
0000205A  43F8 1F2F               2521              LEA         theEnd,A1
0000205E  303C 000E               2522              MOVE        #14,D0
00002062  4E4F                    2523              TRAP        #15
00002064                          2524              
00002064                          2525              END         MAIN  

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1D14
ABSOLUTE            1CF4
ABSOLUTEADDRESSMOVEM  14E0
ADD16BITS           1790
ADD32BITS           17D2
ADD8BITS            174E
ADDRESSMODESR       1C08
ADDRESSNUM          1E70
ARD                 1C4C
ARI                 1C60
BCCOFFSET           171E
BIT16DISPLACEMENT   177C
BIT32DISPLACEMENT   17BE
BIT8DISPLACEMENT    1740
BITLOOP             1556
CHARERROR           1D8A
CHECK               14E4
CONTINUE16BITS      17A2
CONTINUE32BITS      17E4
CONTINUE8BITS       1760
CONTINUEDIVU        1820
CONTINUEI           1262
CONVERT             1074
COUNTER             1008
CR                  D
CURADD              100C
DNDEST              1B10
DNSOURCE            1B34
DORA                100A
DRD                 1C38
ENDG                1FD9
ENDGREATER          1DBA
ENDHEX              1004
ENDING              205A
ENDINGPROMPT        104C
FINDLIST            1508
FINDLIST2           152A
GETBITS             1208
HEX_1L              1D66
HEX_2L              1D76
HEX_L               1D5E
IMDLONG             1D2A
IMMEDIATE           1CD4
IMMEDIATECOUNT      19A6
IMMEDIATECOUNT2     19D0
INVALCH             1F50
INVALID             11D2
INVALOPCODE         203E
ISOADDBIT0TO5       12E6
ISOLATEADDRESSBIT0TO5  1B58
ISOLATEADDRESSBIT6TO11  136E
ISOLATEREGISTERBIT9TO11  1B7E
LETTER              1098
LF                  A
LISTSIZE            100F
LISTTOMEM           144E
LISTTOMEM2          146C
LOOP                1128
M00                 130C
M0000               121E
M0100               1394
M0110               1684
M1000               1800
M1001               1830
M1100               1874
M1101               1ACC
M1110               18EC
MADDI               1256
MAIN                1000
MAND                18B8
MANDI               1246
MANYCHAR            1F9E
MANYCHARERROR       1DAA
MAS                 1A44
MBCC                16DE
MBEQ                170E
MBGE                16FE
MBLT                16EE
MBRA                16CE
MEFFECT             12C4
MEMAS               1A16
MEMDIRECTIONSUBROUTINE  1A52
MEMLS               1A1E
MEMSHIFT            19E0
MEMSHIFT2           19FE
MEMTOLIST           149A
MJSR                166C
ML                  1A7E
MLEA                1610
MLS                 1A36
MMULS               18A8
MNOT                1640
MORECHECKS          10C8
MORECHECKS1         10D4
MORECHECKS2         10F6
MOVEM               13F6
MOVEMADD            100E
MR                  1A70
MSOURCEDEST         134C
MSUBI               128C
MULSCHECK           1892
NUMBER              10AC
ODD                 1F71
ODDERROR            1D9A
OTHERMODES          1CC0
PBYTE               1BDE
PD                  1CA0
PI                  1C80
PLONG               1BFA
PRINTA              1F19
PRINTADD            1E8B
PRINTADDI           1E8F
PRINTAND            1EB2
PRINTANDI           1EB6
PRINTARD            1F10
PRINTARI            1F12
PRINTARI2           1F15
PRINTASL            1EC7
PRINTASR            1ECB
PRINTBCC            1EDE
PRINTBEQ            1ED9
PRINTBGE            1ED4
PRINTBLT            1ECF
PRINTBRA            1EEC
PRINTCOMMA          1F27
PRINTDASH           1F2D
PRINTDIVU           1EA5
PRINTDRD            1F0E
PRINTIA             1F17
PRINTJSR            1EE3
PRINTL              1EF7
PRINTLEA            1EAD
PRINTLSL            1EBF
PRINTLSR            1EC3
PRINTMAS            1EF1
PRINTMLS            1EF4
PRINTMNOP           1D3E
PRINTMOVE           1E80
PRINTMOVEM          1E85
PRINTMOVEMSIZE      1BCE
PRINTMOVESIZE       1BB6
PRINTMRTS           1D4E
PRINTMULS           1E9D
PRINTNOP            1E7C
PRINTNOT            1EBB
PRINTPD             1F21
PRINTPD2            1F25
PRINTPI             1F1B
PRINTPI2            1F1E
PRINTR              1EF9
PRINTRTS            1EE8
PRINTSINGLE         1584
PRINTSIZEB          1EFB
PRINTSIZEL          1F06
PRINTSIZESUBROUTINE  1B96
PRINTSIZEW          1F00
PRINTSLASH          1F2B
PRINTSPACE          1F29
PRINTSUB            1E94
PRINTSUBI           1E98
PSLASH              1602
PWORD               1BEC
REGAS               1A26
REGDIRECTIONSUBROUTINE  1A8E
REGLS               1A2E
REGSHIFT            1944
REGSHIFT2           197C
RL                  1ABC
RR                  1AAC
SETA                154C
SETD                1542
SHIFTEIGHT          19D8
SINGLEAREG          15CE
SINGLEDREG          159C
SIZEERROR           201E
SKIPA6              11F2
SKIPBIT             1578
SKIPCOPY            1CC8
SKIPSLASHA          15DC
SKIPSLASHD          15AA
STAHEX              1000
STARTINGPROMPT      1020
SUB16BITS           1798
SUB32BITS           17DA
SUB8BITS            1756
THEEND              1F2F
TOTALCOUNT          1009
UPDATE              11EA
USEREA              1E30
USERSA              1DEE
WELCOME             1DCA
