00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/28/2021 3:31:42 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 0000185C             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29                     
00001014                            30              ;===TESTING===
00001014  4EB9 0000101A             31              JSR      testing
0000101A                            32              
0000101A                            33  ;===TESTING================            
0000101A                            34  testing:
0000101A                            35  
0000101A                            36  ;Fix the ADDI and SUBI Issue!
0000101A                            37  ;See what you can do with MOVEM
0000101A                            38  ;Implement the rest of the opcodes when the other members have them
0000101A  0602 000C                 39              ADD.B       #12,D2
0000101E  0644 04D2                 40              ADD.W       #1234,D4
00001022  0685 00BC614E             41              ADD.L       #12345678,D5
00001028                            42              
00001028                            43  ;==========================            
00001028                            44              
00001028                            45  startingPrompt:
00001028                            46              ;Ask the user for the starting hex3
00001028  43F9 00001880             47              LEA         userSA,A1
0000102E  103C 000E                 48              MOVE.B      #14,D0
00001032  4E4F                      49              TRAP        #15        
00001034                            50              
00001034                            51              ;Clear the registers in case we had an error
00001034  227C 00000000             52              MOVE.L      #0,A1
0000103A  247C 00000000             53              MOVE.L      #0,A2
00001040  4283                      54              CLR.L       D3
00001042  4284                      55              CLR.L       D4
00001044  4285                      56              CLR.L       D5
00001046  4286                      57              CLR.L       D6
00001048                            58             
00001048                            59              
00001048                            60              ;Input for the hex (D1 equals number of chars)
00001048  303C 0002                 61              MOVE.W      #2,D0
0000104C  4E4F                      62              TRAP        #15
0000104E                            63              
0000104E                            64              ;Moves A1 into A2      
0000104E                            65              ;MOVEA.L     A1,A2
0000104E                            66              
0000104E                            67              ;Makes sure D7 is clear incase we're looping back after an error.
0000104E  4207                      68              CLR.B       D7
00001050                            69              
00001050  6000 002A                 70              BRA         convert  
00001054                            71              
00001054                            72  endingPrompt:
00001054                            73              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001054  1E3C 0001                 74              MOVE.B       #1,D7
00001058                            75              
00001058                            76              ;Ask the user for the ending hex
00001058  43F9 000018C2             77              LEA         userEA,A1
0000105E  103C 000E                 78              MOVE.B      #14,D0
00001062  4E4F                      79              TRAP        #15
00001064                            80              
00001064                            81              ;Clearing the registers so we can reuse them for the ending address
00001064  227C 00000000             82              MOVE.L      #0,A1
0000106A  247C 00000000             83              MOVE.L      #0,A2
00001070  4286                      84              CLR.L       D6
00001072                            85  
00001072                            86              ;Input for the hex (D1 equals number of chars)
00001072  303C 0002                 87              MOVE.W      #2,D0
00001076  4E4F                      88              TRAP        #15
00001078                            89              
00001078                            90              ;Moves A1 into A2      
00001078                            91              ;MOVEA.L     A1,A2
00001078                            92              
00001078  6000 0002                 93              BRA         convert
0000107C                            94  
0000107C                            95  convert:    
0000107C                            96              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
0000107C  B23C 0006                 97              CMP.B       #6, D1
00001080  6E00 07BA                 98              BGT         manyCharError  
00001084                            99              
00001084                           100              ;See if our counter variable is 0
00001084  B23C 0000                101              CMP.B       #0,D1
00001088                           102              
00001088                           103              ;This means that we have gone through all the characters
00001088  6700 0046                104              BEQ         moreChecks
0000108C                           105              
0000108C                           106              ;Decrement the counter, this means we're about to go through another char
0000108C  5301                     107              SUB.B       #1,D1
0000108E                           108  
0000108E                           109              ;Let's move the byte stored at A1
0000108E  1612                     110              MOVE.B      (A2),D3
00001090                           111              
00001090                           112              ;If the byte is greater than or equal to hex $40, then it's a letter
00001090  B63C 0041                113              CMP.B       #$41,D3
00001094  6C00 000A                114              BGE         letter
00001098                           115              
00001098                           116              ;If the byte is less than or equal to hex $39, then it's a number
00001098  B63C 0040                117              CMP.B       #$40,D3
0000109C  6F00 0016                118              BLE         number
000010A0                           119              
000010A0                           120  letter:
000010A0                           121              ;We do this check to see if the character is greater than or equal 'G'
000010A0  B63C 0047                122              CMP.B       #$47,D3
000010A4                           123              ;If so, then display an error and ask the user to enter startingAdd again
000010A4  6C00 0776                124              BGE         charError
000010A8                           125              
000010A8                           126              ;Subtract the Ascii value to convert to hex
000010A8  0403 0037                127              SUB.B       #$37,D3
000010AC                           128              ;Move the value back to our register
000010AC  14C3                     129              MOVE.B      D3,(A2)+
000010AE                           130              
000010AE                           131              ;Shift D5 left to make room for next hex value
000010AE  E986                     132              ASL.L       #4, D6
000010B0                           133              ;Move value to D5
000010B0  DC03                     134              ADD.B      D3, D6
000010B2                           135              
000010B2  60C8                     136              BRA         convert
000010B4                           137             
000010B4                           138  
000010B4                           139  number:          
000010B4                           140             ;We do this check to see if the character is less than or equal to '/'  
000010B4  B63C 002F                141             CMP.B        #$2F,D3
000010B8                           142             ;If so, then display an error and ask the user to enter startingAdd again
000010B8  6F00 0762                143             BLE          charError     
000010BC                           144   
000010BC                           145             ;Check to see if the character is greater than or equal to ':'
000010BC  B63C 003A                146             CMP.B        #$3A,D3
000010C0                           147             ;If so, then display an error and ask the user to enter startingAdd again
000010C0  6C00 075A                148             BGE          charError
000010C4                           149            
000010C4                           150             ;Subtract the Ascii value to convert to hex
000010C4  0403 0030                151             SUB.B        #$30,D3
000010C8                           152             ;Move the value back to our register
000010C8  14C3                     153             MOVE.B       D3,(A2)+
000010CA                           154   
000010CA                           155             ;Shift D5 left to make room for next hex value
000010CA  E986                     156             ASL.L        #4, D6
000010CC                           157             ;Move value to D5
000010CC  DC03                     158             ADD.B        D3, D6
000010CE                           159              
000010CE  60AC                     160             BRA          convert
000010D0                           161   
000010D0                           162            
000010D0                           163  moreChecks:
000010D0                           164              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010D0  BE3C 0001                165              CMP.B      #1,D7
000010D4  6700 0028                166              BEQ        moreChecks2
000010D8                           167              
000010D8  6000 0002                168              BRA        moreChecks1
000010DC                           169   
000010DC                           170  moreChecks1:
000010DC                           171              
000010DC                           172              ;Copy the hex value into a temp register
000010DC  2806                     173              MOVE.L      D6,D4
000010DE                           174              
000010DE                           175              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010DE  1A3C 001F                176              MOVE.B      #31,D5
000010E2                           177              
000010E2                           178              ;Shifts 31 bits, isolates last bit. 
000010E2  EBAC                     179              LSL.L       D5,D4
000010E4                           180  
000010E4                           181              ;Shifts it back 31 bit, isolating the last bit. 
000010E4  EAAC                     182              LSR.L       D5,D4
000010E6                           183  
000010E6                           184              ;If the last bit is 1, address was odd, and throw an error. 
000010E6  B83C 0001                185              CMP.B       #1,D4
000010EA  6700 0740                186              BEQ         oddError   
000010EE                           187                          
000010EE                           188              ;Reset address registers.
000010EE  247C 00000000            189              MOVE.L      #0,A2
000010F4                           190              
000010F4                           191              ;Copy the value to our staHex variable
000010F4  21C6 1000                192              MOVE.L      D6,staHex 
000010F8                           193              
000010F8  4286                     194              CLR.L       D6
000010FA  6000 FF58                195              BRA         endingPrompt     
000010FE                           196              
000010FE                           197  moreChecks2:       
000010FE                           198              
000010FE                           199              ;Copy the hex value into a temp register
000010FE  2806                     200              MOVE.L      D6,D4
00001100                           201              
00001100                           202              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001100  1A3C 001F                203              MOVE.B      #31,D5
00001104                           204              
00001104                           205              ;Shifts 31 bits, isolates last bit. 
00001104  EBAC                     206              LSL.L       D5,D4
00001106                           207  
00001106                           208              ;Shifts it back 31 bit, isolating the last bit. 
00001106  EAAC                     209              LSR.L       D5,D4
00001108                           210  
00001108                           211              ;If the last bit is 1, address was odd, and throw an error. 
00001108  B83C 0001                212              CMP.B       #1,D4
0000110C  6700 071E                213              BEQ         oddError   
00001110                           214                          
00001110                           215              ;Reset address registers.
00001110  247C 00000000            216              MOVE.L      #0,A2
00001116                           217              
00001116                           218              ;Place the value in our ending hex variable
00001116  21C6 1004                219              MOVE.L      D6,endHex 
0000111A                           220              
0000111A                           221              ;Make D7 a temp location to compare our starting hex
0000111A  2E38 1000                222              MOVE.L      staHex,D7
0000111E                           223           
0000111E                           224              
0000111E                           225              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
0000111E  BC87                     226              CMP.L       D7,D6
00001120  6B00 072A                227              BMI         endGreater
00001124                           228              
00001124                           229              ;done, start reading memory. 
00001124                           230              
00001124                           231              ;Clear all the registers since we have the addresses stored in our variables
00001124  4283                     232              CLR.L       D3
00001126  4285                     233              CLR.L       D5
00001128  4286                     234              CLR.L       D6
0000112A  4287                     235              CLR.L       D7  
0000112C                           236              
0000112C                           237              ;Copy the value of our starting hex to A2 (temp register)
0000112C  2478 1000                238              MOVEA.L     staHex,A2
00001130                           239                          
00001130                           240              
00001130                           241  LOOP:   
00001130                           242              ;--------------------------------------------------------
00001130                           243              ;Check for NOP or RTS
00001130                           244              ;--------------------------------------------------------
00001130                           245              
00001130                           246              ;Move the NOP binary value for comparing
00001130  243C 00004E71            247              MOVE.L      #%0100111001110001,D2
00001136                           248              
00001136                           249              ;Check and see i the instruction is NOP
00001136  B452                     250              CMP.W       (A2),D2
00001138  6700 06C2                251              BEQ         printMNOP
0000113C                           252              
0000113C                           253              ;Move the RTS binary value for comparing
0000113C  243C 00004E75            254              MOVE.L      #%0100111001110101,D2
00001142                           255              
00001142                           256              ;Check and see if the instruction is RTS
00001142  B452                     257              CMP.W       (A2),D2
00001144  6700 06C6                258              BEQ         printMRTS
00001148                           259              
00001148                           260              ;Clear the contents for reusing
00001148  4282                     261              CLR.L       D2
0000114A                           262              
0000114A                           263              
0000114A                           264              ;--------------------------------------------------------
0000114A                           265              ;Check for MOVE, since it's the only word starting with 00
0000114A                           266              ;--------------------------------------------------------            
0000114A                           267              ;Move the value in A2 to a temp register
0000114A  1412                     268              MOVE.B      (A2),D2
0000114C                           269              
0000114C                           270              ;Shift 6 bits to the right to isolate the left-most digits
0000114C  EC8A                     271              LSR.L       #6,D2
0000114E                           272              
0000114E                           273              ;If the first two bits (left-most) are 00, then the instruction is MOVE
0000114E  B43C 0000                274              CMP.B       #00,D2
00001152  6F00 0070                275              BLE         M00
00001156                           276              
00001156                           277              ;Reuse the register
00001156  4282                     278              CLR.L       D2
00001158                           279              
00001158                           280              
00001158                           281              ;--------------------------------------------------------
00001158                           282              ;Check for other OpCodes
00001158                           283              ;--------------------------------------------------------
00001158                           284              ;Move the word into a temp register 
00001158  3412                     285              MOVE.W      (A2),D2
0000115A                           286              
0000115A                           287              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
0000115A  163C 000C                288              MOVE.B        #12,D3            ;Start bit index = 12
0000115E  183C 0004                289              MOVE.B        #4,D4             ;Number of bits needed = 4
00001162                           290              
00001162                           291              ;Jumps to getBits and returns with isolated bits in D2
00001162  6100 004A                292              BSR           getBits            
00001166                           293  
00001166                           294              
00001166                           295              ;MOVEM,LEA,NOT,JSR
00001166  B43C 0004                296              CMP.B       #%0100,D2
0000116A  6700 00D0                297              BEQ         M0100
0000116E                           298              
0000116E                           299              ;BRA,BLT,BGE,BEQ
0000116E  B43C 0006                300              CMP.B       #%0110,D2
00001172  6700 01AA                301              BEQ         M0110
00001176                           302              
00001176                           303              ;DIVU
00001176  B43C 0008                304              CMP.B       #%1000,D2
0000117A  6700 01A2                305              BEQ         M1000
0000117E                           306              
0000117E                           307              ;SUB
0000117E  B43C 0009                308              CMP.B       #%1001,D2
00001182  6700 01C6                309              BEQ         M1001
00001186                           310              
00001186                           311              ;MULS,AND
00001186  B43C 000C                312              CMP.B       #%1100,D2
0000118A  6700 01FE                313              BEQ         M1100
0000118E                           314              
0000118E                           315              ;LSL,LSR,ASL,ASR
0000118E  B43C 000E                316              CMP.B       #%1110,D2
00001192  6700 026A                317              BEQ         M1110
00001196                           318              
00001196                           319              ;ADD
00001196  B43C 000D                320              CMP.B       #%1101,D2
0000119A  6700 041E                321              BEQ         M1101
0000119E                           322              
0000119E  6000 0934                323              BRA         ending
000011A2                           324              
000011A2                           325              
000011A2                           326              
000011A2                           327              ;display INVALID OPCODE, and display the raw hex
000011A2                           328              ;do this later
000011A2                           329  
000011A2                           330             
000011A2                           331  update:
000011A2                           332              ;Check and see if we are at the ending hex
000011A2  B5F8 1004                333              CMP.L      endHex,A2
000011A6  6E00 092C                334              BGT        ending
000011AA                           335  
000011AA                           336              ;Update address in A2
000011AA  544A                     337              ADDA.W      #2,A2
000011AC                           338              
000011AC                           339              
000011AC  6082                     340              BRA        LOOP
000011AE                           341              
000011AE                           342              
000011AE                           343  getBits:
000011AE                           344              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
000011AE                           345              ;PARAMETERS:
000011AE                           346              ;D2 = the value the bits are extracted from & saved back in
000011AE                           347              ;D3 = the start bit index (starting from 0)
000011AE                           348              ;D4 = the number of bits we want to extract
000011AE                           349              
000011AE                           350              ;Calculate left shift
000011AE  3A3C 0010                351              MOVE.W      #16,D5
000011B2                           352              
000011B2  D843                     353              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
000011B4  9A44                     354              SUB.W       D4,D5             ; 16 - X = leftShift
000011B6                           355              
000011B6  EB6A                     356              LSL.W       D5,D2
000011B8                           357              
000011B8                           358              
000011B8                           359              ;Calculate right shift
000011B8  DA43                     360              ADD.W       D3,D5             ; start bit + leftShift = X
000011BA  EA6A                     361              LSR.W       D5,D2
000011BC                           362              
000011BC  4283                     363              CLR.L       D3
000011BE  4284                     364              CLR.L       D4
000011C0  4285                     365              CLR.L       D5   
000011C2  4E75                     366              RTS
000011C4                           367  
000011C4                           368  *-----------------------------------------------------------
000011C4                           369  * 
000011C4                           370  *
000011C4                           371  *
000011C4                           372  * OpCode Implementation
000011C4                           373  *
000011C4                           374  *
000011C4                           375  *
000011C4                           376  *-----------------------------------------------------------
000011C4                           377  
000011C4                           378  
000011C4                           379  *-----------------------------------------------------------
000011C4                           380  * MOVE INSTRUCTION
000011C4                           381  *-----------------------------------------------------------
000011C4                           382  M00:
000011C4  43F9 00001908            383              LEA        printMOVE,A1
000011CA  103C 000E                384              MOVE.B     #14,D0
000011CE  4E4F                     385              TRAP       #15
000011D0                           386              
000011D0  4202                     387              CLR.B      D2
000011D2  4203                     388              CLR.B      D3
000011D4                           389              
000011D4                           390              ;======Isolate Size (S) Bits=======
000011D4                           391              ;Copy the address values into a register
000011D4  3412                     392              MOVE.W     (A2),D2
000011D6                           393              
000011D6                           394              ;Passing in parameters for isolating size bits 12,13
000011D6  163C 000C                395              MOVE.B      #12,D3             
000011DA  183C 0002                396              MOVE.B      #2,D4             
000011DE                           397              
000011DE                           398              ;Jumps to getBits and returns with isolated bits in D2
000011DE  61CE                     399              BSR         getBits  
000011E0                           400              
000011E0                           401              ;Indicate to our print function we are doing this for the MOVE opcode
000011E0  163C 0001                402              MOVE.B      #1,D3
000011E4                           403              
000011E4                           404              ;Jumps to printSizeSubroutine and returns after size has been printed
000011E4  6100 049A                405              BSR         printSizeSubroutine
000011E8                           406              
000011E8                           407              ;Let's store the size indicator since it will help us determine how many times
000011E8                           408              ;we have to iterate through addresses to print out the whole instruction
000011E8                           409              ;We will use A4 as the register to temporary store the size
000011E8  3842                     410              MOVE.W      D2,A4
000011EA                           411              
000011EA                           412              ;Clear the register so we can reuse it
000011EA  4282                     413              CLR.L       D2
000011EC                           414              
000011EC  1412                     415              MOVE.B      (A2),D2
000011EE                           416              
000011EE                           417              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
000011EE                           418              ;This is meant so we can use the copy to figure out the destination addressing mode
000011EE  264A                     419              MOVE.L      A2,A3
000011F0                           420  
000011F0  6100 0006                421              BSR         mSourceDest
000011F4                           422              
000011F4  4283                     423              CLR.L       D3
000011F6                           424              
000011F6  60AA                     425              BRA         update
000011F8                           426            
000011F8                           427  ;======Helper function to find the destination for MOVE======
000011F8                           428  mSourceDest:
000011F8                           429              ;SOURCE
000011F8                           430              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
000011F8  6100 0448                431              BSR        isolateAddressBit0to5
000011FC                           432              
000011FC                           433              ;Print source address
000011FC  6100 04E4                434              BSR        addressModeSR
00001200                           435              
00001200                           436              ;Print the comma after the source address
00001200  43F9 000019C1            437              LEA        printComma,A1
00001206  103C 000E                438              MOVE.B     #14,D0
0000120A  4E4F                     439              TRAP       #15
0000120C                           440              
0000120C                           441              ;DESTINATION
0000120C                           442              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000120C  6100 0008                443              BSR        isolateAddressBit6to11
00001210                           444              
00001210                           445              ;Print destination address
00001210  6100 04D0                446              BSR        addressModeSR
00001214                           447              
00001214  4E75                     448              RTS
00001216                           449  
00001216                           450  isolateAddressBit6to11:
00001216                           451              ;===Isolate the Destination Mode (M)Bits===
00001216  4282                     452              CLR.L      D2
00001218                           453              
00001218                           454              ;Copy the address value into a register
00001218  3413                     455              MOVE.W     (A3),D2
0000121A                           456              
0000121A                           457              ;Passing in parameters for isolating Mode bits
0000121A  163C 0006                458              MOVE.B     #6,D3
0000121E  183C 0003                459              MOVE.B     #3,D4
00001222                           460              
00001222                           461              ;Jumps to getBits and returns with isolated bits in D2
00001222  4EB8 11AE                462              JSR        getBits
00001226                           463              
00001226                           464              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001226  1C02                     465              MOVE.B     D2,D6
00001228                           466              
00001228                           467              ;===Isolate the Destination Address Register (Xn)Bits===
00001228  4282                     468              CLR.L      D2
0000122A                           469              
0000122A                           470              ;Copy the address values into a register
0000122A  3413                     471              MOVE.W     (A3),D2
0000122C                           472              
0000122C                           473              ;Passing in parameters for isolating Xn bits
0000122C  163C 0009                474              MOVE.B     #9,D3
00001230  183C 0003                475              MOVE.B     #3,D4
00001234                           476              
00001234                           477              ;Jumps to getBits and returns with isolated bits in D2
00001234  4EB8 11AE                478              JSR        getBits
00001238                           479              
00001238                           480              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001238  1E02                     481              MOVE.B      D2,D7
0000123A                           482  
0000123A  4E75                     483              RTS
0000123C                           484              
0000123C                           485              
0000123C                           486  *-----------------------------------------------------------
0000123C                           487  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
0000123C                           488  *-----------------------------------------------------------
0000123C                           489  M0100:      
0000123C  4282                     490              CLR.L       D2
0000123E  4283                     491              CLR.L       D3
00001240                           492              
00001240                           493              ;--------------------------------------------------------
00001240                           494              ;Check for LEA
00001240                           495              ;--------------------------------------------------------
00001240                           496              ;Copy the address values into a register to check for LEA
00001240  3412                     497              MOVE.W     (A2),D2
00001242                           498              
00001242                           499              ;Passing in parameters for isolating bits 6,7,8
00001242  163C 0006                500              MOVE.B      #6,D3             ;Start bit index = 6
00001246  183C 0003                501              MOVE.B      #3,D4             ;Number of bits needed = 3
0000124A                           502              
0000124A                           503              ;Jumps to getBits and returns with isolated bits in D2
0000124A  6100 FF62                504              BSR         getBits
0000124E                           505  
0000124E  B43C 0007                506              CMP.B       #%111,D2
00001252  6700 0056                507              BEQ         MLEA
00001256                           508  
00001256                           509              ;--------------------------------------------------------
00001256                           510              ;Check for NOT
00001256                           511              ;--------------------------------------------------------
00001256                           512              ;Clear D2 and recopy it to check for NOT
00001256  4282                     513              CLR.L       D2
00001258  3412                     514              MOVE.W      (A2),D2
0000125A                           515              
0000125A                           516              ;Pass in parameters for isolating bits 8,9,10,11
0000125A  163C 0008                517              MOVE.B      #8,D3
0000125E  183C 0004                518              MOVE.B      #4,D4
00001262                           519              
00001262                           520              ;Jumps to getBits and returns with isolated bits in D2
00001262  6100 FF4A                521              BSR         getBits
00001266                           522              
00001266  B43C 0006                523              CMP.B       #%0110,D2
0000126A  6700 006E                524              BEQ         MNOT      
0000126E                           525              
0000126E                           526              ;--------------------------------------------------------
0000126E                           527              ;Check for JSR
0000126E                           528              ;--------------------------------------------------------
0000126E                           529              ;Clear D2 and recopy it to check for JSR
0000126E  4282                     530              CLR.L       D2
00001270  3412                     531              MOVE.W     (A2),D2
00001272                           532              
00001272                           533              ;Pass in parameters for isolating bits 6-11
00001272  163C 0006                534              MOVE.B      #6,D3
00001276  183C 0006                535              MOVE.B      #6,D4
0000127A                           536              
0000127A                           537              ;Jumps to getBits and returns with isolated bits in D2
0000127A  6100 FF32                538              BSR         getBits
0000127E                           539              
0000127E  B43C 003A                540              CMP.B       #%111010,D2
00001282  6700 0082                541              BEQ         MJSR
00001286                           542              
00001286                           543              ;--------------------------------------------------------
00001286                           544              ;Check for MOVEM
00001286                           545              ;--------------------------------------------------------
00001286                           546              ;Clear D2 and recopy it to check for MOVEM
00001286  4282                     547              CLR.L       D2
00001288  3412                     548              MOVE.W     (A2),D2
0000128A                           549              
0000128A                           550              ;Pass in parameters for isolating bit 9
0000128A  163C 0009                551              MOVE.B      #9,D3
0000128E  183C 0001                552              MOVE.B      #1,D4
00001292                           553              
00001292                           554              ;Jumps to getBits and returns with isolated bits in D2
00001292  6100 FF1A                555              BSR         getBits
00001296                           556              
00001296  B43C 0000                557              CMP.B       #%0,D2
0000129A  6700 0002                558              BEQ         MOVEM
0000129E                           559              
0000129E                           560         
0000129E                           561  MOVEM:
0000129E                           562              *******************
0000129E                           563              *Must finish!!!!!!
0000129E                           564              *******************
0000129E  43F9 0000190F            565              LEA         printMOVEM,A1
000012A4  1038 0014                566              MOVE.B      $14,D0
000012A8  4E4F                     567              TRAP        #15
000012AA                           568  
000012AA                           569  
000012AA                           570  MLEA:
000012AA  43F9 00001937            571              LEA         printLEA,A1
000012B0  103C 000E                572              MOVE.B      #14,D0
000012B4  4E4F                     573              TRAP        #15
000012B6                           574              
000012B6                           575              ;*SOURCE*
000012B6                           576              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000012B6                           577              ;D6 will contain mode & D7 will contain the register after this instruction
000012B6  6100 038A                578              BSR         isolateAddressBit0to5
000012BA                           579              
000012BA                           580              ;*Print source address*
000012BA  6100 0426                581              BSR         addressModeSR
000012BE                           582              
000012BE                           583              ;Print comma after source address
000012BE  43F9 000019C1            584              LEA         printComma,A1
000012C4  103C 000E                585              MOVE.B      #14,D0
000012C8  4E4F                     586              TRAP        #15
000012CA                           587              
000012CA                           588              ;*DESTINATION*
000012CA                           589              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000012CA                           590              ;D7 will contain the register after this instruction
000012CA  6100 039C                591              BSR         isolateRegisterBit9to11
000012CE                           592              
000012CE                           593              ;Save #%001 into D6 to specify address register mode
000012CE  1C3C 0001                594              MOVE.B      #1,D6
000012D2                           595              
000012D2                           596              
000012D2                           597              ;*Print destination address*
000012D2  6100 040E                598              BSR         addressModeSR
000012D6                           599  
000012D6  6000 FECA                600              BRA        update
000012DA                           601  
000012DA                           602  MNOT:
000012DA  43F9 00001944            603              LEA        printNOT,A1
000012E0  103C 000E                604              MOVE.B     #14,D0
000012E4  4E4F                     605              TRAP       #15
000012E6                           606              
000012E6  4282                     607              CLR.L      D2
000012E8                           608              ;Move the address into the register to check for size
000012E8  3412                     609              MOVE.W     (A2),D2
000012EA                           610              
000012EA                           611              ;Pass in parameters for isolating bits 6,7
000012EA  163C 0006                612              MOVE.B     #6,D3
000012EE  183C 0002                613              MOVE.B     #2,D4
000012F2                           614              
000012F2                           615              ;Jump to getbits and return with isolated bits
000012F2  6100 FEBA                616              BSR        getbits          
000012F6                           617              
000012F6                           618              ;Jumps to printSizeSubroutine and returns after size has been printed
000012F6  6100 0388                619              BSR        printSizeSubroutine
000012FA                           620              
000012FA                           621              ;*SOURCE*
000012FA                           622              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000012FA                           623              ;D6 will contain mode & D7 will contain the register after this instruction
000012FA  6100 0346                624              BSR        isolateAddressBit0to5
000012FE                           625              
000012FE                           626              ;*Print source address*
000012FE  6100 03E2                627              BSR        addressModeSR
00001302                           628              
00001302  6000 FE9E                629              BRA        update 
00001306                           630  
00001306                           631  MJSR:
00001306  43F9 00001974            632              LEA        printJSR,A1
0000130C  103C 000E                633              MOVE.B     #14,D0
00001310  4E4F                     634              TRAP       #15
00001312                           635              
00001312                           636              ;*SOURCE*
00001312                           637              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001312                           638              ;D6 will contain mode & D7 will contain the register after this instruction
00001312  6100 032E                639              BSR        isolateAddressBit0to5
00001316                           640              
00001316                           641              ;*Print source address*
00001316  6100 03CA                642              BSR        addressModeSR
0000131A                           643              
0000131A  6000 FE86                644              BRA        update 
0000131E                           645              
0000131E                           646  
0000131E                           647  *-----------------------------------------------------------
0000131E                           648  * BRA,BLT,BGE,BEQ INSTRUCTIONS
0000131E                           649  *-----------------------------------------------------------       
0000131E                           650  M0110:
0000131E                           651              ;
0000131E                           652  MBRA:
0000131E                           653  MBLT:
0000131E                           654  MBGE:
0000131E                           655  MBEQ:            
0000131E                           656              
0000131E                           657  
0000131E                           658  *-----------------------------------------------------------
0000131E                           659  * DIVU INSTRUCTION
0000131E                           660  *-----------------------------------------------------------           
0000131E                           661  M1000:
0000131E                           662              
0000131E  4282                     663              CLR.L       D2
00001320  4283                     664              CLR.L       D3
00001322                           665              
00001322                           666              ;Copy the address values into a register
00001322  3412                     667              MOVE.W     (A2),D2
00001324                           668              
00001324                           669              ;Passing in parameters for isolating bits 6,7,8
00001324  163C 0006                670              MOVE.B      #6,D3             ;Start bit index = 6
00001328  183C 0003                671              MOVE.B      #3,D4             ;Number of bits needed = 3
0000132C                           672              
0000132C                           673              ;Jumps to getBits and returns with isolated bits in D2
0000132C  6100 FE80                674              BSR         getBits
00001330                           675              
00001330                           676              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
00001330  B4BC 00000003            677              CMP.L       #%011,D2
00001336  6700 0002                678              BEQ         continueDIVU
0000133A                           679              
0000133A                           680              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
0000133A                           681  
0000133A                           682  continueDIVU:
0000133A                           683  
0000133A  43F9 0000192D            684              LEA         printDIVU,A1
00001340  103C 000E                685              MOVE.B      #14,D0
00001344  4E4F                     686              TRAP        #15
00001346                           687              
00001346  6000 02B2                688              BRA         dnDest
0000134A                           689              
0000134A                           690              
0000134A                           691  *-----------------------------------------------------------
0000134A                           692  * SUB INSTRUCTION
0000134A                           693  *-----------------------------------------------------------  
0000134A                           694  M1001:
0000134A  43F9 0000191D            695              LEA        printSUB,A1
00001350  103C 000E                696              MOVE.B     #14,D0
00001354  4E4F                     697              TRAP       #15
00001356                           698              
00001356  4202                     699              CLR.B      D2
00001358  4203                     700              CLR.B      D3
0000135A                           701              
0000135A                           702              ;======Isolate Size (S) Bits=======
0000135A                           703              ;Copy the address values into a register
0000135A  3412                     704              MOVE.W     (A2),D2
0000135C                           705              
0000135C                           706              ;Passing in parameters for isolating size bits
0000135C  163C 0006                707              MOVE.B      #6,D3             ;Start bit index = 6
00001360  183C 0002                708              MOVE.B      #2,D4             ;Number of bits needed = 2
00001364                           709              
00001364                           710              ;Jumps to getBits and returns with isolated bits in D2
00001364  6100 FE48                711              BSR         getBits  
00001368                           712              
00001368                           713              ;Jumps to printSizeSubroutine and returns after size has been printed
00001368  6100 0316                714              BSR         printSizeSubroutine
0000136C                           715              
0000136C                           716              ;Let's store the size indicator since it will help us determine how many times
0000136C                           717              ;we have to iterate through addresses to print out the whole instruction
0000136C                           718              ;We will use A4 as the register to temporary store the size
0000136C  3842                     719              MOVE.W      D2,A4
0000136E                           720         
0000136E                           721              ;======Isolate direction (D) Bit=======
0000136E                           722              ; 0 = data register is destination | 1 = Dn is source
0000136E  4282                     723              CLR.L       D2
00001370                           724              
00001370                           725              ;Copy the address values into a register
00001370  3412                     726              MOVE.W      (A2),D2
00001372                           727              
00001372                           728              ;Passing in parameters for isolating direction bit
00001372  163C 0008                729              MOVE.B      #8,D3             ;Start bit index = 8
00001376  183C 0001                730              MOVE.B      #1,D4             ;Number of bits needed = 1
0000137A                           731              
0000137A                           732              ;Jumps to getBits and returns with isolated bit in D2
0000137A  6100 FE32                733              BSR         getBits
0000137E                           734              
0000137E                           735              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
0000137E  B43C 0000                736              CMP.B       #0,D2
00001382  6700 0276                737              BEQ         dnDest
00001386  6000 0296                738              BRA         dnSource
0000138A                           739  
0000138A                           740  
0000138A                           741  *-----------------------------------------------------------
0000138A                           742  * MULS,AND INSTRUCTIONS
0000138A                           743  *-----------------------------------------------------------  
0000138A                           744  M1100:      
0000138A  4282                     745              CLR.L       D2
0000138C  4283                     746              CLR.L       D3
0000138E                           747              
0000138E                           748              ;Copy the address values into a register
0000138E  3412                     749              MOVE.W     (A2),D2
00001390                           750              
00001390                           751              ;Passing in parameters for isolating bits 6 and 7
00001390  163C 0006                752              MOVE.B      #6,D3             ;Start bit index = 6
00001394  183C 0002                753              MOVE.B      #2,D4             ;Number of bits needed = 2
00001398                           754              
00001398                           755              ;Jumps to getBits and returns with isolated bits in D2
00001398  6100 FE14                756              BSR         getBits  
0000139C                           757              
0000139C                           758              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
0000139C  B43C 0003                759              CMP.B       #%11,D2
000013A0  6700 0006                760              BEQ         mulsCheck
000013A4  6000 0028                761              BRA         MAND
000013A8                           762              
000013A8                           763  mulsCheck:
000013A8                           764              ;Copy the address values into a register
000013A8  3412                     765              MOVE.W     (A2),D2
000013AA                           766              
000013AA                           767              ;Passing in parameters for isolating bit 8
000013AA  163C 0008                768              MOVE.B      #8,D3             ;Start bit index = 8
000013AE  183C 0001                769              MOVE.B      #1,D4             ;Number of bits needed = 1
000013B2                           770              
000013B2                           771              ;Jumps to getBits and returns with isolated bits in D2
000013B2  6100 FDFA                772              BSR         getBits 
000013B6                           773              
000013B6                           774              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
000013B6  B43C 0001                775              CMP.B       #1,D2
000013BA  6700 0002                776              BEQ         MMULS
000013BE                           777              
000013BE                           778              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
000013BE                           779  
000013BE                           780              
000013BE                           781              
000013BE                           782              
000013BE                           783  MMULS:
000013BE  43F9 00001923            784              LEA         printMULS,A1
000013C4  103C 000E                785              MOVE.B      #14,D0
000013C8  4E4F                     786              TRAP        #15
000013CA                           787              
000013CA  6000 022E                788              BRA         dnDest 
000013CE                           789  
000013CE                           790  
000013CE                           791  MAND:
000013CE  43F9 0000193E            792              LEA        printAND,A1
000013D4  103C 000E                793              MOVE.B     #14,D0
000013D8  4E4F                     794              TRAP       #15
000013DA                           795              
000013DA                           796              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
000013DA                           797              ;Jumps to printSizeSubroutine and returns after size has been printed
000013DA  6100 02A4                798              BSR         printSizeSubroutine
000013DE                           799              
000013DE                           800              ;======Isolate direction (D) Bit=======
000013DE                           801              ; 0 = data register is destination | 1 = Dn is source
000013DE  4282                     802              CLR.L       D2
000013E0                           803              
000013E0                           804              ;Copy the address values into a register
000013E0  3412                     805              MOVE.W      (A2),D2
000013E2                           806              
000013E2                           807              ;Passing in parameters for isolating direction bit
000013E2  163C 0008                808              MOVE.B      #8,D3           ;Start bit index = 8
000013E6  183C 0001                809              MOVE.B      #1,D4           ;Number of bits needed = 1
000013EA                           810  
000013EA                           811              ;Jumps to getBits and returns with isolated bit in D2
000013EA  6100 FDC2                812              BSR         getBits
000013EE                           813              
000013EE                           814              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000013EE  B43C 0000                815              CMP.B       #0,D2
000013F2  6700 0206                816              BEQ         dnDest
000013F6  6000 0226                817              BRA         dnSource
000013FA                           818              
000013FA                           819              
000013FA  6000 FDA6                820              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
000013FE                           821     
000013FE                           822     
000013FE                           823  *-----------------------------------------------------------
000013FE                           824  * LSL,LSR,ASL,ASR INSTRUCTIONS
000013FE                           825  *-----------------------------------------------------------  
000013FE                           826  M1110:
000013FE  4282                     827              CLR.L       D2
00001400  4283                     828              CLR.L       D3
00001402                           829              
00001402                           830              ;Copy the address values into a register
00001402  3412                     831              MOVE.W     (A2),D2
00001404                           832              
00001404                           833              ;Passing in parameters for isolating bits 6-7
00001404  163C 0006                834              MOVE.B      #6,D3             ;Start bit index = 6
00001408  183C 0002                835              MOVE.B      #2,D4             ;Number of bits needed = 2
0000140C                           836              
0000140C                           837              ;Jumps to getBits and returns with isolated bits in D2
0000140C  6100 FDA0                838              BSR         getBits  
00001410                           839              
00001410                           840              ;Check if Memory Shift
00001410  B43C 0003                841              CMP.B       #%11,D2
00001414  6700 00B8                842              BEQ         MemShift
00001418                           843              
00001418                           844              ;If not Memory Shift, is a Register Shift
00001418                           845              
00001418                           846              ;Copy the address values into a register
00001418  3412                     847              MOVE.W     (A2),D2
0000141A                           848              
0000141A                           849              ;Passing in parameters for isolating bit 3
0000141A  163C 0003                850              MOVE.B      #3,D3             ;Start bit index = 3
0000141E  183C 0001                851              MOVE.B      #1,D4             ;Number of bits needed = 1
00001422                           852              
00001422                           853              ;Jumps to getBits and returns with isolated bits in D2
00001422  6100 FD8A                854              BSR         getBits  
00001426                           855              
00001426                           856              ;Checks if ASd
00001426  B43C 0000                857              CMP.B       #%0,D2
0000142A  6700 00E8                858              BEQ         RegAS
0000142E                           859              
0000142E                           860              ;Checks if LSd
0000142E  B43C 0001                861              CMP.B       #%1,D2
00001432  6700 00E8                862              BEQ         RegLS
00001436                           863  RegShift      
00001436                           864              ;Copy the address values into a register
00001436  3412                     865              MOVE.W     (A2),D2
00001438                           866              
00001438                           867              ;Passing in parameters for isolating bits 6-7
00001438  163C 0006                868              MOVE.B      #6,D3             ;Start bit index = 6
0000143C  183C 0002                869              MOVE.B      #2,D4             ;Number of bits needed = 2
00001440                           870              
00001440                           871              ;Jumps to getBits and returns with isolated bits in D2
00001440  6100 FD6C                872              BSR         getBits  
00001444                           873              
00001444                           874              ;Print Size
00001444  6100 023A                875              BSR         printSizeSubroutine
00001448                           876              
00001448                           877              ;Copy the address values into a register
00001448  3412                     878              MOVE.W     (A2),D2
0000144A                           879              
0000144A                           880              ;Passing in parameters for isolating bit 5
0000144A  163C 0005                881              MOVE.B      #5,D3             ;Start bit index = 5
0000144E  183C 0001                882              MOVE.B      #1,D4             ;Number of bits needed = 1
00001452                           883              
00001452                           884              ;Jumps to getBits and returns with isolated bits in D2
00001452  6100 FD5A                885              BSR         getBits  
00001456                           886              
00001456                           887              ;Checks if shift count is immediate
00001456  B43C 0000                888              CMP.B       #%0,D2
0000145A  6700 003C                889              BEQ         ImmediateCount
0000145E                           890              
0000145E                           891              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000145E                           892              ;D7 will contain the register after this instruction
0000145E  6100 0208                893              BSR         isolateRegisterBit9to11
00001462                           894              
00001462                           895              ;Save #%000 into D6 to specify data register mode
00001462  1C3C 0000                896              MOVE.B      #0,D6
00001466                           897              
00001466                           898              ;*Print Shift Count address*
00001466  6100 027A                899              BSR         addressModeSR
0000146A                           900  
0000146A  6100 0002                901              BSR         RegShift2
0000146E                           902  
0000146E                           903  RegShift2   ;Print comma after shift count
0000146E  43F9 000019C1            904              LEA         printComma,A1
00001474  103C 000E                905              MOVE.B      #14,D0
00001478  4E4F                     906              TRAP        #15
0000147A                           907              
0000147A                           908              ;*Data Register to be Shifted*
0000147A  4282                     909              CLR.L       D2
0000147C                           910              
0000147C                           911              ;Copy the address values into a register
0000147C  3412                     912              MOVE.W      (A2),D2
0000147E                           913              
0000147E                           914              ;Passing in parameters for isolating bits 0-2
0000147E  163C 0000                915              MOVE.B      #0,D3             ;Start bit index = 0
00001482  183C 0003                916              MOVE.B      #3,D4             ;Number of bits needed = 3
00001486                           917              
00001486                           918              ;Jumps to getBits and returns with isolated bits in D2
00001486  6100 FD26                919              BSR         getBits
0000148A                           920              
0000148A                           921              ;Save Xn register bit into ***D7*** for later use in addressModeSR
0000148A  1E02                     922              MOVE.B      D2,D7
0000148C                           923              
0000148C                           924              ;Save #%000 into D6 to specify data register mode
0000148C  1C3C 0000                925              MOVE.B      #0,D6
00001490                           926              
00001490                           927              ;*Prints data register to be shifted*
00001490  6100 0250                928              BSR         addressModeSR
00001494                           929  
00001494  6000 FD0C                930              BRA         update
00001498                           931              
00001498                           932  ImmediateCount
00001498                           933              ;Print #$
00001498  43F9 000019B1            934              LEA        printIA,A1
0000149E  103C 000E                935              MOVE.B     #14,D0
000014A2  4E4F                     936              TRAP       #15
000014A4                           937              
000014A4                           938              ;Copy the address values into a register
000014A4  3412                     939              MOVE.W     (A2),D2
000014A6                           940              
000014A6                           941              ;Passing in parameters for isolating bits 9-11
000014A6  163C 0009                942              MOVE.B      #9,D3             ;Start bit index = 9
000014AA  183C 0003                943              MOVE.B      #3,D4             ;Number of bits needed = 3
000014AE                           944              
000014AE                           945              ;Jumps to getBits and returns with isolated bits in D2
000014AE  6100 FCFE                946              BSR         getBits  
000014B2                           947              
000014B2                           948              ;Check if shift count is 8
000014B2  B43C 0000                949              CMP.B       #%000,D2
000014B6  6700 0010                950              BEQ         ShiftEight
000014BA                           951              
000014BA  1202                     952              MOVE.B      D2, D1
000014BC  6100 0002                953              BSR         ImmediateCount2
000014C0                           954             
000014C0                           955  ImmediateCount2
000014C0                           956              ;Print shift count
000014C0  103C 0003                957              MOVE.B      #3,D0
000014C4  4E4F                     958              TRAP        #15
000014C6  61A6                     959              BSR         RegShift2
000014C8                           960   
000014C8                           961  ShiftEight  ;Move 8 into D1    
000014C8  123C 0008                962              MOVE.B      #8, D1
000014CC  61F2                     963              BSR         ImmediateCount2
000014CE                           964                                     
000014CE                           965  MemShift
000014CE                           966              ;Copy the address values into a register
000014CE  3412                     967              MOVE.W     (A2),D2
000014D0                           968              
000014D0                           969              ;Passing in parameters for isolating bit 9
000014D0  163C 0009                970              MOVE.B      #9,D3             ;Start bit index = 9
000014D4  183C 0001                971              MOVE.B      #1,D4             ;Number of bits needed = 1
000014D8                           972              
000014D8                           973              ;Jumps to getBits and returns with isolated bits in D2
000014D8  6100 FCD4                974              BSR         getBits  
000014DC                           975              
000014DC                           976              ;Checks if ASd
000014DC  B43C 0000                977              CMP.B       #%0,D2
000014E0  6700 0022                978              BEQ         MemAS
000014E4                           979              
000014E4                           980              ;Checks if LSd
000014E4  B43C 0001                981              CMP.B       #%1,D2
000014E8  6700 0022                982              BEQ         MemLS
000014EC                           983  
000014EC                           984  MemShift2   
000014EC                           985              ;Print Space
000014EC  43F9 000019C3            986              LEA        printSpace,A1
000014F2  103C 000E                987              MOVE.B     #14,D0
000014F6  4E4F                     988              TRAP       #15
000014F8                           989              
000014F8                           990              ;*Memory Address*
000014F8                           991              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000014F8                           992              ;D6 will contain mode & D7 will contain the register after this instruction
000014F8  6100 0148                993              BSR         isolateAddressBit0to5
000014FC                           994              
000014FC                           995              ;*Print source address*
000014FC  6100 01E4                996              BSR         addressModeSR
00001500                           997              
00001500  6000 FCA0                998              BRA         update
00001504                           999              
00001504                          1000  MemAS       ;Print AS
00001504  6100 002C               1001              BSR         MAS      
00001508  6100 0036               1002              BSR         MemDirectionSubroutine                
0000150C                          1003  
0000150C                          1004              
0000150C                          1005  MemLS       ;Print LS
0000150C  6100 0016               1006              BSR         MLS      
00001510  6100 002E               1007              BSR         MemDirectionSubroutine
00001514                          1008              
00001514                          1009  RegAS       ;Print AS
00001514  6100 001C               1010              BSR         MAS      
00001518  6100 0062               1011              BSR         RegDirectionSubroutine                
0000151C                          1012  
0000151C                          1013              
0000151C                          1014  RegLS       ;Print LS
0000151C  6100 0006               1015              BSR         MLS      
00001520  6100 005A               1016              BSR         RegDirectionSubroutine
00001524                          1017  
00001524                          1018  MLS:
00001524  43F9 0000198C           1019              LEA        printMLS,A1
0000152A  103C 000E               1020              MOVE.B     #14,D0
0000152E  4E4F                    1021              TRAP       #15
00001530  4E75                    1022              RTS
00001532                          1023  MAS:
00001532  43F9 00001987           1024              LEA        printMAS,A1
00001538  103C 000E               1025              MOVE.B     #14,D0
0000153C  4E4F                    1026              TRAP       #15
0000153E  4E75                    1027              RTS
00001540                          1028  
00001540                          1029  MemDirectionSubroutine
00001540                          1030              ;Copy the address values into a register
00001540  3412                    1031              MOVE.W     (A2),D2
00001542                          1032              
00001542                          1033              ;Passing in parameters for isolating bit 8
00001542  163C 0008               1034              MOVE.B      #8,D3             ;Start bit index = 8
00001546  183C 0001               1035              MOVE.B      #1,D4             ;Number of bits needed = 1
0000154A                          1036              
0000154A                          1037              ;Jumps to getBits and returns with isolated bits in D2
0000154A  6100 FC62               1038              BSR         getBits  
0000154E                          1039              
0000154E                          1040              ;Checks if Right
0000154E  B43C 0000               1041              CMP.B       #%0,D2
00001552  6700 000A               1042              BEQ         MR
00001556                          1043              
00001556                          1044              ;Checks if Left
00001556  B43C 0001               1045              CMP.B       #%1,D2
0000155A  6700 0010               1046              BEQ         ML
0000155E                          1047                          
0000155E  43F9 00001993           1048  MR          LEA        printR,A1
00001564  103C 000E               1049              MOVE.B     #14,D0
00001568  4E4F                    1050              TRAP       #15
0000156A  6180                    1051              BSR        MemShift2
0000156C                          1052  
0000156C  43F9 00001991           1053  ML          LEA        printL,A1
00001572  103C 000E               1054              MOVE.B     #14,D0
00001576  4E4F                    1055              TRAP       #15
00001578  6100 FF72               1056              BSR        MemShift2
0000157C                          1057              
0000157C                          1058  RegDirectionSubroutine
0000157C                          1059              ;Copy the address values into a register
0000157C  3412                    1060              MOVE.W     (A2),D2
0000157E                          1061              
0000157E                          1062              ;Passing in parameters for isolating bit 8
0000157E  163C 0008               1063              MOVE.B      #8,D3             ;Start bit index = 8
00001582  183C 0001               1064              MOVE.B      #1,D4             ;Number of bits needed = 1
00001586                          1065              
00001586                          1066              ;Jumps to getBits and returns with isolated bits in D2
00001586  6100 FC26               1067              BSR         getBits  
0000158A                          1068              
0000158A                          1069              ;Checks if Right
0000158A  B43C 0000               1070              CMP.B       #%0,D2
0000158E  6700 000A               1071              BEQ         RR
00001592                          1072              
00001592                          1073              ;Checks if Left
00001592  B43C 0001               1074              CMP.B       #%1,D2
00001596  6700 0012               1075              BEQ         RL
0000159A                          1076                          
0000159A  43F9 00001993           1077  RR          LEA        printR,A1
000015A0  103C 000E               1078              MOVE.B     #14,D0
000015A4  4E4F                    1079              TRAP       #15
000015A6  6100 FE8E               1080              BSR        RegShift
000015AA                          1081  
000015AA  43F9 00001991           1082  RL          LEA        printL,A1
000015B0  103C 000E               1083              MOVE.B     #14,D0
000015B4  4E4F                    1084              TRAP       #15
000015B6  6100 FE7E               1085              BSR        RegShift
000015BA                          1086  
000015BA                          1087  
000015BA                          1088  *-----------------------------------------------------------------------
000015BA                          1089  *-----------------------------------------------------------------------
000015BA                          1090  *-----------------------------------------------------------------------
000015BA                          1091  
000015BA                          1092  
000015BA                          1093  
000015BA                          1094  
000015BA                          1095  ;ADD
000015BA                          1096  M1101:
000015BA  43F9 00001917           1097              LEA        printADD,A1
000015C0  103C 000E               1098              MOVE.B     #14,D0
000015C4  4E4F                    1099              TRAP       #15
000015C6                          1100              
000015C6  4202                    1101              CLR.B      D2
000015C8  4203                    1102              CLR.B      D3
000015CA                          1103              
000015CA                          1104              ;======Isolate Size (S) Bits=======
000015CA                          1105              ;Copy the address values into a register
000015CA  3412                    1106              MOVE.W     (A2),D2
000015CC                          1107              
000015CC                          1108              ;Passing in parameters for isolating size bits
000015CC  163C 0006               1109              MOVE.B      #6,D3             ;Start bit index = 6
000015D0  183C 0002               1110              MOVE.B      #2,D4             ;Number of bits needed = 2
000015D4                          1111              
000015D4                          1112              ;Jumps to getBits and returns with isolated bits in D2
000015D4  6100 FBD8               1113              BSR         getBits  
000015D8                          1114              
000015D8                          1115              ;Jumps to printSizeSubroutine and returns after size has been printed
000015D8  6100 00A6               1116              BSR         printSizeSubroutine
000015DC                          1117         
000015DC                          1118              ;Let's store the size indicator since it will help us determine how many times
000015DC                          1119              ;we have to iterate through addresses to print out the whole instruction
000015DC                          1120              ;We will use A4 as the register to temporary store the size
000015DC  3842                    1121              MOVE.W      D2,A4
000015DE                          1122         
000015DE                          1123              ;======Isolate direction (D) Bit=======
000015DE                          1124              ; 0 = data register is destination | 1 = Dn is source
000015DE  4282                    1125              CLR.L       D2
000015E0                          1126              
000015E0                          1127              ;Copy the address values into a register
000015E0  3412                    1128              MOVE.W      (A2),D2
000015E2                          1129              
000015E2                          1130              ;Passing in parameters for isolating direction bit
000015E2  163C 0008               1131              MOVE.B      #8,D3             ;Start bit index = 8
000015E6  183C 0001               1132              MOVE.B      #1,D4             ;Number of bits needed = 1
000015EA                          1133              
000015EA                          1134              ;Jumps to getBits and returns with isolated bit in D2
000015EA  6100 FBC2               1135              BSR         getBits
000015EE                          1136              
000015EE                          1137              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000015EE  B43C 0000               1138              CMP.B       #0,D2
000015F2  6700 0006               1139              BEQ         dnDest
000015F6  6000 0026               1140              BRA         dnSource
000015FA                          1141              
000015FA                          1142  
000015FA                          1143  *-----------------------------------------------------------------
000015FA                          1144  * dnDest, dnSource, & other subroutines for isolating address bits
000015FA                          1145  *-----------------------------------------------------------------
000015FA                          1146  ;* dnDest,dnSource *
000015FA                          1147  ;For: MULS,AND,ADD,SUB,DIVU
000015FA                          1148  ;Used by instructions that require Dn as one of their addressing modes.
000015FA                          1149  ;dnDest isolates the addressing bits with Dn being the destination address
000015FA                          1150  ;dnSource isolates the addressing bits with Dn being the source address
000015FA                          1151  
000015FA                          1152  dnDest:
000015FA                          1153              ;**Used for isolating addressing bits when Dn is the destination**
000015FA                          1154              
000015FA                          1155              ;*SOURCE*
000015FA                          1156              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000015FA                          1157              ;D6 will contain mode & D7 will contain the register after this instruction
000015FA  6100 0046               1158              BSR         isolateAddressBit0to5
000015FE                          1159              
000015FE                          1160              ;*Print source address*
000015FE  6100 00E2               1161              BSR         addressModeSR
00001602                          1162              
00001602                          1163              ;Print comma after source address
00001602  43F9 000019C1           1164              LEA         printComma,A1
00001608  103C 000E               1165              MOVE.B      #14,D0
0000160C  4E4F                    1166              TRAP        #15
0000160E                          1167              
0000160E                          1168              ;*DESTINATION*
0000160E                          1169              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000160E                          1170              ;D7 will contain the register after this instruction
0000160E  6100 0058               1171              BSR         isolateRegisterBit9to11
00001612                          1172              
00001612                          1173              ;Save #%000 into D6 to specify data register mode
00001612  1C3C 0000               1174              MOVE.B      #0,D6
00001616                          1175              
00001616                          1176              ;*Print destination address*
00001616  6100 00CA               1177              BSR         addressModeSR
0000161A                          1178  
0000161A  6000 FB86               1179              BRA         update
0000161E                          1180              
0000161E                          1181  dnSource:
0000161E                          1182              ;**Used for isolating addressing bits when Dn is the destination**
0000161E                          1183                          
0000161E                          1184              ;*SOURCE*
0000161E                          1185              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000161E                          1186              ;D7 will contain the register after this instruction
0000161E  6100 0048               1187              BSR         isolateRegisterBit9to11
00001622                          1188              
00001622                          1189              ;Save #%000 into D6 to specify data register mode
00001622  1C3C 0000               1190              MOVE.B      #0,D6
00001626                          1191              
00001626                          1192              ;*Print Source address*
00001626  6100 00BA               1193              BSR         addressModeSR
0000162A                          1194              
0000162A                          1195              ;Print comma after source address
0000162A  43F9 000019C1           1196              LEA         printComma,A1
00001630  103C 000E               1197              MOVE.B      #14,D0
00001634  4E4F                    1198              TRAP        #15
00001636                          1199              
00001636                          1200              ;*DESTINATION*
00001636                          1201              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001636                          1202              ;D6 will contain mode & D7 will contain the register after this instruction
00001636  6100 000A               1203              BSR         isolateAddressBit0to5
0000163A                          1204              
0000163A                          1205              ;*Print destination address*
0000163A  6100 00A6               1206              BSR         addressModeSR
0000163E                          1207  
0000163E  6000 FB62               1208              BRA         update
00001642                          1209                     
00001642                          1210  isolateAddressBit0to5:
00001642                          1211  ;Helper subroutine for isolating the address stored within bits 0-5
00001642                          1212  ;Stores address mode in D6
00001642                          1213  ;Stores address register in D7
00001642                          1214  
00001642                          1215              ;======Isolate Effective Address Mode (M) Bits=======
00001642  4282                    1216              CLR.L       D2
00001644                          1217              
00001644                          1218              ;Copy the address values into a register
00001644  3412                    1219              MOVE.W      (A2),D2
00001646                          1220              
00001646                          1221              ;Passing in parameters for isolating Mode bits
00001646  163C 0003               1222              MOVE.B      #3,D3             ;Start bit index = 3
0000164A  183C 0003               1223              MOVE.B      #3,D4             ;Number of bits needed = 3
0000164E                          1224              
0000164E                          1225              ;Jumps to getBits and returns with isolated bits in D2
0000164E  4EB8 11AE               1226              JSR         getBits
00001652                          1227              
00001652                          1228              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001652  1C02                    1229              MOVE.B      D2,D6
00001654                          1230              
00001654                          1231                       
00001654                          1232              ;======Isolate Effective Address Register (Xn) Bits=======
00001654  4282                    1233              CLR.L       D2
00001656                          1234              
00001656                          1235              ;Copy the address values into a register
00001656  3412                    1236              MOVE.W      (A2),D2
00001658                          1237              
00001658                          1238              ;Passing in parameters for isolating Xn bits
00001658  163C 0000               1239              MOVE.B      #0,D3             ;Start bit index = 0
0000165C  183C 0003               1240              MOVE.B      #3,D4             ;Number of bits needed = 3
00001660                          1241              
00001660                          1242              ;Jumps to getBits and returns with isolated bits in D2
00001660  6100 FB4C               1243              BSR         getBits
00001664                          1244              
00001664                          1245              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001664  1E02                    1246              MOVE.B      D2,D7
00001666                          1247              
00001666  4E75                    1248              RTS
00001668                          1249  
00001668                          1250  isolateRegisterBit9to11:
00001668                          1251  ;Helper subroutine for isolating the register stored within bits 9-11
00001668                          1252  ;Stores the address register in D7
00001668                          1253  
00001668                          1254              ;======Isolate Register Bits=======
00001668  4282                    1255              CLR.L       D2
0000166A  4286                    1256              CLR.L       D6
0000166C  4287                    1257              CLR.L       D7
0000166E                          1258              
0000166E                          1259              ;Copy the address values into a register
0000166E  3412                    1260              MOVE.W      (A2),D2
00001670                          1261              
00001670                          1262              ;Passing in parameters for isolating register bits
00001670  163C 0009               1263              MOVE.B      #9,D3             ;Start bit index = 9
00001674  183C 0003               1264              MOVE.B      #3,D4             ;Number of bits needed = 3
00001678                          1265              
00001678                          1266              ;Jumps to getBits and returns with isolated bit in D2
00001678  6100 FB34               1267              BSR         getBits
0000167C                          1268              
0000167C                          1269              ;Save register bit into ***D7*** for later use in addressModeSR
0000167C  1E02                    1270              MOVE.B      D2,D7
0000167E                          1271  
0000167E  4E75                    1272              RTS
00001680                          1273              
00001680                          1274  *-----------------------------------------------------------
00001680                          1275  * Print Sizes
00001680                          1276  *-----------------------------------------------------------
00001680                          1277  printSizeSubroutine:
00001680                          1278              ;Prints the apporpriate size
00001680                          1279              ;PARAMETER:
00001680                          1280              ;D2 = the size bits
00001680                          1281              
00001680                          1282              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
00001680  B63C 0001               1283              CMP.B      #1,D3
00001684  6700 001A               1284              BEQ        printMOVESize
00001688                          1285              
00001688                          1286              ;Compare to which size is being moved for the opcode
00001688  B43C 0000               1287              CMP.B      #%00,D2
0000168C  6700 002A               1288              BEQ        PByte
00001690                          1289              
00001690  B43C 0001               1290              CMP.B      #%01,D2
00001694  6700 0030               1291              BEQ        PWord
00001698                          1292              
00001698  B43C 0002               1293              CMP.B      #%10,D2
0000169C  6700 0036               1294              BEQ        PLong
000016A0                          1295           
000016A0                          1296  printMOVESize:
000016A0                          1297              ;Now that we know we have a MOVE opcode
000016A0                          1298              ;Compare to which size is being moved for the opcode
000016A0  B43C 0001               1299              CMP.B      #%01,D2
000016A4  6700 0012               1300              BEQ        PByte
000016A8                          1301  
000016A8  B43C 0003               1302              CMP.B      #%11,D2
000016AC  6700 0018               1303              BEQ        PWord            
000016B0                          1304    
000016B0  B43C 0002               1305              CMP.B      #%10,D2
000016B4  6700 001E               1306              BEQ        PLong
000016B8                          1307  
000016B8                          1308  PByte:
000016B8  43F9 00001995           1309              LEA        printSIZEB,A1
000016BE  103C 000E               1310              MOVE.B     #14,D0
000016C2  4E4F                    1311              TRAP       #15
000016C4                          1312              
000016C4  4E75                    1313              RTS
000016C6                          1314  PWord:
000016C6  43F9 0000199A           1315              LEA        printSIZEW,A1
000016CC  103C 000E               1316              MOVE.B     #14,D0
000016D0  4E4F                    1317              TRAP       #15
000016D2                          1318              
000016D2  4E75                    1319              RTS
000016D4                          1320  PLong:            
000016D4  43F9 000019A0           1321              LEA        printSIZEL,A1
000016DA  103C 000E               1322              MOVE.B     #14,D0
000016DE  4E4F                    1323              TRAP       #15
000016E0                          1324              
000016E0  4E75                    1325              RTS
000016E2                          1326              
000016E2                          1327  *-----------------------------------------------------------
000016E2                          1328  * Addressing Mode Implementation
000016E2                          1329  *-----------------------------------------------------------
000016E2                          1330  addressModeSR:
000016E2                          1331              ;Prints address according to the parameters passed in
000016E2                          1332              ;PARAMETERS:
000016E2                          1333              ;D6 = mode
000016E2                          1334              ;D7 = register
000016E2                          1335  
000016E2                          1336              ;Data register direct
000016E2  BC3C 0000               1337              CMP.B       #%000,D6
000016E6  6700 002A               1338              BEQ         DRD
000016EA                          1339              
000016EA                          1340              ;Address register direct
000016EA  BC3C 0001               1341              CMP.B       #%001,D6
000016EE  6700 0036               1342              BEQ         ARD
000016F2                          1343              
000016F2                          1344              ;Address register indirect
000016F2  BC3C 0002               1345              CMP.B       #%010,D6
000016F6  6700 0042               1346              BEQ         ARI
000016FA                          1347              
000016FA                          1348              ;Post Increment
000016FA  BC3C 0003               1349              CMP.B       #%011,D6
000016FE  6700 005A               1350              BEQ         PI
00001702                          1351              
00001702                          1352              ;Pre Decrement
00001702  BC3C 0004               1353              CMP.B       #%100,D6
00001706  6700 0072               1354              BEQ         PD
0000170A                          1355              
0000170A                          1356              ;Immediate/Absolute Addressing
0000170A  BC3C 0007               1357              CMP.B       #%111,D6
0000170E  6700 008A               1358              BEQ         Address
00001712                          1359  DRD:
00001712                          1360              ;Print D __
00001712  43F9 000019A8           1361              LEA         printDRD,A1
00001718  103C 000E               1362              MOVE.B      #14,D0
0000171C  4E4F                    1363              TRAP        #15
0000171E                          1364              
0000171E                          1365              ;Print register number
0000171E  7003                    1366              MOVE.L      #3,D0
00001720  2207                    1367              MOVE.L      D7,D1
00001722  4E4F                    1368              TRAP        #15
00001724                          1369              
00001724  4E75                    1370              RTS
00001726                          1371  ARD:
00001726                          1372              ;Print A __
00001726  43F9 000019AA           1373              LEA         printARD,A1
0000172C  103C 000E               1374              MOVE.B      #14,D0
00001730  4E4F                    1375              TRAP        #15
00001732                          1376              
00001732                          1377              ;Print register number
00001732  7003                    1378              MOVE.L      #3,D0
00001734  2207                    1379              MOVE.L      D7,D1
00001736  4E4F                    1380              TRAP        #15
00001738                          1381              
00001738  4E75                    1382              RTS
0000173A                          1383  ARI:
0000173A                          1384              ;Print (A __ )
0000173A  43F9 000019AC           1385              LEA         printARI,A1
00001740  103C 000E               1386              MOVE.B      #14,D0
00001744  4E4F                    1387              TRAP        #15
00001746                          1388              
00001746                          1389              ;Print register number
00001746  7003                    1390              MOVE.L      #3,D0
00001748  2207                    1391              MOVE.L      D7,D1
0000174A  4E4F                    1392              TRAP        #15
0000174C                          1393              
0000174C                          1394              ;Print closing ')'
0000174C  43F9 000019AF           1395              LEA         printARI2,A1
00001752  103C 000E               1396              MOVE.B      #14,D0
00001756  4E4F                    1397              TRAP        #15
00001758                          1398              
00001758  4E75                    1399              RTS
0000175A                          1400  PI:
0000175A                          1401              ;Print (A __)+
0000175A  43F9 000019B5           1402              LEA         printPI,A1
00001760  103C 000E               1403              MOVE.B      #14,D0
00001764  4E4F                    1404              TRAP        #15
00001766                          1405              
00001766                          1406              ;Print register number
00001766  7003                    1407              MOVE.L      #3,D0
00001768  2207                    1408              MOVE.L      D7,D1
0000176A  4E4F                    1409              TRAP        #15
0000176C                          1410              
0000176C                          1411              ;Print closing ')+'
0000176C  43F9 000019B8           1412              LEA         printPI2,A1
00001772  103C 000E               1413              MOVE.B      #14,D0
00001776  4E4F                    1414              TRAP        #15
00001778                          1415              
00001778  4E75                    1416              RTS
0000177A                          1417  PD:
0000177A                          1418              ;Print -(A __)
0000177A  43F9 000019BB           1419              LEA         printPD,A1
00001780  103C 000E               1420              MOVE.B      #14,D0
00001784  4E4F                    1421              TRAP        #15
00001786                          1422              
00001786                          1423              ;Print register number
00001786  7003                    1424              MOVE.L      #3,D0
00001788  2207                    1425              MOVE.L      D7,D1
0000178A  4E4F                    1426              TRAP        #15
0000178C                          1427              
0000178C                          1428              ;Print closing ')'
0000178C  43F9 000019BF           1429              LEA         printPD2,A1
00001792  103C 000E               1430              MOVE.B      #14,D0
00001796  4E4F                    1431              TRAP        #15
00001798                          1432              
00001798  4E75                    1433              RTS
0000179A                          1434              
0000179A                          1435  Address:
0000179A                          1436              ;Print #--------          
0000179A  BE3C 0004               1437              CMP.B       #%100,D7
0000179E  6700 0038               1438              BEQ         printImmediate
000017A2                          1439              
000017A2                          1440              ;Print $--------
000017A2  BE3C 0000               1441              CMP.B       #%000,D7
000017A6  6700 0042               1442              BEQ         printAbsolute
000017AA                          1443              
000017AA                          1444              ;Print $----
000017AA  BE3C 0001               1445              CMP.B       #%001,D7
000017AE  6700 003A               1446              BEQ         printAbsolute
000017B2                          1447              
000017B2                          1448              ;Since we are dealing with addresses, we update our address to account for the actual address value
000017B2                          1449              ;We will be able to access the contents of either size B or W
000017B2  544A                    1450              ADDA.W      #2,A2         
000017B4                          1451  
000017B4                          1452              ;See if we have to print out a long 
000017B4  0C14 0002               1453              CMP.B       #%10,(A4)
000017B8  6700 000A               1454              BEQ         updateLong
000017BC                          1455              
000017BC                          1456              ;If we don't branch, then we assume we're printing out a byte or word      
000017BC  7003                    1457              MOVE.L      #3,D0
000017BE  3212                    1458              MOVE.W      (A2),D1
000017C0  4E4F                    1459              TRAP        #15
000017C2                          1460              
000017C2  4E75                    1461              RTS
000017C4                          1462  
000017C4                          1463  
000017C4                          1464  updateLong:
000017C4                          1465              ;Place the current value into a temp register
000017C4  3812                    1466              MOVE.W      (A2),D4
000017C6                          1467              
000017C6                          1468              ;Shift the bits so we can enter the rest of the values
000017C6  1E3C 0010               1469              MOVE.B      #16,D7
000017CA  EFAC                    1470              LSL.L       D7,D4
000017CC                          1471              
000017CC                          1472              ;Increment A2 to account for the next values in the machine code
000017CC  544A                    1473              ADDA.W      #2,A2
000017CE                          1474              
000017CE                          1475              ;Move the rest of the machine code into our register
000017CE                          1476              ;This register should have the whole long values
000017CE  3812                    1477              MOVE.W      (A2),D4
000017D0                          1478              
000017D0                          1479              ;Print out the value in the address
000017D0  7003                    1480              MOVE.L      #3,D0
000017D2  2204                    1481              MOVE.L      D4,D1
000017D4  4E4F                    1482              TRAP        #15
000017D6                          1483              
000017D6  4E75                    1484              RTS
000017D8                          1485  
000017D8                          1486  *-----------------------------------------------------------
000017D8                          1487  * Print Immediate, or Absolute Addressing symbol
000017D8                          1488  *-----------------------------------------------------------
000017D8                          1489  printImmediate:
000017D8  43F9 000019B1           1490              LEA         printIA,A1
000017DE  103C 000E               1491              MOVE.B      #14,D0
000017E2  4E4F                    1492              TRAP        #15
000017E4                          1493              
000017E4                          1494              ;Clear D7 so we can branch back and not repeat the process in Address
000017E4  1E3C 0007               1495              MOVE.B      #7,D7
000017E8                          1496              
000017E8  60B0                    1497              BRA         Address
000017EA                          1498   
000017EA                          1499  printAbsolute:
000017EA  43F9 000019B3           1500              LEA         printA,A1
000017F0  103C 000E               1501              MOVE.B      #14,D0
000017F4  4E4F                    1502              TRAP        #15
000017F6                          1503              
000017F6                          1504              ;Clear D7 so we can branch back and not repeat the process in Address
000017F6  1E3C 0007               1505              MOVE.B      #7,D7
000017FA                          1506              
000017FA  609E                    1507              BRA         Address
000017FC                          1508  
000017FC                          1509  *-----------------------------------------------------------
000017FC                          1510  * Print Instructions for NOP and RTS
000017FC                          1511  *-----------------------------------------------------------
000017FC                          1512  printMNOP:
000017FC  43F9 00001902           1513              LEA        printNOP,A1
00001802  103C 000E               1514              MOVE.B     #14,D0
00001806  4E4F                    1515              TRAP       #15
00001808                          1516              
00001808  6000 F998               1517              BRA        update
0000180C                          1518  
0000180C                          1519  printMRTS:
0000180C  43F9 0000197B           1520              LEA        printRTS,A1
00001812  103C 000E               1521              MOVE.B     #14,D0
00001816  4E4F                    1522              TRAP       #15
00001818                          1523              
00001818  6000 F988               1524              BRA        update
0000181C                          1525  ;-----------------------------------------------------------
0000181C                          1526  ;ERROR MESSAGES FOR I/O portion
0000181C                          1527  ;-----------------------------------------------------------
0000181C                          1528  charError:
0000181C                          1529              
0000181C  43F9 000019E6           1530              LEA         invalCh,A1
00001822  103C 000E               1531              MOVE.B      #14,D0
00001826  4E4F                    1532              TRAP        #15
00001828                          1533              
00001828  6000 F7FE               1534              BRA         startingPrompt
0000182C                          1535            
0000182C                          1536  oddError:
0000182C  43F9 00001A07           1537              LEA         odd,A1
00001832  103C 000E               1538              MOVE.B      #14,D0
00001836  4E4F                    1539              TRAP        #15
00001838                          1540              
00001838  6000 F7EE               1541              BRA         startingPrompt
0000183C                          1542              
0000183C                          1543  manyCharError:  
0000183C  43F9 00001A34           1544              LEA         manyChar, A1
00001842  103C 000E               1545              MOVE.B      #14,D0
00001846  4E4F                    1546              TRAP        #15
00001848                          1547              
00001848  6000 F7DE               1548              BRA         startingPrompt
0000184C                          1549           
0000184C                          1550  endGreater:
0000184C  43F9 00001A6F           1551              LEA         endG,A1
00001852  103C 000E               1552              MOVE.B      #14,D0
00001856  4E4F                    1553              TRAP        #15
00001858                          1554              
00001858  6000 F7CE               1555              BRA         startingPrompt
0000185C                          1556      
0000185C                          1557  ;-----------------------------------------------------------
0000185C                          1558  ;MESSAGES
0000185C                          1559  ;-----------------------------------------------------------
0000185C= 57 65 6C 63 6F 6D ...   1560  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001880= 50 6C 65 61 73 65 ...   1561  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
000018C2= 50 6C 65 61 73 65 ...   1562  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001902                          1563  
00001902                          1564  ;-----------------------------------------------------------
00001902                          1565  ;OPCODE Messages
00001902                          1566  ;-----------------------------------------------------------
00001902= 0D 0A 4E 4F 50 00       1567  printNOP    DC.B        CR,LF,'NOP',0
00001908= 0D 0A 4D 4F 56 45 00    1568  printMOVE   DC.B        CR,LF,'MOVE',0
0000190F= 0D 0A 4D 4F 56 45 ...   1569  printMOVEM  DC.B        CR,LF,'MOVEM',0
00001917= 0D 0A 41 44 44 00       1570  printADD    DC.B        CR,LF,'ADD',0
0000191D= 0D 0A 53 55 42 00       1571  printSUB    DC.B        CR,LF,'SUB',0
00001923= 0D 0A 4D 55 4C 53 ...   1572  printMULS   DC.B        CR,LF,'MULS.W ',0
0000192D= 0D 0A 44 49 56 55 ...   1573  printDIVU   DC.B        CR,LF,'DIVU.W ',0
00001937= 0D 0A 4C 45 41 20 00    1574  printLEA    DC.B        CR,LF,'LEA ',0
0000193E= 0D 0A 41 4E 44 00       1575  printAND    DC.B        CR,LF,'AND',0
00001944= 0D 0A 4E 4F 54 00       1576  printNOT    DC.B        CR,LF,'NOT',0
0000194A= 0D 0A 4C 53 4C 00       1577  printLSL    DC.B        CR,LF,'LSL',0
00001950= 0D 0A 4C 53 52 00       1578  printLSR    DC.B        CR,LF,'LSR',0
00001956= 0D 0A 41 53 4C 00       1579  printASL    DC.B        CR,LF,'ASL',0
0000195C= 0D 0A 41 53 52 00       1580  printASR    DC.B        CR,LF,'ASR',0
00001962= 0D 0A 42 4C 54 00       1581  printBLT    DC.B        CR,LF,'BLT',0
00001968= 0D 0A 42 47 45 00       1582  printBGE    DC.B        CR,LF,'BGE',0
0000196E= 0D 0A 42 45 51 00       1583  printBEQ    DC.B        CR,LF,'BEQ',0
00001974= 0D 0A 4A 53 52 20 00    1584  printJSR    DC.B        CR,LF,'JSR ',0
0000197B= 0D 0A 52 54 53 00       1585  printRTS    DC.B        CR,LF,'RTS',0
00001981= 0D 0A 42 52 41 00       1586  printBRA    DC.B        CR,LF,'BRA',0
00001987= 0D 0A 41 53 00          1587  printMAS    DC.B        CR,LF,'AS',0
0000198C= 0D 0A 4C 53 00          1588  printMLS    DC.B        CR,LF,'LS',0
00001991= 4C 00                   1589  printL      DC.B        'L',0    
00001993= 52 00                   1590  printR      DC.B        'R',0
00001995                          1591  ;-----------------------------------------------------------
00001995                          1592  ;Size Messages
00001995                          1593  ;-----------------------------------------------------------
00001995= 2E 42 20 00             1594  printSIZEB  DC.B        '.B ',0
0000199A= 2E57 2000 0000          1595  printSIZEW  DC.W        '.W ',0
000019A0= 2E4C2000 00000000       1596  printSIZEL  DC.L        '.L ',0
000019A8                          1597  
000019A8                          1598  ;-----------------------------------------------------------
000019A8                          1599  ;Addressing Mode Messages
000019A8                          1600  ;-----------------------------------------------------------
000019A8= 44 00                   1601  printDRD      DC.B        'D',0
000019AA= 41 00                   1602  printARD      DC.B        'A',0
000019AC= 28 41 00                1603  printARI      DC.B        '(A',0
000019AF= 29 00                   1604  printARI2     DC.B        ')',0
000019B1= 23 00                   1605  printIA       DC.B        '#',0
000019B3= 24 00                   1606  printA        DC.B        '$',0
000019B5= 28 41 00                1607  printPI       DC.B        '(A',0
000019B8= 29 2B 00                1608  printPI2      DC.B        ')+',0
000019BB= 2D 28 41 00             1609  printPD       DC.B        '-(A',0
000019BF= 29 00                   1610  printPD2      DC.B        ')',0
000019C1                          1611  
000019C1= 2C 00                   1612  printComma    DC.B        ',',0
000019C3= 20 00                   1613  printSpace    DC.B        ' ',0
000019C5                          1614  
000019C5= 0D 0A 59 6F 75 20 ...   1615  theEnd        DC.B        CR,LF,'You are now ending the program',0
000019E6                          1616  
000019E6                          1617  ;-----------------------------------------------------------
000019E6                          1618  ;ERRORS
000019E6                          1619  ;-----------------------------------------------------------
000019E6= 45 52 52 4F 52 3A ...   1620  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001A07= 45 52 52 4F 52 3A ...   1621  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001A34= 45 52 52 4F 52 3A ...   1622  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001A6F= 45 52 52 4F 52 3A ...   1623  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00001AB4= 45 52 52 4F 52 3A ...   1624  sizeError   DC.B        'ERROR: Invalid size instruction',0
00001AD4                          1625  
00001AD4                          1626  ;-----------------------------------------------------------
00001AD4                          1627  ;Ending function that ends our program 
00001AD4                          1628  ;-----------------------------------------------------------
00001AD4                          1629  ending:
00001AD4  43F8 19C5               1630              LEA         theEnd,A1
00001AD8  303C 000E               1631              MOVE        #14,D0
00001ADC  4E4F                    1632              TRAP        #15
00001ADE                          1633              
00001ADE                          1634              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS             179A
ADDRESSMODESR       16E2
ARD                 1726
ARI                 173A
CHARERROR           181C
CONTINUEDIVU        133A
CONVERT             107C
CR                  D
DNDEST              15FA
DNSOURCE            161E
DRD                 1712
ENDG                1A6F
ENDGREATER          184C
ENDHEX              1004
ENDING              1AD4
ENDINGPROMPT        1054
GETBITS             11AE
IMMEDIATECOUNT      1498
IMMEDIATECOUNT2     14C0
INVALCH             19E6
ISOLATEADDRESSBIT0TO5  1642
ISOLATEADDRESSBIT6TO11  1216
ISOLATEREGISTERBIT9TO11  1668
LETTER              10A0
LF                  A
LOOP                1130
M00                 11C4
M0100               123C
M0110               131E
M1000               131E
M1001               134A
M1100               138A
M1101               15BA
M1110               13FE
MAIN                1000
MAND                13CE
MANYCHAR            1A34
MANYCHARERROR       183C
MAS                 1532
MBEQ                131E
MBGE                131E
MBLT                131E
MBRA                131E
MEMAS               1504
MEMDIRECTIONSUBROUTINE  1540
MEMLS               150C
MEMSHIFT            14CE
MEMSHIFT2           14EC
MJSR                1306
ML                  156C
MLEA                12AA
MLS                 1524
MMULS               13BE
MNOT                12DA
MORECHECKS          10D0
MORECHECKS1         10DC
MORECHECKS2         10FE
MOVEM               129E
MR                  155E
MSOURCEDEST         11F8
MULSCHECK           13A8
NUMBER              10B4
ODD                 1A07
ODDERROR            182C
PBYTE               16B8
PD                  177A
PI                  175A
PLONG               16D4
PRINTA              19B3
PRINTABSOLUTE       17EA
PRINTADD            1917
PRINTAND            193E
PRINTARD            19AA
PRINTARI            19AC
PRINTARI2           19AF
PRINTASL            1956
PRINTASR            195C
PRINTBEQ            196E
PRINTBGE            1968
PRINTBLT            1962
PRINTBRA            1981
PRINTCOMMA          19C1
PRINTDIVU           192D
PRINTDRD            19A8
PRINTIA             19B1
PRINTIMMEDIATE      17D8
PRINTJSR            1974
PRINTL              1991
PRINTLEA            1937
PRINTLSL            194A
PRINTLSR            1950
PRINTMAS            1987
PRINTMLS            198C
PRINTMNOP           17FC
PRINTMOVE           1908
PRINTMOVEM          190F
PRINTMOVESIZE       16A0
PRINTMRTS           180C
PRINTMULS           1923
PRINTNOP            1902
PRINTNOT            1944
PRINTPD             19BB
PRINTPD2            19BF
PRINTPI             19B5
PRINTPI2            19B8
PRINTR              1993
PRINTRTS            197B
PRINTSIZEB          1995
PRINTSIZEL          19A0
PRINTSIZESUBROUTINE  1680
PRINTSIZEW          199A
PRINTSPACE          19C3
PRINTSUB            191D
PWORD               16C6
REGAS               1514
REGDIRECTIONSUBROUTINE  157C
REGLS               151C
REGSHIFT            1436
REGSHIFT2           146E
RL                  15AA
RR                  159A
SHIFTEIGHT          14C8
SIZEERROR           1AB4
STAHEX              1000
STARTINGPROMPT      1028
TESTING             101A
THEEND              19C5
UPDATE              11A2
UPDATELONG          17C4
USEREA              18C2
USERSA              1880
WELCOME             185C
