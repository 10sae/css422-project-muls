00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/30/2021 4:02:51 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 000019C6             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29                     
00001014                            30              ;===TESTING===
00001014  4EB9 0000101A             31              JSR      testing
0000101A                            32              
0000101A                            33  ;===TESTING================            
0000101A                            34  testing:
0000101A                            35  
0000101A                            36  ;See what you can do with MOVEM
0000101A                            37  ;Implement the rest of the opcodes when the other members have them
0000101A  0603 000C                 38              ADD.B       #12,D3
0000101E  0647 04D2                 39              ADD.W       #1234,D7
00001022  0684 00BC614E             40              ADD.L       #12345678,D4
00001028  0403 000C                 41              SUB.B       #12,D3
0000102C  0445 04D2                 42              SUB.W       #1234,D5
00001030  0486 00BC614E             43              SUB.L       #12345678,D6
00001036                            44              
00001036  0603 000C                 45              ADD.B       #12,D3
0000103A  DEB9 12345678             46              ADD.L       $12345678,D7
00001040  0647 04D2                 47              ADD.W       #1234,D7
00001044  0684 00BC614E             48              ADD.L       #12345678,D4
0000104A  0403 000C                 49              SUB.B       #12,D3
0000104E  0445 04D2                 50              SUB.W       #1234,D5
00001052  0486 00BC614E             51              SUB.L       #12345678,D6
00001058                            52              
00001058  11FC 000C 1238            53              MOVE.B      #12,$1238
0000105E  31FC 2654 1238            54              MOVE.W      #9812,$1238
00001064  21FC 00BD995F 1234        55              MOVE.L      #12425567,$1234
0000106C                            56              
0000106C                            57  
0000106C                            58              
0000106C                            59             
0000106C                            60              
0000106C                            61  ;==========================            
0000106C                            62              
0000106C                            63  startingPrompt:
0000106C                            64              ;Ask the user for the starting hex3
0000106C  43F9 000019EA             65              LEA         userSA,A1
00001072  103C 000E                 66              MOVE.B      #14,D0
00001076  4E4F                      67              TRAP        #15        
00001078                            68              
00001078                            69              ;Clear the registers in case we had an error
00001078  227C 00000000             70              MOVE.L      #0,A1
0000107E  247C 00000000             71              MOVE.L      #0,A2
00001084  4283                      72              CLR.L       D3
00001086  4284                      73              CLR.L       D4
00001088  4285                      74              CLR.L       D5
0000108A  4286                      75              CLR.L       D6
0000108C                            76             
0000108C                            77              
0000108C                            78              ;Input for the hex (D1 equals number of chars)
0000108C  303C 0002                 79              MOVE.W      #2,D0
00001090  4E4F                      80              TRAP        #15
00001092                            81              
00001092                            82              ;Moves A1 into A2      
00001092                            83              ;MOVEA.L     A1,A2
00001092                            84              
00001092                            85              ;Makes sure D7 is clear incase we're looping back after an error.
00001092  4207                      86              CLR.B       D7
00001094                            87              
00001094  6000 002A                 88              BRA         convert  
00001098                            89              
00001098                            90  endingPrompt:
00001098                            91              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001098  1E3C 0001                 92              MOVE.B       #1,D7
0000109C                            93              
0000109C                            94              ;Ask the user for the ending hex
0000109C  43F9 00001A2C             95              LEA         userEA,A1
000010A2  103C 000E                 96              MOVE.B      #14,D0
000010A6  4E4F                      97              TRAP        #15
000010A8                            98              
000010A8                            99              ;Clearing the registers so we can reuse them for the ending address
000010A8  227C 00000000            100              MOVE.L      #0,A1
000010AE  247C 00000000            101              MOVE.L      #0,A2
000010B4  4286                     102              CLR.L       D6
000010B6                           103  
000010B6                           104              ;Input for the hex (D1 equals number of chars)
000010B6  303C 0002                105              MOVE.W      #2,D0
000010BA  4E4F                     106              TRAP        #15
000010BC                           107              
000010BC                           108              ;Moves A1 into A2      
000010BC                           109              ;MOVEA.L     A1,A2
000010BC                           110              
000010BC  6000 0002                111              BRA         convert
000010C0                           112  
000010C0                           113  convert:    
000010C0                           114              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
000010C0  B23C 0006                115              CMP.B       #6, D1
000010C4  6E00 08E0                116              BGT         manyCharError  
000010C8                           117              
000010C8                           118              ;See if our counter variable is 0
000010C8  B23C 0000                119              CMP.B       #0,D1
000010CC                           120              
000010CC                           121              ;This means that we have gone through all the characters
000010CC  6700 0046                122              BEQ         moreChecks
000010D0                           123              
000010D0                           124              ;Decrement the counter, this means we're about to go through another char
000010D0  5301                     125              SUB.B       #1,D1
000010D2                           126  
000010D2                           127              ;Let's move the byte stored at A1
000010D2  1612                     128              MOVE.B      (A2),D3
000010D4                           129              
000010D4                           130              ;If the byte is greater than or equal to hex $40, then it's a letter
000010D4  B63C 0041                131              CMP.B       #$41,D3
000010D8  6C00 000A                132              BGE         letter
000010DC                           133              
000010DC                           134              ;If the byte is less than or equal to hex $39, then it's a number
000010DC  B63C 0040                135              CMP.B       #$40,D3
000010E0  6F00 0016                136              BLE         number
000010E4                           137              
000010E4                           138  letter:
000010E4                           139              ;We do this check to see if the character is greater than or equal 'G'
000010E4  B63C 0047                140              CMP.B       #$47,D3
000010E8                           141              ;If so, then display an error and ask the user to enter startingAdd again
000010E8  6C00 089C                142              BGE         charError
000010EC                           143              
000010EC                           144              ;Subtract the Ascii value to convert to hex
000010EC  0403 0037                145              SUB.B       #$37,D3
000010F0                           146              ;Move the value back to our register
000010F0  14C3                     147              MOVE.B      D3,(A2)+
000010F2                           148              
000010F2                           149              ;Shift D5 left to make room for next hex value
000010F2  E986                     150              ASL.L       #4, D6
000010F4                           151              ;Move value to D5
000010F4  DC03                     152              ADD.B      D3, D6
000010F6                           153              
000010F6  60C8                     154              BRA         convert
000010F8                           155             
000010F8                           156  
000010F8                           157  number:          
000010F8                           158             ;We do this check to see if the character is less than or equal to '/'  
000010F8  B63C 002F                159             CMP.B        #$2F,D3
000010FC                           160             ;If so, then display an error and ask the user to enter startingAdd again
000010FC  6F00 0888                161             BLE          charError     
00001100                           162   
00001100                           163             ;Check to see if the character is greater than or equal to ':'
00001100  B63C 003A                164             CMP.B        #$3A,D3
00001104                           165             ;If so, then display an error and ask the user to enter startingAdd again
00001104  6C00 0880                166             BGE          charError
00001108                           167            
00001108                           168             ;Subtract the Ascii value to convert to hex
00001108  0403 0030                169             SUB.B        #$30,D3
0000110C                           170             ;Move the value back to our register
0000110C  14C3                     171             MOVE.B       D3,(A2)+
0000110E                           172   
0000110E                           173             ;Shift D5 left to make room for next hex value
0000110E  E986                     174             ASL.L        #4, D6
00001110                           175             ;Move value to D5
00001110  DC03                     176             ADD.B        D3, D6
00001112                           177              
00001112  60AC                     178             BRA          convert
00001114                           179   
00001114                           180            
00001114                           181  moreChecks:
00001114                           182              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
00001114  BE3C 0001                183              CMP.B      #1,D7
00001118  6700 0028                184              BEQ        moreChecks2
0000111C                           185              
0000111C  6000 0002                186              BRA        moreChecks1
00001120                           187   
00001120                           188  moreChecks1:
00001120                           189              
00001120                           190              ;Copy the hex value into a temp register
00001120  2806                     191              MOVE.L      D6,D4
00001122                           192              
00001122                           193              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001122  1A3C 001F                194              MOVE.B      #31,D5
00001126                           195              
00001126                           196              ;Shifts 31 bits, isolates last bit. 
00001126  EBAC                     197              LSL.L       D5,D4
00001128                           198  
00001128                           199              ;Shifts it back 31 bit, isolating the last bit. 
00001128  EAAC                     200              LSR.L       D5,D4
0000112A                           201  
0000112A                           202              ;If the last bit is 1, address was odd, and throw an error. 
0000112A  B83C 0001                203              CMP.B       #1,D4
0000112E  6700 0866                204              BEQ         oddError   
00001132                           205                          
00001132                           206              ;Reset address registers.
00001132  247C 00000000            207              MOVE.L      #0,A2
00001138                           208              
00001138                           209              ;Copy the value to our staHex variable
00001138  21C6 1000                210              MOVE.L      D6,staHex 
0000113C                           211              
0000113C  4286                     212              CLR.L       D6
0000113E  6000 FF58                213              BRA         endingPrompt     
00001142                           214              
00001142                           215  moreChecks2:       
00001142                           216              
00001142                           217              ;Copy the hex value into a temp register
00001142  2806                     218              MOVE.L      D6,D4
00001144                           219              
00001144                           220              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001144  1A3C 001F                221              MOVE.B      #31,D5
00001148                           222              
00001148                           223              ;Shifts 31 bits, isolates last bit. 
00001148  EBAC                     224              LSL.L       D5,D4
0000114A                           225  
0000114A                           226              ;Shifts it back 31 bit, isolating the last bit. 
0000114A  EAAC                     227              LSR.L       D5,D4
0000114C                           228  
0000114C                           229              ;If the last bit is 1, address was odd, and throw an error. 
0000114C  B83C 0001                230              CMP.B       #1,D4
00001150  6700 0844                231              BEQ         oddError   
00001154                           232                          
00001154                           233              ;Reset address registers.
00001154  247C 00000000            234              MOVE.L      #0,A2
0000115A                           235              
0000115A                           236              ;Place the value in our ending hex variable
0000115A  21C6 1004                237              MOVE.L      D6,endHex 
0000115E                           238              
0000115E                           239              ;Make D7 a temp location to compare our starting hex
0000115E  2E38 1000                240              MOVE.L      staHex,D7
00001162                           241           
00001162                           242              
00001162                           243              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001162  BC87                     244              CMP.L       D7,D6
00001164  6B00 0850                245              BMI         endGreater
00001168                           246              
00001168                           247              ;done, start reading memory. 
00001168                           248              
00001168                           249              ;Clear all the registers since we have the addresses stored in our variables
00001168  4283                     250              CLR.L       D3
0000116A  4285                     251              CLR.L       D5
0000116C  4286                     252              CLR.L       D6
0000116E  4287                     253              CLR.L       D7  
00001170                           254              
00001170                           255              ;Copy the value of our starting hex to A2 (temp register)
00001170  2478 1000                256              MOVEA.L     staHex,A2
00001174                           257                          
00001174                           258              
00001174                           259  LOOP:   
00001174                           260              ;--------------------------------------------------------
00001174                           261              ;Check for NOP or RTS
00001174                           262              ;--------------------------------------------------------
00001174                           263              
00001174                           264              ;Move the NOP binary value for comparing
00001174  243C 00004E71            265              MOVE.L      #%0100111001110001,D2
0000117A                           266              
0000117A                           267              ;Check and see i the instruction is NOP
0000117A  B452                     268              CMP.W       (A2),D2
0000117C  6700 07E8                269              BEQ         printMNOP
00001180                           270              
00001180                           271              ;Move the RTS binary value for comparing
00001180  243C 00004E75            272              MOVE.L      #%0100111001110101,D2
00001186                           273              
00001186                           274              ;Check and see if the instruction is RTS
00001186  B452                     275              CMP.W       (A2),D2
00001188  6700 07EC                276              BEQ         printMRTS
0000118C                           277              
0000118C                           278              ;Clear the contents for reusing
0000118C  4282                     279              CLR.L       D2
0000118E                           280              
0000118E                           281              ;--------------------------------------------------------
0000118E                           282              ;Check for ADDI or SUBI, check for four 0's since it's the only
0000118E                           283              ;opcode with this pattern
0000118E                           284              ;--------------------------------------------------------  
0000118E                           285              ;Move the value in A2 to a temp register
0000118E  3412                     286              MOVE.W      (A2),D2
00001190                           287              
00001190                           288              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001190  163C 000C                289              MOVE.B      #12,D3
00001194  183C 0004                290              MOVE.B      #4,D4
00001198                           291              
00001198                           292              ;Jumps to getBits and returns with isolated bits in D2
00001198  6100 0078                293              BSR         getBits
0000119C                           294              
0000119C  B43C 0000                295              CMP.B       #%0000,D2
000011A0  6700 0086                296              BEQ         M0000
000011A4                           297              
000011A4                           298              ;--------------------------------------------------------
000011A4                           299              ;Check for MOVE, since it's the only word starting with 00
000011A4                           300              ;--------------------------------------------------------            
000011A4                           301              ;Move the value in A2 to a temp register
000011A4  1412                     302              MOVE.B      (A2),D2
000011A6                           303              
000011A6                           304              ;Shift 6 bits to the right to isolate the left-most digits
000011A6  EC8A                     305              LSR.L       #6,D2
000011A8                           306              
000011A8                           307              ;If the first two bits (left-most) are 00, then the instruction is MOVE
000011A8  B43C 0000                308              CMP.B       #00,D2
000011AC  6F00 014E                309              BLE         M00
000011B0                           310              
000011B0                           311              ;Reuse the register
000011B0  4282                     312              CLR.L       D2
000011B2                           313              
000011B2                           314              
000011B2                           315              ;--------------------------------------------------------
000011B2                           316              ;Check for other OpCodes
000011B2                           317              ;--------------------------------------------------------
000011B2                           318              ;Move the word into a temp register 
000011B2  3412                     319              MOVE.W      (A2),D2
000011B4                           320              
000011B4                           321              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
000011B4  163C 000C                322              MOVE.B        #12,D3            ;Start bit index = 12
000011B8  183C 0004                323              MOVE.B        #4,D4             ;Number of bits needed = 4
000011BC                           324              
000011BC                           325              ;Jumps to getBits and returns with isolated bits in D2
000011BC  6100 0054                326              BSR           getBits            
000011C0                           327  
000011C0                           328              
000011C0                           329              ;MOVEM,LEA,NOT,JSR
000011C0  B43C 0004                330              CMP.B       #%0100,D2
000011C4  6700 01B4                331              BEQ         M0100
000011C8                           332              
000011C8                           333              ;BRA,BLT,BGE,BEQ
000011C8  B43C 0006                334              CMP.B       #%0110,D2
000011CC  6700 028E                335              BEQ         M0110
000011D0                           336              
000011D0                           337              ;DIVU
000011D0  B43C 0008                338              CMP.B       #%1000,D2
000011D4  6700 0286                339              BEQ         M1000
000011D8                           340              
000011D8                           341              ;SUB
000011D8  B43C 0009                342              CMP.B       #%1001,D2
000011DC  6700 02AA                343              BEQ         M1001
000011E0                           344              
000011E0                           345              ;MULS,AND
000011E0  B43C 000C                346              CMP.B       #%1100,D2
000011E4  6700 02E6                347              BEQ         M1100
000011E8                           348              
000011E8                           349              ;LSL,LSR,ASL,ASR
000011E8  B43C 000E                350              CMP.B       #%1110,D2
000011EC  6700 0352                351              BEQ         M1110
000011F0                           352              
000011F0                           353              ;ADD
000011F0  B43C 000D                354              CMP.B       #%1101,D2
000011F4  6700 0506                355              BEQ         M1101
000011F8                           356              
000011F8  6000 0A52                357              BRA         ending
000011FC                           358              
000011FC                           359              
000011FC                           360              
000011FC                           361              ;display INVALID OPCODE, and display the raw hex
000011FC                           362              ;do this later
000011FC                           363  
000011FC                           364             
000011FC                           365  update:
000011FC                           366              *=====Important if we've done any Immediate or Absolute addressing=====*
000011FC                           367              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
000011FC                           368              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
000011FC                           369              ;because A2 always points at the the first word in an instruction (opcode).
000011FC  B5CE                     370              CMP.L       A6,A2
000011FE  6C00 0004                371              BGE         skipA6
00001202                           372              
00001202                           373              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
00001202  244E                     374              MOVEA.L     A6,A2
00001204                           375              
00001204                           376  skipA6:
00001204                           377              ;Check and see if we are at the ending hex
00001204  B5F8 1004                378              CMP.L      endHex,A2
00001208  6E00 0A42                379              BGT        ending
0000120C                           380  
0000120C                           381              ;Update address in A2
0000120C  544A                     382              ADDA.W      #2,A2
0000120E                           383              
0000120E                           384              
0000120E  6000 FF64                385              BRA        LOOP
00001212                           386              
00001212                           387              
00001212                           388  getBits:
00001212                           389              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
00001212                           390              ;PARAMETERS:
00001212                           391              ;D2 = the value the bits are extracted from & saved back in
00001212                           392              ;D3 = the start bit index (starting from 0)
00001212                           393              ;D4 = the number of bits we want to extract
00001212                           394              
00001212                           395              ;Calculate left shift
00001212  3A3C 0010                396              MOVE.W      #16,D5
00001216                           397              
00001216  D843                     398              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
00001218  9A44                     399              SUB.W       D4,D5             ; 16 - X = leftShift
0000121A                           400              
0000121A  EB6A                     401              LSL.W       D5,D2
0000121C                           402              
0000121C                           403              
0000121C                           404              ;Calculate right shift
0000121C  DA43                     405              ADD.W       D3,D5             ; start bit + leftShift = X
0000121E  EA6A                     406              LSR.W       D5,D2
00001220                           407              
00001220  4283                     408              CLR.L       D3
00001222  4284                     409              CLR.L       D4
00001224  4285                     410              CLR.L       D5   
00001226  4E75                     411              RTS
00001228                           412  
00001228                           413  *-----------------------------------------------------------
00001228                           414  * 
00001228                           415  *
00001228                           416  *
00001228                           417  * OpCode Implementation
00001228                           418  *
00001228                           419  *
00001228                           420  *
00001228                           421  *-----------------------------------------------------------
00001228                           422  
00001228                           423  
00001228                           424  *-----------------------------------------------------------
00001228                           425  * ADDI/SUBI INSTRUCTION
00001228                           426  *-----------------------------------------------------------
00001228                           427  M0000:
00001228  4282                     428              CLR.L       D2
0000122A  4283                     429              CLR.L       D3
0000122C                           430              
0000122C                           431              ;Copy the address values into a register to check for ADDI or SUBI
0000122C  3412                     432              MOVE.W      (A2),D2
0000122E                           433              
0000122E                           434              ;Passing in paramters for isolating bits
0000122E  163C 0008                435              MOVE.B      #8,D3
00001232  183C 0004                436              MOVE.B      #4,D4
00001236                           437              
00001236                           438              ;Jumps to getBits and returns with isolated bits in D2
00001236  61DA                     439              BSR         getBits
00001238                           440              
00001238                           441              ;--------------------------------------------------------
00001238                           442              ;Check for ADDI
00001238                           443              ;--------------------------------------------------------
00001238  B43C 0006                444              CMP.B       #%0110,D2
0000123C  6700 000A                445              BEQ         MADDI
00001240                           446             
00001240                           447              ;--------------------------------------------------------
00001240                           448              ;Check for SUBI
00001240                           449              ;--------------------------------------------------------
00001240  B43C 0004                450              CMP.B       #%0100,D2
00001244  6700 0036                451              BEQ         MSUBI
00001248                           452  
00001248                           453  MADDI:
00001248  43F9 00001A87            454              LEA         printADDI,A1
0000124E  103C 000E                455              MOVE.B      #14,D0
00001252  4E4F                     456              TRAP        #15
00001254                           457              
00001254  4282                     458              CLR.L       D2
00001256  4283                     459              CLR.L       D3
00001258                           460              
00001258                           461              ;======Isolate Size (S) Bits======
00001258                           462              ;Copy the address values into a register
00001258  3412                     463              MOVE.W      (A2),D2
0000125A                           464              
0000125A                           465              ;Passing in parameters for isolating size bits
0000125A  163C 0006                466              MOVE.B      #6,D3
0000125E  183C 0002                467              MOVE.B      #2,D4
00001262                           468              
00001262                           469              ;Jumps to getBits and returns with isolated bits in D2
00001262  61AE                     470              BSR         getBits
00001264                           471              
00001264                           472              ;Jumps to printSizeSubroutine and returns after size has been printed
00001264  6100 0560                473              BSR         printSizeSubroutine
00001268                           474              
00001268                           475              ;Let's store the size indicator since it will help us determine how many times
00001268                           476              ;we have to iterate through addresses to print out the whole instruction
00001268                           477              ;We will use A4 as the register to temporary store the size
00001268  3842                     478              MOVE.W      D2,A4
0000126A  11C2 2000                479              MOVE.B      D2,$2000
0000126E                           480              
0000126E                           481              ;Clear the register so we can reuse it
0000126E  4282                     482              CLR.L       D2
00001270                           483              
00001270  1412                     484              MOVE.B      (A2),D2
00001272                           485              
00001272                           486              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001272                           487              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001272  264A                     488              MOVE.L      A2,A3
00001274                           489              
00001274  6100 003E                490              BSR         mEffect
00001278                           491              
00001278  4283                     492              CLR.L       D3
0000127A                           493              
0000127A  6080                     494              BRA         update
0000127C                           495              
0000127C                           496              
0000127C                           497  MSUBI:
0000127C  43F9 00001A94            498              LEA         printSUBI,A1
00001282  103C 000E                499              MOVE.B      #14,D0
00001286  4E4F                     500              TRAP        #15
00001288                           501              
00001288  4282                     502              CLR.L       D2
0000128A  4283                     503              CLR.L       D3
0000128C                           504              
0000128C                           505              ;======Isolate Size (S) Bits======
0000128C                           506              ;Copy the address values into a register
0000128C  3412                     507              MOVE.W      (A2),D2
0000128E                           508              
0000128E                           509              ;Passing in parameters for isolating size bits
0000128E  163C 0006                510              MOVE.B      #6,D3
00001292  183C 0002                511              MOVE.B      #2,D4
00001296                           512              
00001296                           513              ;Jumps to getBits and returns with isolated bits in D2
00001296  6100 FF7A                514              BSR         getBits
0000129A                           515              
0000129A                           516              ;Jumps to printSizeSubroutine and returns after size has been printed
0000129A  6100 052A                517              BSR         printSizeSubroutine
0000129E                           518              
0000129E                           519              ;Let's store the size indicator since it will help us determine how many times
0000129E                           520              ;we have to iterate through addresses to print out the whole instruction
0000129E                           521              ;We will use A4 as the register to temporary store the size
0000129E  3842                     522              MOVE.W      D2,A4
000012A0  11C2 2000                523              MOVE.B      D2,$2000
000012A4                           524              
000012A4                           525              ;Clear the register so we can reuse it
000012A4  4282                     526              CLR.L       D2
000012A6                           527              
000012A6  1412                     528              MOVE.B      (A2),D2
000012A8                           529              
000012A8                           530              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012A8                           531              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012A8  264A                     532              MOVE.L      A2,A3
000012AA                           533              
000012AA  6100 0008                534              BSR         mEffect
000012AE                           535              
000012AE  4283                     536              CLR.L       D3
000012B0                           537              
000012B0  6000 FF4A                538              BRA         update
000012B4                           539  
000012B4                           540              
000012B4                           541  mEffect:
000012B4                           542              ;Male D6 #%111 since the source will always be an immediate value 
000012B4  1C3C 0007                543              MOVE.B      #7,D6
000012B8                           544              ;Make D7 #%100 since the source will always be an immediate value
000012B8  1E3C 0004                545              MOVE.B      #4,D7     
000012BC                           546  
000012BC                           547              ;Print source address
000012BC  6100 056A                548              BSR         addressModeSR
000012C0                           549              
000012C0                           550              ;Print the comma after the source address
000012C0  43F9 00001B39            551              LEA        printComma,A1
000012C6  103C 000E                552              MOVE.B     #14,D0
000012CA  4E4F                     553              TRAP       #15
000012CC                           554              
000012CC                           555              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
000012CC  6100 0008                556              BSR        isoAddBit0to5
000012D0                           557              
000012D0                           558              ;Print source address
000012D0  6100 0556                559              BSR        addressModeSR
000012D4                           560              
000012D4  4E75                     561              RTS            
000012D6                           562              
000012D6                           563              
000012D6                           564  isoAddBit0to5:
000012D6                           565              ;===Isolate the Destination Mode (M)Bits===
000012D6  4282                     566              CLR.L      D2
000012D8                           567              
000012D8                           568              ;Copy the address value into a register
000012D8  3413                     569              MOVE.W     (A3),D2
000012DA                           570              
000012DA                           571              ;Passing in parameters for isolating Mode bits
000012DA  163C 0003                572              MOVE.B     #3,D3
000012DE  183C 0003                573              MOVE.B     #3,D4
000012E2                           574              
000012E2                           575              ;Jumps to getBits and returns with isolated bits in D2
000012E2  4EB8 1212                576              JSR        getBits
000012E6                           577              
000012E6                           578              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000012E6  1C02                     579              MOVE.B     D2,D6
000012E8                           580              
000012E8                           581              ;===Isolate the Destination Address Register (Xn)Bits===
000012E8  4282                     582              CLR.L      D2
000012EA                           583              
000012EA                           584              ;Copy the address values into a register
000012EA  3413                     585              MOVE.W     (A3),D2
000012EC                           586              
000012EC                           587              ;Passing in parameters for isolating Xn bits
000012EC  163C 0000                588              MOVE.B     #0,D3
000012F0  183C 0003                589              MOVE.B     #3,D4
000012F4                           590              
000012F4                           591              ;Jumps to getBits and returns with isolated bits in D2
000012F4  4EB8 1212                592              JSR        getBits
000012F8                           593              
000012F8                           594              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000012F8  1E02                     595              MOVE.B      D2,D7
000012FA                           596  
000012FA  4E75                     597              RTS
000012FC                           598              
000012FC                           599  *-----------------------------------------------------------
000012FC                           600  * MOVE INSTRUCTION
000012FC                           601  *-----------------------------------------------------------
000012FC                           602  M00:
000012FC  43F9 00001A72            603              LEA        printMOVE,A1
00001302  103C 000E                604              MOVE.B     #14,D0
00001306  4E4F                     605              TRAP       #15
00001308                           606              
00001308  4202                     607              CLR.B      D2
0000130A  4203                     608              CLR.B      D3
0000130C                           609              
0000130C                           610              ;======Isolate Size (S) Bits=======
0000130C                           611              ;Copy the address values into a register
0000130C  3412                     612              MOVE.W     (A2),D2
0000130E                           613              
0000130E                           614              ;Passing in parameters for isolating size bits 12,13
0000130E  163C 000C                615              MOVE.B      #12,D3             
00001312  183C 0002                616              MOVE.B      #2,D4             
00001316                           617              
00001316                           618              ;Jumps to getBits and returns with isolated bits in D2
00001316  6100 FEFA                619              BSR         getBits  
0000131A                           620              
0000131A                           621              ;Indicate to our print function we are doing this for the MOVE opcode
0000131A  163C 0001                622              MOVE.B      #1,D3
0000131E                           623              
0000131E                           624              ;Jumps to printSizeSubroutine and returns after size has been printed
0000131E  6100 04A6                625              BSR         printSizeSubroutine
00001322                           626              
00001322                           627              ;Let's store the size indicator since it will help us determine how many times
00001322                           628              ;we have to iterate through addresses to print out the whole instruction
00001322                           629              ;We will use A4 as the register to temporary store the size
00001322  3842                     630              MOVE.W      D2,A4
00001324  11C2 2000                631              MOVE.B      D2,$2000
00001328                           632  
00001328                           633              ;Clear the register so we can reuse it
00001328  4282                     634              CLR.L       D2
0000132A                           635              
0000132A  3412                     636              MOVE.W      (A2),D2
0000132C                           637              
0000132C                           638              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
0000132C                           639              ;This is meant so we can use the copy to figure out the destination addressing mode
0000132C  264A                     640              MOVE.L      A2,A3
0000132E                           641  
0000132E  6000 0002                642              BRA         mSourceDest
00001332                           643              
00001332                           644            
00001332                           645  ;======Helper function to find the destination for MOVE======
00001332                           646  mSourceDest:
00001332                           647              ;SOURCE
00001332                           648              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001332  6100 0454                649              BSR        isolateAddressBit0to5
00001336                           650              
00001336                           651              ;Print source address
00001336  6100 04F0                652              BSR        addressModeSR
0000133A                           653              
0000133A                           654              ;Print the comma after the source address
0000133A  43F9 00001B39            655              LEA        printComma,A1
00001340  103C 000E                656              MOVE.B     #14,D0
00001344  4E4F                     657              TRAP       #15
00001346                           658              
00001346                           659              ;DESTINATION
00001346                           660              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001346  6100 000C                661              BSR        isolateAddressBit6to11
0000134A                           662              
0000134A                           663              ;Print destination address
0000134A  6100 04DC                664              BSR        addressModeSR
0000134E                           665              
0000134E  4283                     666              CLR.L      D3
00001350                           667              
00001350  6000 FEAA                668              BRA        update
00001354                           669              
00001354                           670  
00001354                           671  isolateAddressBit6to11:
00001354                           672              ;===Isolate the Destination Mode (M)Bits===
00001354  4282                     673              CLR.L      D2
00001356                           674              
00001356                           675              ;Copy the address value into a register
00001356  3413                     676              MOVE.W     (A3),D2
00001358                           677              
00001358                           678              ;Passing in parameters for isolating Mode bits
00001358  163C 0006                679              MOVE.B     #6,D3
0000135C  183C 0003                680              MOVE.B     #3,D4
00001360                           681              
00001360                           682              ;Jumps to getBits and returns with isolated bits in D2
00001360  4EB8 1212                683              JSR        getBits
00001364                           684              
00001364                           685              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001364  1C02                     686              MOVE.B     D2,D6
00001366                           687              
00001366                           688              ;===Isolate the Destination Address Register (Xn)Bits===
00001366  4282                     689              CLR.L      D2
00001368                           690              
00001368                           691              ;Copy the address values into a register
00001368  3413                     692              MOVE.W     (A3),D2
0000136A                           693              
0000136A                           694              ;Passing in parameters for isolating Xn bits
0000136A  163C 0009                695              MOVE.B     #9,D3
0000136E  183C 0003                696              MOVE.B     #3,D4
00001372                           697              
00001372                           698              ;Jumps to getBits and returns with isolated bits in D2
00001372  4EB8 1212                699              JSR        getBits
00001376                           700              
00001376                           701              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001376  1E02                     702              MOVE.B      D2,D7
00001378                           703  
00001378  4E75                     704              RTS
0000137A                           705              
0000137A                           706              
0000137A                           707  *-----------------------------------------------------------
0000137A                           708  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
0000137A                           709  *-----------------------------------------------------------
0000137A                           710  M0100:      
0000137A  4282                     711              CLR.L       D2
0000137C  4283                     712              CLR.L       D3
0000137E                           713              
0000137E                           714              ;--------------------------------------------------------
0000137E                           715              ;Check for LEA
0000137E                           716              ;--------------------------------------------------------
0000137E                           717              ;Copy the address values into a register to check for LEA
0000137E  3412                     718              MOVE.W     (A2),D2
00001380                           719              
00001380                           720              ;Passing in parameters for isolating bits 6,7,8
00001380  163C 0006                721              MOVE.B      #6,D3             ;Start bit index = 6
00001384  183C 0003                722              MOVE.B      #3,D4             ;Number of bits needed = 3
00001388                           723              
00001388                           724              ;Jumps to getBits and returns with isolated bits in D2
00001388  6100 FE88                725              BSR         getBits
0000138C                           726  
0000138C  B43C 0007                727              CMP.B       #%111,D2
00001390  6700 0056                728              BEQ         MLEA
00001394                           729  
00001394                           730              ;--------------------------------------------------------
00001394                           731              ;Check for NOT
00001394                           732              ;--------------------------------------------------------
00001394                           733              ;Clear D2 and recopy it to check for NOT
00001394  4282                     734              CLR.L       D2
00001396  3412                     735              MOVE.W      (A2),D2
00001398                           736              
00001398                           737              ;Pass in parameters for isolating bits 8,9,10,11
00001398  163C 0008                738              MOVE.B      #8,D3
0000139C  183C 0004                739              MOVE.B      #4,D4
000013A0                           740              
000013A0                           741              ;Jumps to getBits and returns with isolated bits in D2
000013A0  6100 FE70                742              BSR         getBits
000013A4                           743              
000013A4  B43C 0006                744              CMP.B       #%0110,D2
000013A8  6700 006E                745              BEQ         MNOT      
000013AC                           746              
000013AC                           747              ;--------------------------------------------------------
000013AC                           748              ;Check for JSR
000013AC                           749              ;--------------------------------------------------------
000013AC                           750              ;Clear D2 and recopy it to check for JSR
000013AC  4282                     751              CLR.L       D2
000013AE  3412                     752              MOVE.W     (A2),D2
000013B0                           753              
000013B0                           754              ;Pass in parameters for isolating bits 6-11
000013B0  163C 0006                755              MOVE.B      #6,D3
000013B4  183C 0006                756              MOVE.B      #6,D4
000013B8                           757              
000013B8                           758              ;Jumps to getBits and returns with isolated bits in D2
000013B8  6100 FE58                759              BSR         getBits
000013BC                           760              
000013BC  B43C 003A                761              CMP.B       #%111010,D2
000013C0  6700 0082                762              BEQ         MJSR
000013C4                           763              
000013C4                           764              ;--------------------------------------------------------
000013C4                           765              ;Check for MOVEM
000013C4                           766              ;--------------------------------------------------------
000013C4                           767              ;Clear D2 and recopy it to check for MOVEM
000013C4  4282                     768              CLR.L       D2
000013C6  3412                     769              MOVE.W     (A2),D2
000013C8                           770              
000013C8                           771              ;Pass in parameters for isolating bit 9
000013C8  163C 0009                772              MOVE.B      #9,D3
000013CC  183C 0001                773              MOVE.B      #1,D4
000013D0                           774              
000013D0                           775              ;Jumps to getBits and returns with isolated bits in D2
000013D0  6100 FE40                776              BSR         getBits
000013D4                           777              
000013D4  B43C 0000                778              CMP.B       #%0,D2
000013D8  6700 0002                779              BEQ         MOVEM
000013DC                           780              
000013DC                           781         
000013DC                           782  MOVEM:
000013DC                           783              *******************
000013DC                           784              *Must finish!!!!!!
000013DC                           785              *******************
000013DC  43F9 00001A79            786              LEA         printMOVEM,A1
000013E2  1038 0014                787              MOVE.B      $14,D0
000013E6  4E4F                     788              TRAP        #15
000013E8                           789  
000013E8                           790  
000013E8                           791  MLEA:
000013E8  43F9 00001AAF            792              LEA         printLEA,A1
000013EE  103C 000E                793              MOVE.B      #14,D0
000013F2  4E4F                     794              TRAP        #15
000013F4                           795              
000013F4                           796              ;*SOURCE*
000013F4                           797              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000013F4                           798              ;D6 will contain mode & D7 will contain the register after this instruction
000013F4  6100 0392                799              BSR         isolateAddressBit0to5
000013F8                           800              
000013F8                           801              ;*Print source address*
000013F8  6100 042E                802              BSR         addressModeSR
000013FC                           803              
000013FC                           804              ;Print comma after source address
000013FC  43F9 00001B39            805              LEA         printComma,A1
00001402  103C 000E                806              MOVE.B      #14,D0
00001406  4E4F                     807              TRAP        #15
00001408                           808              
00001408                           809              ;*DESTINATION*
00001408                           810              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001408                           811              ;D7 will contain the register after this instruction
00001408  6100 03A4                812              BSR         isolateRegisterBit9to11
0000140C                           813              
0000140C                           814              ;Save #%001 into D6 to specify address register mode
0000140C  1C3C 0001                815              MOVE.B      #1,D6
00001410                           816              
00001410                           817              
00001410                           818              ;*Print destination address*
00001410  6100 0416                819              BSR         addressModeSR
00001414                           820  
00001414  6000 FDE6                821              BRA        update
00001418                           822  
00001418                           823  MNOT:
00001418  43F9 00001ABC            824              LEA        printNOT,A1
0000141E  103C 000E                825              MOVE.B     #14,D0
00001422  4E4F                     826              TRAP       #15
00001424                           827              
00001424  4282                     828              CLR.L      D2
00001426                           829              ;Move the address into the register to check for size
00001426  3412                     830              MOVE.W     (A2),D2
00001428                           831              
00001428                           832              ;Pass in parameters for isolating bits 6,7
00001428  163C 0006                833              MOVE.B     #6,D3
0000142C  183C 0002                834              MOVE.B     #2,D4
00001430                           835              
00001430                           836              ;Jump to getbits and return with isolated bits
00001430  6100 FDE0                837              BSR        getbits          
00001434                           838              
00001434                           839              ;Jumps to printSizeSubroutine and returns after size has been printed
00001434  6100 0390                840              BSR        printSizeSubroutine
00001438                           841              
00001438                           842              ;*SOURCE*
00001438                           843              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001438                           844              ;D6 will contain mode & D7 will contain the register after this instruction
00001438  6100 034E                845              BSR        isolateAddressBit0to5
0000143C                           846              
0000143C                           847              ;*Print source address*
0000143C  6100 03EA                848              BSR        addressModeSR
00001440                           849              
00001440  6000 FDBA                850              BRA        update 
00001444                           851  
00001444                           852  MJSR:
00001444  43F9 00001AEC            853              LEA        printJSR,A1
0000144A  103C 000E                854              MOVE.B     #14,D0
0000144E  4E4F                     855              TRAP       #15
00001450                           856              
00001450                           857              ;*SOURCE*
00001450                           858              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001450                           859              ;D6 will contain mode & D7 will contain the register after this instruction
00001450  6100 0336                860              BSR        isolateAddressBit0to5
00001454                           861              
00001454                           862              ;*Print source address*
00001454  6100 03D2                863              BSR        addressModeSR
00001458                           864              
00001458  6000 FDA2                865              BRA        update 
0000145C                           866              
0000145C                           867  
0000145C                           868  *-----------------------------------------------------------
0000145C                           869  * BRA,BLT,BGE,BEQ INSTRUCTIONS
0000145C                           870  *-----------------------------------------------------------       
0000145C                           871  M0110:
0000145C                           872              ;
0000145C                           873  MBRA:
0000145C                           874  MBLT:
0000145C                           875  MBGE:
0000145C                           876  MBEQ:            
0000145C                           877              
0000145C                           878  
0000145C                           879  *-----------------------------------------------------------
0000145C                           880  * DIVU INSTRUCTION
0000145C                           881  *-----------------------------------------------------------           
0000145C                           882  M1000:
0000145C                           883              
0000145C  4282                     884              CLR.L       D2
0000145E  4283                     885              CLR.L       D3
00001460                           886              
00001460                           887              ;Copy the address values into a register
00001460  3412                     888              MOVE.W     (A2),D2
00001462                           889              
00001462                           890              ;Passing in parameters for isolating bits 6,7,8
00001462  163C 0006                891              MOVE.B      #6,D3             ;Start bit index = 6
00001466  183C 0003                892              MOVE.B      #3,D4             ;Number of bits needed = 3
0000146A                           893              
0000146A                           894              ;Jumps to getBits and returns with isolated bits in D2
0000146A  6100 FDA6                895              BSR         getBits
0000146E                           896              
0000146E                           897              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
0000146E  B4BC 00000003            898              CMP.L       #%011,D2
00001474  6700 0002                899              BEQ         continueDIVU
00001478                           900              
00001478                           901              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
00001478                           902  
00001478                           903  continueDIVU:
00001478                           904  
00001478  43F9 00001AA5            905              LEA         printDIVU,A1
0000147E  103C 000E                906              MOVE.B      #14,D0
00001482  4E4F                     907              TRAP        #15
00001484                           908              
00001484  6000 02BA                909              BRA         dnDest
00001488                           910              
00001488                           911              
00001488                           912  *-----------------------------------------------------------
00001488                           913  * SUB INSTRUCTION
00001488                           914  *-----------------------------------------------------------  
00001488                           915  M1001:
00001488  43F9 00001A8E            916              LEA        printSUB,A1
0000148E  103C 000E                917              MOVE.B     #14,D0
00001492  4E4F                     918              TRAP       #15
00001494                           919              
00001494  4202                     920              CLR.B      D2
00001496  4203                     921              CLR.B      D3
00001498                           922              
00001498                           923              ;======Isolate Size (S) Bits=======
00001498                           924              ;Copy the address values into a register
00001498  3412                     925              MOVE.W     (A2),D2
0000149A                           926              
0000149A                           927              ;Passing in parameters for isolating size bits
0000149A  163C 0006                928              MOVE.B      #6,D3             ;Start bit index = 6
0000149E  183C 0002                929              MOVE.B      #2,D4             ;Number of bits needed = 2
000014A2                           930              
000014A2                           931              ;Jumps to getBits and returns with isolated bits in D2
000014A2  6100 FD6E                932              BSR         getBits  
000014A6                           933              
000014A6                           934              ;Jumps to printSizeSubroutine and returns after size has been printed
000014A6  6100 031E                935              BSR         printSizeSubroutine
000014AA                           936              
000014AA                           937              ;Let's store the size indicator since it will help us determine how many times
000014AA                           938              ;we have to iterate through addresses to print out the whole instruction
000014AA                           939              ;We will use A4 as the register to temporary store the size
000014AA  3842                     940              MOVE.W      D2,A4
000014AC  11C2 2000                941              MOVE.B      D2,$2000
000014B0                           942              
000014B0                           943              ;======Isolate direction (D) Bit=======
000014B0                           944              ; 0 = data register is destination | 1 = Dn is source
000014B0  4282                     945              CLR.L       D2
000014B2                           946              
000014B2                           947              ;Copy the address values into a register
000014B2  3412                     948              MOVE.W      (A2),D2
000014B4                           949              
000014B4                           950              ;Passing in parameters for isolating direction bit
000014B4  163C 0008                951              MOVE.B      #8,D3             ;Start bit index = 8
000014B8  183C 0001                952              MOVE.B      #1,D4             ;Number of bits needed = 1
000014BC                           953              
000014BC                           954              ;Jumps to getBits and returns with isolated bit in D2
000014BC  6100 FD54                955              BSR         getBits
000014C0                           956              
000014C0                           957              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000014C0  B43C 0000                958              CMP.B       #0,D2
000014C4  6700 027A                959              BEQ         dnDest
000014C8  6000 029A                960              BRA         dnSource
000014CC                           961  
000014CC                           962  
000014CC                           963  *-----------------------------------------------------------
000014CC                           964  * MULS,AND INSTRUCTIONS
000014CC                           965  *-----------------------------------------------------------  
000014CC                           966  M1100:      
000014CC  4282                     967              CLR.L       D2
000014CE  4283                     968              CLR.L       D3
000014D0                           969              
000014D0                           970              ;Copy the address values into a register
000014D0  3412                     971              MOVE.W     (A2),D2
000014D2                           972              
000014D2                           973              ;Passing in parameters for isolating bits 6 and 7
000014D2  163C 0006                974              MOVE.B      #6,D3             ;Start bit index = 6
000014D6  183C 0002                975              MOVE.B      #2,D4             ;Number of bits needed = 2
000014DA                           976              
000014DA                           977              ;Jumps to getBits and returns with isolated bits in D2
000014DA  6100 FD36                978              BSR         getBits  
000014DE                           979              
000014DE                           980              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
000014DE  B43C 0003                981              CMP.B       #%11,D2
000014E2  6700 0006                982              BEQ         mulsCheck
000014E6  6000 0028                983              BRA         MAND
000014EA                           984              
000014EA                           985  mulsCheck:
000014EA                           986              ;Copy the address values into a register
000014EA  3412                     987              MOVE.W     (A2),D2
000014EC                           988              
000014EC                           989              ;Passing in parameters for isolating bit 8
000014EC  163C 0008                990              MOVE.B      #8,D3             ;Start bit index = 8
000014F0  183C 0001                991              MOVE.B      #1,D4             ;Number of bits needed = 1
000014F4                           992              
000014F4                           993              ;Jumps to getBits and returns with isolated bits in D2
000014F4  6100 FD1C                994              BSR         getBits 
000014F8                           995              
000014F8                           996              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
000014F8  B43C 0001                997              CMP.B       #1,D2
000014FC  6700 0002                998              BEQ         MMULS
00001500                           999              
00001500                          1000              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001500                          1001  
00001500                          1002              
00001500                          1003              
00001500                          1004              
00001500                          1005  MMULS:
00001500  43F9 00001A9B           1006              LEA         printMULS,A1
00001506  103C 000E               1007              MOVE.B      #14,D0
0000150A  4E4F                    1008              TRAP        #15
0000150C                          1009              
0000150C  6000 0232               1010              BRA         dnDest 
00001510                          1011  
00001510                          1012  
00001510                          1013  MAND:
00001510  43F9 00001AB6           1014              LEA        printAND,A1
00001516  103C 000E               1015              MOVE.B     #14,D0
0000151A  4E4F                    1016              TRAP       #15
0000151C                          1017              
0000151C                          1018              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
0000151C                          1019              ;Jumps to printSizeSubroutine and returns after size has been printed
0000151C  6100 02A8               1020              BSR         printSizeSubroutine
00001520                          1021              
00001520                          1022              ;======Isolate direction (D) Bit=======
00001520                          1023              ; 0 = data register is destination | 1 = Dn is source
00001520  4282                    1024              CLR.L       D2
00001522                          1025              
00001522                          1026              ;Copy the address values into a register
00001522  3412                    1027              MOVE.W      (A2),D2
00001524                          1028              
00001524                          1029              ;Passing in parameters for isolating direction bit
00001524  163C 0008               1030              MOVE.B      #8,D3           ;Start bit index = 8
00001528  183C 0001               1031              MOVE.B      #1,D4           ;Number of bits needed = 1
0000152C                          1032  
0000152C                          1033              ;Jumps to getBits and returns with isolated bit in D2
0000152C  6100 FCE4               1034              BSR         getBits
00001530                          1035              
00001530                          1036              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001530  B43C 0000               1037              CMP.B       #0,D2
00001534  6700 020A               1038              BEQ         dnDest
00001538  6000 022A               1039              BRA         dnSource
0000153C                          1040              
0000153C                          1041              
0000153C  6000 FCBE               1042              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001540                          1043     
00001540                          1044     
00001540                          1045  *-----------------------------------------------------------
00001540                          1046  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001540                          1047  *-----------------------------------------------------------  
00001540                          1048  M1110:
00001540  4282                    1049              CLR.L       D2
00001542  4283                    1050              CLR.L       D3
00001544                          1051              
00001544                          1052              ;Copy the address values into a register
00001544  3412                    1053              MOVE.W     (A2),D2
00001546                          1054              
00001546                          1055              ;Passing in parameters for isolating bits 6-7
00001546  163C 0006               1056              MOVE.B      #6,D3             ;Start bit index = 6
0000154A  183C 0002               1057              MOVE.B      #2,D4             ;Number of bits needed = 2
0000154E                          1058              
0000154E                          1059              ;Jumps to getBits and returns with isolated bits in D2
0000154E  6100 FCC2               1060              BSR         getBits  
00001552                          1061              
00001552                          1062              ;Check if Memory Shift
00001552  B43C 0003               1063              CMP.B       #%11,D2
00001556  6700 00B8               1064              BEQ         MemShift
0000155A                          1065              
0000155A                          1066              ;If not Memory Shift, is a Register Shift
0000155A                          1067              
0000155A                          1068              ;Copy the address values into a register
0000155A  3412                    1069              MOVE.W     (A2),D2
0000155C                          1070              
0000155C                          1071              ;Passing in parameters for isolating bit 3
0000155C  163C 0003               1072              MOVE.B      #3,D3             ;Start bit index = 3
00001560  183C 0001               1073              MOVE.B      #1,D4             ;Number of bits needed = 1
00001564                          1074              
00001564                          1075              ;Jumps to getBits and returns with isolated bits in D2
00001564  6100 FCAC               1076              BSR         getBits  
00001568                          1077              
00001568                          1078              ;Checks if ASd
00001568  B43C 0000               1079              CMP.B       #%0,D2
0000156C  6700 00E8               1080              BEQ         RegAS
00001570                          1081              
00001570                          1082              ;Checks if LSd
00001570  B43C 0001               1083              CMP.B       #%1,D2
00001574  6700 00E8               1084              BEQ         RegLS
00001578                          1085  RegShift      
00001578                          1086              ;Copy the address values into a register
00001578  3412                    1087              MOVE.W     (A2),D2
0000157A                          1088              
0000157A                          1089              ;Passing in parameters for isolating bits 6-7
0000157A  163C 0006               1090              MOVE.B      #6,D3             ;Start bit index = 6
0000157E  183C 0002               1091              MOVE.B      #2,D4             ;Number of bits needed = 2
00001582                          1092              
00001582                          1093              ;Jumps to getBits and returns with isolated bits in D2
00001582  6100 FC8E               1094              BSR         getBits  
00001586                          1095              
00001586                          1096              ;Print Size
00001586  6100 023E               1097              BSR         printSizeSubroutine
0000158A                          1098              
0000158A                          1099              ;Copy the address values into a register
0000158A  3412                    1100              MOVE.W     (A2),D2
0000158C                          1101              
0000158C                          1102              ;Passing in parameters for isolating bit 5
0000158C  163C 0005               1103              MOVE.B      #5,D3             ;Start bit index = 5
00001590  183C 0001               1104              MOVE.B      #1,D4             ;Number of bits needed = 1
00001594                          1105              
00001594                          1106              ;Jumps to getBits and returns with isolated bits in D2
00001594  6100 FC7C               1107              BSR         getBits  
00001598                          1108              
00001598                          1109              ;Checks if shift count is immediate
00001598  B43C 0000               1110              CMP.B       #%0,D2
0000159C  6700 003C               1111              BEQ         ImmediateCount
000015A0                          1112              
000015A0                          1113              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000015A0                          1114              ;D7 will contain the register after this instruction
000015A0  6100 020C               1115              BSR         isolateRegisterBit9to11
000015A4                          1116              
000015A4                          1117              ;Save #%000 into D6 to specify data register mode
000015A4  1C3C 0000               1118              MOVE.B      #0,D6
000015A8                          1119              
000015A8                          1120              ;*Print Shift Count address*
000015A8  6100 027E               1121              BSR         addressModeSR
000015AC                          1122  
000015AC  6100 0002               1123              BSR         RegShift2
000015B0                          1124  
000015B0                          1125  RegShift2   ;Print comma after shift count
000015B0  43F9 00001B39           1126              LEA         printComma,A1
000015B6  103C 000E               1127              MOVE.B      #14,D0
000015BA  4E4F                    1128              TRAP        #15
000015BC                          1129              
000015BC                          1130              ;*Data Register to be Shifted*
000015BC  4282                    1131              CLR.L       D2
000015BE                          1132              
000015BE                          1133              ;Copy the address values into a register
000015BE  3412                    1134              MOVE.W      (A2),D2
000015C0                          1135              
000015C0                          1136              ;Passing in parameters for isolating bits 0-2
000015C0  163C 0000               1137              MOVE.B      #0,D3             ;Start bit index = 0
000015C4  183C 0003               1138              MOVE.B      #3,D4             ;Number of bits needed = 3
000015C8                          1139              
000015C8                          1140              ;Jumps to getBits and returns with isolated bits in D2
000015C8  6100 FC48               1141              BSR         getBits
000015CC                          1142              
000015CC                          1143              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000015CC  1E02                    1144              MOVE.B      D2,D7
000015CE                          1145              
000015CE                          1146              ;Save #%000 into D6 to specify data register mode
000015CE  1C3C 0000               1147              MOVE.B      #0,D6
000015D2                          1148              
000015D2                          1149              ;*Prints data register to be shifted*
000015D2  6100 0254               1150              BSR         addressModeSR
000015D6                          1151  
000015D6  6000 FC24               1152              BRA         update
000015DA                          1153              
000015DA                          1154  ImmediateCount
000015DA                          1155              ;Print #$
000015DA  43F9 00001B29           1156              LEA        printIA,A1
000015E0  103C 000E               1157              MOVE.B     #14,D0
000015E4  4E4F                    1158              TRAP       #15
000015E6                          1159              
000015E6                          1160              ;Copy the address values into a register
000015E6  3412                    1161              MOVE.W     (A2),D2
000015E8                          1162              
000015E8                          1163              ;Passing in parameters for isolating bits 9-11
000015E8  163C 0009               1164              MOVE.B      #9,D3             ;Start bit index = 9
000015EC  183C 0003               1165              MOVE.B      #3,D4             ;Number of bits needed = 3
000015F0                          1166              
000015F0                          1167              ;Jumps to getBits and returns with isolated bits in D2
000015F0  6100 FC20               1168              BSR         getBits  
000015F4                          1169              
000015F4                          1170              ;Check if shift count is 8
000015F4  B43C 0000               1171              CMP.B       #%000,D2
000015F8  6700 0010               1172              BEQ         ShiftEight
000015FC                          1173              
000015FC  1202                    1174              MOVE.B      D2, D1
000015FE  6100 0002               1175              BSR         ImmediateCount2
00001602                          1176             
00001602                          1177  ImmediateCount2
00001602                          1178              ;Print shift count
00001602  103C 0003               1179              MOVE.B      #3,D0
00001606  4E4F                    1180              TRAP        #15
00001608  61A6                    1181              BSR         RegShift2
0000160A                          1182   
0000160A                          1183  ShiftEight  ;Move 8 into D1    
0000160A  123C 0008               1184              MOVE.B      #8, D1
0000160E  61F2                    1185              BSR         ImmediateCount2
00001610                          1186                                     
00001610                          1187  MemShift
00001610                          1188              ;Copy the address values into a register
00001610  3412                    1189              MOVE.W     (A2),D2
00001612                          1190              
00001612                          1191              ;Passing in parameters for isolating bit 9
00001612  163C 0009               1192              MOVE.B      #9,D3             ;Start bit index = 9
00001616  183C 0001               1193              MOVE.B      #1,D4             ;Number of bits needed = 1
0000161A                          1194              
0000161A                          1195              ;Jumps to getBits and returns with isolated bits in D2
0000161A  6100 FBF6               1196              BSR         getBits  
0000161E                          1197              
0000161E                          1198              ;Checks if ASd
0000161E  B43C 0000               1199              CMP.B       #%0,D2
00001622  6700 0022               1200              BEQ         MemAS
00001626                          1201              
00001626                          1202              ;Checks if LSd
00001626  B43C 0001               1203              CMP.B       #%1,D2
0000162A  6700 0022               1204              BEQ         MemLS
0000162E                          1205  
0000162E                          1206  MemShift2   
0000162E                          1207              ;Print Space
0000162E  43F9 00001B3B           1208              LEA        printSpace,A1
00001634  103C 000E               1209              MOVE.B     #14,D0
00001638  4E4F                    1210              TRAP       #15
0000163A                          1211              
0000163A                          1212              ;*Memory Address*
0000163A                          1213              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000163A                          1214              ;D6 will contain mode & D7 will contain the register after this instruction
0000163A  6100 014C               1215              BSR         isolateAddressBit0to5
0000163E                          1216              
0000163E                          1217              ;*Print source address*
0000163E  6100 01E8               1218              BSR         addressModeSR
00001642                          1219              
00001642  6000 FBB8               1220              BRA         update
00001646                          1221              
00001646                          1222  MemAS       ;Print AS
00001646  6100 002C               1223              BSR         MAS      
0000164A  6100 0036               1224              BSR         MemDirectionSubroutine                
0000164E                          1225  
0000164E                          1226              
0000164E                          1227  MemLS       ;Print LS
0000164E  6100 0016               1228              BSR         MLS      
00001652  6100 002E               1229              BSR         MemDirectionSubroutine
00001656                          1230              
00001656                          1231  RegAS       ;Print AS
00001656  6100 001C               1232              BSR         MAS      
0000165A  6100 0062               1233              BSR         RegDirectionSubroutine                
0000165E                          1234  
0000165E                          1235              
0000165E                          1236  RegLS       ;Print LS
0000165E  6100 0006               1237              BSR         MLS      
00001662  6100 005A               1238              BSR         RegDirectionSubroutine
00001666                          1239  
00001666                          1240  MLS:
00001666  43F9 00001B04           1241              LEA        printMLS,A1
0000166C  103C 000E               1242              MOVE.B     #14,D0
00001670  4E4F                    1243              TRAP       #15
00001672  4E75                    1244              RTS
00001674                          1245  MAS:
00001674  43F9 00001AFF           1246              LEA        printMAS,A1
0000167A  103C 000E               1247              MOVE.B     #14,D0
0000167E  4E4F                    1248              TRAP       #15
00001680  4E75                    1249              RTS
00001682                          1250  
00001682                          1251  MemDirectionSubroutine
00001682                          1252              ;Copy the address values into a register
00001682  3412                    1253              MOVE.W     (A2),D2
00001684                          1254              
00001684                          1255              ;Passing in parameters for isolating bit 8
00001684  163C 0008               1256              MOVE.B      #8,D3             ;Start bit index = 8
00001688  183C 0001               1257              MOVE.B      #1,D4             ;Number of bits needed = 1
0000168C                          1258              
0000168C                          1259              ;Jumps to getBits and returns with isolated bits in D2
0000168C  6100 FB84               1260              BSR         getBits  
00001690                          1261              
00001690                          1262              ;Checks if Right
00001690  B43C 0000               1263              CMP.B       #%0,D2
00001694  6700 000A               1264              BEQ         MR
00001698                          1265              
00001698                          1266              ;Checks if Left
00001698  B43C 0001               1267              CMP.B       #%1,D2
0000169C  6700 0010               1268              BEQ         ML
000016A0                          1269                          
000016A0  43F9 00001B0B           1270  MR          LEA        printR,A1
000016A6  103C 000E               1271              MOVE.B     #14,D0
000016AA  4E4F                    1272              TRAP       #15
000016AC  6180                    1273              BSR        MemShift2
000016AE                          1274  
000016AE  43F9 00001B09           1275  ML          LEA        printL,A1
000016B4  103C 000E               1276              MOVE.B     #14,D0
000016B8  4E4F                    1277              TRAP       #15
000016BA  6100 FF72               1278              BSR        MemShift2
000016BE                          1279              
000016BE                          1280  RegDirectionSubroutine
000016BE                          1281              ;Copy the address values into a register
000016BE  3412                    1282              MOVE.W     (A2),D2
000016C0                          1283              
000016C0                          1284              ;Passing in parameters for isolating bit 8
000016C0  163C 0008               1285              MOVE.B      #8,D3             ;Start bit index = 8
000016C4  183C 0001               1286              MOVE.B      #1,D4             ;Number of bits needed = 1
000016C8                          1287              
000016C8                          1288              ;Jumps to getBits and returns with isolated bits in D2
000016C8  6100 FB48               1289              BSR         getBits  
000016CC                          1290              
000016CC                          1291              ;Checks if Right
000016CC  B43C 0000               1292              CMP.B       #%0,D2
000016D0  6700 000A               1293              BEQ         RR
000016D4                          1294              
000016D4                          1295              ;Checks if Left
000016D4  B43C 0001               1296              CMP.B       #%1,D2
000016D8  6700 0012               1297              BEQ         RL
000016DC                          1298                          
000016DC  43F9 00001B0B           1299  RR          LEA        printR,A1
000016E2  103C 000E               1300              MOVE.B     #14,D0
000016E6  4E4F                    1301              TRAP       #15
000016E8  6100 FE8E               1302              BSR        RegShift
000016EC                          1303  
000016EC  43F9 00001B09           1304  RL          LEA        printL,A1
000016F2  103C 000E               1305              MOVE.B     #14,D0
000016F6  4E4F                    1306              TRAP       #15
000016F8  6100 FE7E               1307              BSR        RegShift
000016FC                          1308  
000016FC                          1309  
000016FC                          1310  *-----------------------------------------------------------------------
000016FC                          1311  *-----------------------------------------------------------------------
000016FC                          1312  *-----------------------------------------------------------------------
000016FC                          1313  
000016FC                          1314  
000016FC                          1315  
000016FC                          1316  
000016FC                          1317  ;ADD
000016FC                          1318  M1101:
000016FC  43F9 00001A81           1319              LEA        printADD,A1
00001702  103C 000E               1320              MOVE.B     #14,D0
00001706  4E4F                    1321              TRAP       #15
00001708                          1322              
00001708  4202                    1323              CLR.B      D2
0000170A  4203                    1324              CLR.B      D3
0000170C                          1325              
0000170C                          1326              ;======Isolate Size (S) Bits=======
0000170C                          1327              ;Copy the address values into a register
0000170C  3412                    1328              MOVE.W     (A2),D2
0000170E                          1329              
0000170E                          1330              ;Passing in parameters for isolating size bits
0000170E  163C 0006               1331              MOVE.B      #6,D3             ;Start bit index = 6
00001712  183C 0002               1332              MOVE.B      #2,D4             ;Number of bits needed = 2
00001716                          1333              
00001716                          1334              ;Jumps to getBits and returns with isolated bits in D2
00001716  6100 FAFA               1335              BSR         getBits  
0000171A                          1336              
0000171A                          1337              ;Jumps to printSizeSubroutine and returns after size has been printed
0000171A  6100 00AA               1338              BSR         printSizeSubroutine
0000171E                          1339         
0000171E                          1340              ;Let's store the size indicator since it will help us determine how many times
0000171E                          1341              ;we have to iterate through addresses to print out the whole instruction
0000171E                          1342              ;We will use A4 as the register to temporary store the size
0000171E  3842                    1343              MOVE.W      D2,A4
00001720  11C2 2000               1344              MOVE.B      D2,$2000
00001724                          1345              
00001724                          1346              ;======Isolate direction (D) Bit=======
00001724                          1347              ; 0 = data register is destination | 1 = Dn is source
00001724  4282                    1348              CLR.L       D2
00001726                          1349              
00001726                          1350              ;Copy the address values into a register
00001726  3412                    1351              MOVE.W      (A2),D2
00001728                          1352              
00001728                          1353              ;Passing in parameters for isolating direction bit
00001728  163C 0008               1354              MOVE.B      #8,D3             ;Start bit index = 8
0000172C  183C 0001               1355              MOVE.B      #1,D4             ;Number of bits needed = 1
00001730                          1356              
00001730                          1357              ;Jumps to getBits and returns with isolated bit in D2
00001730  6100 FAE0               1358              BSR         getBits
00001734                          1359              
00001734                          1360              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001734  B43C 0000               1361              CMP.B       #0,D2
00001738  6700 0006               1362              BEQ         dnDest
0000173C  6000 0026               1363              BRA         dnSource
00001740                          1364              
00001740                          1365  
00001740                          1366  *-----------------------------------------------------------------
00001740                          1367  * dnDest, dnSource, & other subroutines for isolating address bits
00001740                          1368  *-----------------------------------------------------------------
00001740                          1369  ;* dnDest,dnSource *
00001740                          1370  ;For: MULS,AND,ADD,SUB,DIVU
00001740                          1371  ;Used by instructions that require Dn as one of their addressing modes.
00001740                          1372  ;dnDest isolates the addressing bits with Dn being the destination address
00001740                          1373  ;dnSource isolates the addressing bits with Dn being the source address
00001740                          1374  
00001740                          1375  dnDest:
00001740                          1376              ;**Used for isolating addressing bits when Dn is the destination**
00001740                          1377              
00001740                          1378              ;*SOURCE*
00001740                          1379              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001740                          1380              ;D6 will contain mode & D7 will contain the register after this instruction
00001740  6100 0046               1381              BSR         isolateAddressBit0to5
00001744                          1382              
00001744                          1383              ;*Print source address*
00001744  6100 00E2               1384              BSR         addressModeSR
00001748                          1385              
00001748                          1386              ;Print comma after source address
00001748  43F9 00001B39           1387              LEA         printComma,A1
0000174E  103C 000E               1388              MOVE.B      #14,D0
00001752  4E4F                    1389              TRAP        #15
00001754                          1390              
00001754                          1391              ;*DESTINATION*
00001754                          1392              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001754                          1393              ;D7 will contain the register after this instruction
00001754  6100 0058               1394              BSR         isolateRegisterBit9to11
00001758                          1395              
00001758                          1396              ;Save #%000 into D6 to specify data register mode
00001758  1C3C 0000               1397              MOVE.B      #0,D6
0000175C                          1398              
0000175C                          1399              ;*Print destination address*
0000175C  6100 00CA               1400              BSR         addressModeSR
00001760                          1401  
00001760  6000 FA9A               1402              BRA         update
00001764                          1403              
00001764                          1404  dnSource:
00001764                          1405              ;**Used for isolating addressing bits when Dn is the destination**
00001764                          1406                          
00001764                          1407              ;*SOURCE*
00001764                          1408              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001764                          1409              ;D7 will contain the register after this instruction
00001764  6100 0048               1410              BSR         isolateRegisterBit9to11
00001768                          1411              
00001768                          1412              ;Save #%000 into D6 to specify data register mode
00001768  1C3C 0000               1413              MOVE.B      #0,D6
0000176C                          1414              
0000176C                          1415              ;*Print Source address*
0000176C  6100 00BA               1416              BSR         addressModeSR
00001770                          1417              
00001770                          1418              ;Print comma after source address
00001770  43F9 00001B39           1419              LEA         printComma,A1
00001776  103C 000E               1420              MOVE.B      #14,D0
0000177A  4E4F                    1421              TRAP        #15
0000177C                          1422              
0000177C                          1423              ;*DESTINATION*
0000177C                          1424              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000177C                          1425              ;D6 will contain mode & D7 will contain the register after this instruction
0000177C  6100 000A               1426              BSR         isolateAddressBit0to5
00001780                          1427              
00001780                          1428              ;*Print destination address*
00001780  6100 00A6               1429              BSR         addressModeSR
00001784                          1430  
00001784  6000 FA76               1431              BRA         update
00001788                          1432                     
00001788                          1433  isolateAddressBit0to5:
00001788                          1434  ;Helper subroutine for isolating the address stored within bits 0-5
00001788                          1435  ;Stores address mode in D6
00001788                          1436  ;Stores address register in D7
00001788                          1437  
00001788                          1438              ;======Isolate Effective Address Mode (M) Bits=======
00001788  4282                    1439              CLR.L       D2
0000178A                          1440              
0000178A                          1441              ;Copy the address values into a register
0000178A  3412                    1442              MOVE.W      (A2),D2
0000178C                          1443              
0000178C                          1444              ;Passing in parameters for isolating Mode bits
0000178C  163C 0003               1445              MOVE.B      #3,D3             ;Start bit index = 3
00001790  183C 0003               1446              MOVE.B      #3,D4             ;Number of bits needed = 3
00001794                          1447              
00001794                          1448              ;Jumps to getBits and returns with isolated bits in D2
00001794  4EB8 1212               1449              JSR         getBits
00001798                          1450              
00001798                          1451              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001798  1C02                    1452              MOVE.B      D2,D6
0000179A                          1453              
0000179A                          1454                       
0000179A                          1455              ;======Isolate Effective Address Register (Xn) Bits=======
0000179A  4282                    1456              CLR.L       D2
0000179C                          1457              
0000179C                          1458              ;Copy the address values into a register
0000179C  3412                    1459              MOVE.W      (A2),D2
0000179E                          1460              
0000179E                          1461              ;Passing in parameters for isolating Xn bits
0000179E  163C 0000               1462              MOVE.B      #0,D3             ;Start bit index = 0
000017A2  183C 0003               1463              MOVE.B      #3,D4             ;Number of bits needed = 3
000017A6                          1464              
000017A6                          1465              ;Jumps to getBits and returns with isolated bits in D2
000017A6  6100 FA6A               1466              BSR         getBits
000017AA                          1467              
000017AA                          1468              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000017AA  1E02                    1469              MOVE.B      D2,D7
000017AC                          1470              
000017AC  4E75                    1471              RTS
000017AE                          1472  
000017AE                          1473  isolateRegisterBit9to11:
000017AE                          1474  ;Helper subroutine for isolating the register stored within bits 9-11
000017AE                          1475  ;Stores the address register in D7
000017AE                          1476  
000017AE                          1477              ;======Isolate Register Bits=======
000017AE  4282                    1478              CLR.L       D2
000017B0  4286                    1479              CLR.L       D6
000017B2  4287                    1480              CLR.L       D7
000017B4                          1481              
000017B4                          1482              ;Copy the address values into a register
000017B4  3412                    1483              MOVE.W      (A2),D2
000017B6                          1484              
000017B6                          1485              ;Passing in parameters for isolating register bits
000017B6  163C 0009               1486              MOVE.B      #9,D3             ;Start bit index = 9
000017BA  183C 0003               1487              MOVE.B      #3,D4             ;Number of bits needed = 3
000017BE                          1488              
000017BE                          1489              ;Jumps to getBits and returns with isolated bit in D2
000017BE  6100 FA52               1490              BSR         getBits
000017C2                          1491              
000017C2                          1492              ;Save register bit into ***D7*** for later use in addressModeSR
000017C2  1E02                    1493              MOVE.B      D2,D7
000017C4                          1494  
000017C4  4E75                    1495              RTS
000017C6                          1496              
000017C6                          1497  *-----------------------------------------------------------
000017C6                          1498  * Print Sizes
000017C6                          1499  *-----------------------------------------------------------
000017C6                          1500  printSizeSubroutine:
000017C6                          1501              ;Prints the apporpriate size
000017C6                          1502              ;PARAMETER:
000017C6                          1503              ;D2 = the size bits
000017C6                          1504              
000017C6                          1505              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
000017C6  B63C 0001               1506              CMP.B      #1,D3
000017CA  6700 001A               1507              BEQ        printMOVESize
000017CE                          1508              
000017CE                          1509              ;Compare to which size is being moved for the opcode
000017CE  B43C 0000               1510              CMP.B      #%00,D2
000017D2  6700 002A               1511              BEQ        PByte
000017D6                          1512              
000017D6  B43C 0001               1513              CMP.B      #%01,D2
000017DA  6700 0030               1514              BEQ        PWord
000017DE                          1515              
000017DE  B43C 0002               1516              CMP.B      #%10,D2
000017E2  6700 0036               1517              BEQ        PLong
000017E6                          1518           
000017E6                          1519  printMOVESize:
000017E6                          1520              ;Now that we know we have a MOVE opcode
000017E6                          1521              ;Compare to which size is being moved for the opcode
000017E6  B43C 0001               1522              CMP.B      #%01,D2
000017EA  6700 0012               1523              BEQ        PByte
000017EE                          1524  
000017EE  B43C 0003               1525              CMP.B      #%11,D2
000017F2  6700 0018               1526              BEQ        PWord            
000017F6                          1527    
000017F6  B43C 0002               1528              CMP.B      #%10,D2
000017FA  6700 001E               1529              BEQ        PLong
000017FE                          1530  
000017FE                          1531  PByte:
000017FE  43F9 00001B0D           1532              LEA        printSIZEB,A1
00001804  103C 000E               1533              MOVE.B     #14,D0
00001808  4E4F                    1534              TRAP       #15
0000180A                          1535              
0000180A  4E75                    1536              RTS
0000180C                          1537  PWord:
0000180C  43F9 00001B12           1538              LEA        printSIZEW,A1
00001812  103C 000E               1539              MOVE.B     #14,D0
00001816  4E4F                    1540              TRAP       #15
00001818                          1541              
00001818  4E75                    1542              RTS
0000181A                          1543  PLong:            
0000181A  43F9 00001B18           1544              LEA        printSIZEL,A1
00001820  103C 000E               1545              MOVE.B     #14,D0
00001824  4E4F                    1546              TRAP       #15
00001826                          1547              
00001826  4E75                    1548              RTS
00001828                          1549              
00001828                          1550  *-----------------------------------------------------------
00001828                          1551  * Addressing Mode Implementation
00001828                          1552  *-----------------------------------------------------------
00001828                          1553  addressModeSR:
00001828                          1554              ;Prints address according to the parameters passed in
00001828                          1555              ;PARAMETERS:
00001828                          1556              ;D6 = mode
00001828                          1557              ;D7 = register
00001828                          1558  
00001828                          1559              ;Data register direct
00001828  BC3C 0000               1560              CMP.B       #%000,D6
0000182C  6700 002A               1561              BEQ         DRD
00001830                          1562              
00001830                          1563              ;Address register direct
00001830  BC3C 0001               1564              CMP.B       #%001,D6
00001834  6700 0036               1565              BEQ         ARD
00001838                          1566              
00001838                          1567              ;Address register indirect
00001838  BC3C 0002               1568              CMP.B       #%010,D6
0000183C  6700 0042               1569              BEQ         ARI
00001840                          1570              
00001840                          1571              ;Post Increment
00001840  BC3C 0003               1572              CMP.B       #%011,D6
00001844  6700 005A               1573              BEQ         PI
00001848                          1574              
00001848                          1575              ;Pre Decrement
00001848  BC3C 0004               1576              CMP.B       #%100,D6
0000184C  6700 0072               1577              BEQ         PD
00001850                          1578              
00001850                          1579              ;Immediate/Absolute Addressing
00001850  BC3C 0007               1580              CMP.B       #%111,D6
00001854  6700 008A               1581              BEQ         otherModes
00001858                          1582  DRD:
00001858                          1583              ;Print D __
00001858  43F9 00001B20           1584              LEA         printDRD,A1
0000185E  103C 000E               1585              MOVE.B      #14,D0
00001862  4E4F                    1586              TRAP        #15
00001864                          1587              
00001864                          1588              ;Print register number
00001864  7003                    1589              MOVE.L      #3,D0
00001866  2207                    1590              MOVE.L      D7,D1
00001868  4E4F                    1591              TRAP        #15
0000186A                          1592              
0000186A  4E75                    1593              RTS
0000186C                          1594  ARD:
0000186C                          1595              ;Print A __
0000186C  43F9 00001B22           1596              LEA         printARD,A1
00001872  103C 000E               1597              MOVE.B      #14,D0
00001876  4E4F                    1598              TRAP        #15
00001878                          1599              
00001878                          1600              ;Print register number
00001878  7003                    1601              MOVE.L      #3,D0
0000187A  2207                    1602              MOVE.L      D7,D1
0000187C  4E4F                    1603              TRAP        #15
0000187E                          1604              
0000187E  4E75                    1605              RTS
00001880                          1606  ARI:
00001880                          1607              ;Print (A __ )
00001880  43F9 00001B24           1608              LEA         printARI,A1
00001886  103C 000E               1609              MOVE.B      #14,D0
0000188A  4E4F                    1610              TRAP        #15
0000188C                          1611              
0000188C                          1612              ;Print register number
0000188C  7003                    1613              MOVE.L      #3,D0
0000188E  2207                    1614              MOVE.L      D7,D1
00001890  4E4F                    1615              TRAP        #15
00001892                          1616              
00001892                          1617              ;Print closing ')'
00001892  43F9 00001B27           1618              LEA         printARI2,A1
00001898  103C 000E               1619              MOVE.B      #14,D0
0000189C  4E4F                    1620              TRAP        #15
0000189E                          1621              
0000189E  4E75                    1622              RTS
000018A0                          1623  PI:
000018A0                          1624              ;Print (A __)+
000018A0  43F9 00001B2D           1625              LEA         printPI,A1
000018A6  103C 000E               1626              MOVE.B      #14,D0
000018AA  4E4F                    1627              TRAP        #15
000018AC                          1628              
000018AC                          1629              ;Print register number
000018AC  7003                    1630              MOVE.L      #3,D0
000018AE  2207                    1631              MOVE.L      D7,D1
000018B0  4E4F                    1632              TRAP        #15
000018B2                          1633              
000018B2                          1634              ;Print closing ')+'
000018B2  43F9 00001B30           1635              LEA         printPI2,A1
000018B8  103C 000E               1636              MOVE.B      #14,D0
000018BC  4E4F                    1637              TRAP        #15
000018BE                          1638              
000018BE  4E75                    1639              RTS
000018C0                          1640  PD:
000018C0                          1641              ;Print -(A __)
000018C0  43F9 00001B33           1642              LEA         printPD,A1
000018C6  103C 000E               1643              MOVE.B      #14,D0
000018CA  4E4F                    1644              TRAP        #15
000018CC                          1645              
000018CC                          1646              ;Print register number
000018CC  7003                    1647              MOVE.L      #3,D0
000018CE  2207                    1648              MOVE.L      D7,D1
000018D0  4E4F                    1649              TRAP        #15
000018D2                          1650              
000018D2                          1651              ;Print closing ')'
000018D2  43F9 00001B37           1652              LEA         printPD2,A1
000018D8  103C 000E               1653              MOVE.B      #14,D0
000018DC  4E4F                    1654              TRAP        #15
000018DE                          1655              
000018DE  4E75                    1656              RTS
000018E0                          1657  
000018E0                          1658  otherModes:
000018E0  B4CE                    1659              CMP.W       A6,A2
000018E2                          1660              
000018E2  6D00 0004               1661              BLT         SKIPCOPY  
000018E6                          1662  
000018E6                          1663               *=====Important step for making sure we have access to where A2 orignally points=====*
000018E6  2C4A                    1664              MOVEA.L     A2,A6 
000018E8                          1665  
000018E8                          1666  
000018E8                          1667  SKIPCOPY:            
000018E8                          1668              
000018E8                          1669              ;Branch to Immediate if register bits are %100       
000018E8  BE3C 0004               1670              CMP.B       #%100,D7
000018EC  6700 0006               1671              BEQ         Immediate
000018F0                          1672              
000018F0                          1673              ;Otherwise, branch to Absolute
000018F0  6000 0022               1674              BRA         Absolute
000018F4                          1675              
000018F4                          1676          
000018F4                          1677                     
000018F4                          1678  Immediate:
000018F4                          1679              ;Print #
000018F4  43F9 00001B29           1680              LEA         printIA,A1
000018FA  103C 000E               1681              MOVE.B      #14,D0
000018FE  4E4F                    1682              TRAP        #15
00001900                          1683              
00001900                          1684              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001900                          1685              ;We will be able to access the contents of either size B or W
00001900  544A                    1686              ADDA.W      #2,A2         
00001902                          1687  
00001902                          1688              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
00001902  0C38 0002 2000          1689              CMP.B       #%10,$2000
00001908  6700 0048               1690              BEQ         IMDLong
0000190C                          1691              
0000190C                          1692              ;If we don't branch, then we assume we're printing out a byte or word      
0000190C  7003                    1693              MOVE.L      #3,D0
0000190E  3212                    1694              MOVE.W      (A2),D1
00001910  4E4F                    1695              TRAP        #15
00001912                          1696              
00001912  4E75                    1697              RTS
00001914                          1698              
00001914                          1699              
00001914                          1700              
00001914                          1701  Absolute:
00001914                          1702              ;Print $
00001914  43F9 00001B2B           1703              LEA         printA,A1
0000191A  103C 000E               1704              MOVE.B      #14,D0
0000191E  4E4F                    1705              TRAP        #15
00001920                          1706              
00001920                          1707              ;Point to the next word (contains memory address)
00001920  544E                    1708              ADDA.W      #2,A6
00001922                          1709              
00001922                          1710              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
00001922  BE3C 0001               1711              CMP.B       #%001,D7
00001926  6700 0012               1712              BEQ         AbsLong
0000192A                          1713              
0000192A                          1714              ;Print out the value in the address if it's a word
0000192A  4281                    1715              CLR.L       D1
0000192C                          1716              
0000192C  303C 000F               1717              MOVE.W      #15,D0
00001930  343C 0010               1718              MOVE.W      #16,D2
00001934  3216                    1719              MOVE.W      (A6),D1
00001936  4E4F                    1720              TRAP        #15
00001938                          1721              
00001938  4E75                    1722              RTS
0000193A                          1723              
0000193A                          1724  AbsLong:            
0000193A                          1725              ;Place the current value into a temp register
0000193A  3816                    1726              MOVE.W      (A6),D4
0000193C                          1727              
0000193C                          1728              ;Shift the bits so we can enter the rest of the values
0000193C  1E3C 0010               1729              MOVE.B      #16,D7
00001940  EFAC                    1730              LSL.L       D7,D4
00001942                          1731              
00001942                          1732              ;Increment A6 to account for the next values in the instruction
00001942  544E                    1733              ADDA.W      #2,A6
00001944                          1734              
00001944                          1735              ;Move the rest of the machine code into our register
00001944                          1736              ;This register should have the whole long values
00001944  3816                    1737              MOVE.W      (A6),D4
00001946                          1738              
00001946                          1739              ;Print the Long address
00001946  4281                    1740              CLR.L       D1
00001948                          1741              
00001948  700F                    1742              MOVE.L      #15,D0
0000194A  7410                    1743              MOVE.L      #16,D2
0000194C  2204                    1744              MOVE.L      D4,D1
0000194E  4E4F                    1745              TRAP        #15
00001950                          1746              
00001950  4E75                    1747              RTS    
00001952                          1748          
00001952                          1749  IMDLong:
00001952                          1750              *********USED FOR IMMEDIATE LONGS ONLY***************
00001952                          1751              
00001952                          1752              ;Place the current value into a temp register
00001952  3812                    1753              MOVE.W      (A2),D4
00001954                          1754              
00001954                          1755              ;Shift the bits so we can enter the rest of the values
00001954  1E3C 0010               1756              MOVE.B      #16,D7
00001958  EFAC                    1757              LSL.L       D7,D4
0000195A                          1758              
0000195A                          1759              ;Increment A2 to account for the next values in the machine code
0000195A  544A                    1760              ADDA.W      #2,A2
0000195C                          1761              
0000195C                          1762              ;Move the rest of the machine code into our register
0000195C                          1763              ;This register should have the whole long values
0000195C  3812                    1764              MOVE.W      (A2),D4
0000195E                          1765              
0000195E                          1766              ;Print out the value in the address
0000195E  7003                    1767              MOVE.L      #3,D0
00001960  2204                    1768              MOVE.L      D4,D1
00001962  4E4F                    1769              TRAP        #15
00001964                          1770              
00001964  4E75                    1771              RTS
00001966                          1772  
00001966                          1773  
00001966                          1774  *-----------------------------------------------------------
00001966                          1775  * Print Instructions for NOP and RTS
00001966                          1776  *-----------------------------------------------------------
00001966                          1777  printMNOP:
00001966  43F9 00001A6C           1778              LEA        printNOP,A1
0000196C  103C 000E               1779              MOVE.B     #14,D0
00001970  4E4F                    1780              TRAP       #15
00001972                          1781              
00001972  6000 F888               1782              BRA        update
00001976                          1783  
00001976                          1784  printMRTS:
00001976  43F9 00001AF3           1785              LEA        printRTS,A1
0000197C  103C 000E               1786              MOVE.B     #14,D0
00001980  4E4F                    1787              TRAP       #15
00001982                          1788              
00001982  6000 F878               1789              BRA        update
00001986                          1790  ;-----------------------------------------------------------
00001986                          1791  ;ERROR MESSAGES FOR I/O portion
00001986                          1792  ;-----------------------------------------------------------
00001986                          1793  charError:
00001986                          1794              
00001986  43F9 00001B5E           1795              LEA         invalCh,A1
0000198C  103C 000E               1796              MOVE.B      #14,D0
00001990  4E4F                    1797              TRAP        #15
00001992                          1798              
00001992  6000 F6D8               1799              BRA         startingPrompt
00001996                          1800            
00001996                          1801  oddError:
00001996  43F9 00001B7F           1802              LEA         odd,A1
0000199C  103C 000E               1803              MOVE.B      #14,D0
000019A0  4E4F                    1804              TRAP        #15
000019A2                          1805              
000019A2  6000 F6C8               1806              BRA         startingPrompt
000019A6                          1807              
000019A6                          1808  manyCharError:  
000019A6  43F9 00001BAC           1809              LEA         manyChar, A1
000019AC  103C 000E               1810              MOVE.B      #14,D0
000019B0  4E4F                    1811              TRAP        #15
000019B2                          1812              
000019B2  6000 F6B8               1813              BRA         startingPrompt
000019B6                          1814           
000019B6                          1815  endGreater:
000019B6  43F9 00001BE7           1816              LEA         endG,A1
000019BC  103C 000E               1817              MOVE.B      #14,D0
000019C0  4E4F                    1818              TRAP        #15
000019C2                          1819              
000019C2  6000 F6A8               1820              BRA         startingPrompt
000019C6                          1821      
000019C6                          1822  ;-----------------------------------------------------------
000019C6                          1823  ;MESSAGES
000019C6                          1824  ;-----------------------------------------------------------
000019C6= 57 65 6C 63 6F 6D ...   1825  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
000019EA= 50 6C 65 61 73 65 ...   1826  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001A2C= 50 6C 65 61 73 65 ...   1827  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001A6C                          1828  
00001A6C                          1829  ;-----------------------------------------------------------
00001A6C                          1830  ;OPCODE Messages
00001A6C                          1831  ;-----------------------------------------------------------
00001A6C= 0D 0A 4E 4F 50 00       1832  printNOP    DC.B        CR,LF,'NOP',0
00001A72= 0D 0A 4D 4F 56 45 00    1833  printMOVE   DC.B        CR,LF,'MOVE',0
00001A79= 0D 0A 4D 4F 56 45 ...   1834  printMOVEM  DC.B        CR,LF,'MOVEM',0
00001A81= 0D 0A 41 44 44 00       1835  printADD    DC.B        CR,LF,'ADD',0
00001A87= 0D 0A 41 44 44 49 00    1836  printADDI   DC.B        CR,LF,'ADDI',0
00001A8E= 0D 0A 53 55 42 00       1837  printSUB    DC.B        CR,LF,'SUB',0
00001A94= 0D 0A 53 55 42 49 00    1838  printSUBI   DC.B        CR,LF,'SUBI',0
00001A9B= 0D 0A 4D 55 4C 53 ...   1839  printMULS   DC.B        CR,LF,'MULS.W ',0
00001AA5= 0D 0A 44 49 56 55 ...   1840  printDIVU   DC.B        CR,LF,'DIVU.W ',0
00001AAF= 0D 0A 4C 45 41 20 00    1841  printLEA    DC.B        CR,LF,'LEA ',0
00001AB6= 0D 0A 41 4E 44 00       1842  printAND    DC.B        CR,LF,'AND',0
00001ABC= 0D 0A 4E 4F 54 00       1843  printNOT    DC.B        CR,LF,'NOT',0
00001AC2= 0D 0A 4C 53 4C 00       1844  printLSL    DC.B        CR,LF,'LSL',0
00001AC8= 0D 0A 4C 53 52 00       1845  printLSR    DC.B        CR,LF,'LSR',0
00001ACE= 0D 0A 41 53 4C 00       1846  printASL    DC.B        CR,LF,'ASL',0
00001AD4= 0D 0A 41 53 52 00       1847  printASR    DC.B        CR,LF,'ASR',0
00001ADA= 0D 0A 42 4C 54 00       1848  printBLT    DC.B        CR,LF,'BLT',0
00001AE0= 0D 0A 42 47 45 00       1849  printBGE    DC.B        CR,LF,'BGE',0
00001AE6= 0D 0A 42 45 51 00       1850  printBEQ    DC.B        CR,LF,'BEQ',0
00001AEC= 0D 0A 4A 53 52 20 00    1851  printJSR    DC.B        CR,LF,'JSR ',0
00001AF3= 0D 0A 52 54 53 00       1852  printRTS    DC.B        CR,LF,'RTS',0
00001AF9= 0D 0A 42 52 41 00       1853  printBRA    DC.B        CR,LF,'BRA',0
00001AFF= 0D 0A 41 53 00          1854  printMAS    DC.B        CR,LF,'AS',0
00001B04= 0D 0A 4C 53 00          1855  printMLS    DC.B        CR,LF,'LS',0
00001B09= 4C 00                   1856  printL      DC.B        'L',0    
00001B0B= 52 00                   1857  printR      DC.B        'R',0
00001B0D                          1858  ;-----------------------------------------------------------
00001B0D                          1859  ;Size Messages
00001B0D                          1860  ;-----------------------------------------------------------
00001B0D= 2E 42 20 00             1861  printSIZEB  DC.B        '.B ',0
00001B12= 2E57 2000 0000          1862  printSIZEW  DC.W        '.W ',0
00001B18= 2E4C2000 00000000       1863  printSIZEL  DC.L        '.L ',0
00001B20                          1864  
00001B20                          1865  ;-----------------------------------------------------------
00001B20                          1866  ;Addressing Mode Messages
00001B20                          1867  ;-----------------------------------------------------------
00001B20= 44 00                   1868  printDRD      DC.B        'D',0
00001B22= 41 00                   1869  printARD      DC.B        'A',0
00001B24= 28 41 00                1870  printARI      DC.B        '(A',0
00001B27= 29 00                   1871  printARI2     DC.B        ')',0
00001B29= 23 00                   1872  printIA       DC.B        '#',0
00001B2B= 24 00                   1873  printA        DC.B        '$',0
00001B2D= 28 41 00                1874  printPI       DC.B        '(A',0
00001B30= 29 2B 00                1875  printPI2      DC.B        ')+',0
00001B33= 2D 28 41 00             1876  printPD       DC.B        '-(A',0
00001B37= 29 00                   1877  printPD2      DC.B        ')',0
00001B39                          1878  
00001B39= 2C 00                   1879  printComma    DC.B        ',',0
00001B3B= 20 00                   1880  printSpace    DC.B        ' ',0
00001B3D                          1881  
00001B3D= 0D 0A 59 6F 75 20 ...   1882  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001B5E                          1883  
00001B5E                          1884  ;-----------------------------------------------------------
00001B5E                          1885  ;ERRORS
00001B5E                          1886  ;-----------------------------------------------------------
00001B5E= 45 52 52 4F 52 3A ...   1887  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001B7F= 45 52 52 4F 52 3A ...   1888  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001BAC= 45 52 52 4F 52 3A ...   1889  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001BE7= 45 52 52 4F 52 3A ...   1890  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00001C2C= 45 52 52 4F 52 3A ...   1891  sizeError   DC.B        'ERROR: Invalid size instruction',0
00001C4C                          1892  
00001C4C                          1893  ;-----------------------------------------------------------
00001C4C                          1894  ;Ending function that ends our program 
00001C4C                          1895  ;-----------------------------------------------------------
00001C4C                          1896  ending:
00001C4C  43F8 1B3D               1897              LEA         theEnd,A1
00001C50  303C 000E               1898              MOVE        #14,D0
00001C54  4E4F                    1899              TRAP        #15
00001C56                          1900              
00001C56                          1901              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             193A
ABSOLUTE            1914
ADDRESSMODESR       1828
ARD                 186C
ARI                 1880
CHARERROR           1986
CONTINUEDIVU        1478
CONVERT             10C0
CR                  D
DNDEST              1740
DNSOURCE            1764
DRD                 1858
ENDG                1BE7
ENDGREATER          19B6
ENDHEX              1004
ENDING              1C4C
ENDINGPROMPT        1098
GETBITS             1212
IMDLONG             1952
IMMEDIATE           18F4
IMMEDIATECOUNT      15DA
IMMEDIATECOUNT2     1602
INVALCH             1B5E
ISOADDBIT0TO5       12D6
ISOLATEADDRESSBIT0TO5  1788
ISOLATEADDRESSBIT6TO11  1354
ISOLATEREGISTERBIT9TO11  17AE
LETTER              10E4
LF                  A
LOOP                1174
M00                 12FC
M0000               1228
M0100               137A
M0110               145C
M1000               145C
M1001               1488
M1100               14CC
M1101               16FC
M1110               1540
MADDI               1248
MAIN                1000
MAND                1510
MANYCHAR            1BAC
MANYCHARERROR       19A6
MAS                 1674
MBEQ                145C
MBGE                145C
MBLT                145C
MBRA                145C
MEFFECT             12B4
MEMAS               1646
MEMDIRECTIONSUBROUTINE  1682
MEMLS               164E
MEMSHIFT            1610
MEMSHIFT2           162E
MJSR                1444
ML                  16AE
MLEA                13E8
MLS                 1666
MMULS               1500
MNOT                1418
MORECHECKS          1114
MORECHECKS1         1120
MORECHECKS2         1142
MOVEM               13DC
MR                  16A0
MSOURCEDEST         1332
MSUBI               127C
MULSCHECK           14EA
NUMBER              10F8
ODD                 1B7F
ODDERROR            1996
OTHERMODES          18E0
PBYTE               17FE
PD                  18C0
PI                  18A0
PLONG               181A
PRINTA              1B2B
PRINTADD            1A81
PRINTADDI           1A87
PRINTAND            1AB6
PRINTARD            1B22
PRINTARI            1B24
PRINTARI2           1B27
PRINTASL            1ACE
PRINTASR            1AD4
PRINTBEQ            1AE6
PRINTBGE            1AE0
PRINTBLT            1ADA
PRINTBRA            1AF9
PRINTCOMMA          1B39
PRINTDIVU           1AA5
PRINTDRD            1B20
PRINTIA             1B29
PRINTJSR            1AEC
PRINTL              1B09
PRINTLEA            1AAF
PRINTLSL            1AC2
PRINTLSR            1AC8
PRINTMAS            1AFF
PRINTMLS            1B04
PRINTMNOP           1966
PRINTMOVE           1A72
PRINTMOVEM          1A79
PRINTMOVESIZE       17E6
PRINTMRTS           1976
PRINTMULS           1A9B
PRINTNOP            1A6C
PRINTNOT            1ABC
PRINTPD             1B33
PRINTPD2            1B37
PRINTPI             1B2D
PRINTPI2            1B30
PRINTR              1B0B
PRINTRTS            1AF3
PRINTSIZEB          1B0D
PRINTSIZEL          1B18
PRINTSIZESUBROUTINE  17C6
PRINTSIZEW          1B12
PRINTSPACE          1B3B
PRINTSUB            1A8E
PRINTSUBI           1A94
PWORD               180C
REGAS               1656
REGDIRECTIONSUBROUTINE  16BE
REGLS               165E
REGSHIFT            1578
REGSHIFT2           15B0
RL                  16EC
RR                  16DC
SHIFTEIGHT          160A
SIZEERROR           1C2C
SKIPA6              1204
SKIPCOPY            18E8
STAHEX              1000
STARTINGPROMPT      106C
TESTING             101A
THEEND              1B3D
UPDATE              11FC
USEREA              1A2C
USERSA              19EA
WELCOME             19C6
