00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/19/2021 8:19:56 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 00001768             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29                     
00001014                            30              ;===TESTING===
00001014  49D3                      31              LEA (A3),A4
00001016  4600                      32              NOT.B    D0
00001018  E5A1                      33              ASL.L      D2, D1  
0000101A  E268                      34              LSR.W      D1, D0
0000101C  E0D1                      35              ASR        (A1)
0000101E  E10A                      36              LSL.B      #8, D2
00001020                            37              
00001020                            38  startingPrompt:
00001020                            39              ;Ask the user for the starting hex3
00001020  43F9 0000178C             40              LEA         userSA,A1
00001026  103C 000E                 41              MOVE.B      #14,D0
0000102A  4E4F                      42              TRAP        #15        
0000102C                            43              
0000102C                            44              ;Clear the registers in case we had an error
0000102C  227C 00000000             45              MOVE.L      #0,A1
00001032  247C 00000000             46              MOVE.L      #0,A2
00001038  4283                      47              CLR.L       D3
0000103A  4284                      48              CLR.L       D4
0000103C  4285                      49              CLR.L       D5
0000103E  4286                      50              CLR.L       D6
00001040                            51             
00001040                            52              
00001040                            53              ;Input for the hex (D1 equals number of chars)
00001040  303C 0002                 54              MOVE.W      #2,D0
00001044  4E4F                      55              TRAP        #15
00001046                            56              
00001046                            57              ;Moves A1 into A2      
00001046                            58              ;MOVEA.L     A1,A2
00001046                            59              
00001046                            60              ;Makes sure D7 is clear incase we're looping back after an error.
00001046  4207                      61              CLR.B       D7
00001048                            62              
00001048  6000 002A                 63              BRA         convert  
0000104C                            64              
0000104C                            65  endingPrompt:
0000104C                            66              ;D7 is if we're working with the first or second promt, used in the more checks section. 
0000104C  1E3C 0001                 67              MOVE.B       #1,D7
00001050                            68              
00001050                            69              ;Ask the user for the ending hex
00001050  43F9 000017CE             70              LEA         userEA,A1
00001056  103C 000E                 71              MOVE.B      #14,D0
0000105A  4E4F                      72              TRAP        #15
0000105C                            73              
0000105C                            74              ;Clearing the registers so we can reuse them for the ending address
0000105C  227C 00000000             75              MOVE.L      #0,A1
00001062  247C 00000000             76              MOVE.L      #0,A2
00001068  4286                      77              CLR.L       D6
0000106A                            78  
0000106A                            79              ;Input for the hex (D1 equals number of chars)
0000106A  303C 0002                 80              MOVE.W      #2,D0
0000106E  4E4F                      81              TRAP        #15
00001070                            82              
00001070                            83              ;Moves A1 into A2      
00001070                            84              ;MOVEA.L     A1,A2
00001070                            85              
00001070  6000 0002                 86              BRA         convert
00001074                            87  
00001074                            88  convert:    
00001074                            89              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001074  B23C 0006                 90              CMP.B       #6, D1
00001078  6E00 06CE                 91              BGT         manyCharError  
0000107C                            92              
0000107C                            93              ;See if our counter variable is 0
0000107C  B23C 0000                 94              CMP.B       #0,D1
00001080                            95              
00001080                            96              ;This means that we have gone through all the characters
00001080  6700 0046                 97              BEQ         moreChecks
00001084                            98              
00001084                            99              ;Decrement the counter, this means we're about to go through another char
00001084  5301                     100              SUB.B       #1,D1
00001086                           101  
00001086                           102              ;Let's move the byte stored at A1
00001086  1612                     103              MOVE.B      (A2),D3
00001088                           104              
00001088                           105              ;If the byte is greater than or equal to hex $40, then it's a letter
00001088  B63C 0041                106              CMP.B       #$41,D3
0000108C  6C00 000A                107              BGE         letter
00001090                           108              
00001090                           109              ;If the byte is less than or equal to hex $39, then it's a number
00001090  B63C 0040                110              CMP.B       #$40,D3
00001094  6F00 0016                111              BLE         number
00001098                           112              
00001098                           113  letter:
00001098                           114              ;We do this check to see if the character is greater than or equal 'G'
00001098  B63C 0047                115              CMP.B       #$47,D3
0000109C                           116              ;If so, then display an error and ask the user to enter startingAdd again
0000109C  6C00 068A                117              BGE         charError
000010A0                           118              
000010A0                           119              ;Subtract the Ascii value to convert to hex
000010A0  0403 0037                120              SUB.B       #$37,D3
000010A4                           121              ;Move the value back to our register
000010A4  14C3                     122              MOVE.B      D3,(A2)+
000010A6                           123              
000010A6                           124              ;Shift D5 left to make room for next hex value
000010A6  E986                     125              ASL.L       #4, D6
000010A8                           126              ;Move value to D5
000010A8  DC03                     127              ADD.B      D3, D6
000010AA                           128              
000010AA  60C8                     129              BRA         convert
000010AC                           130             
000010AC                           131  
000010AC                           132  number:          
000010AC                           133             ;We do this check to see if the character is less than or equal to '/'  
000010AC  B63C 002F                134             CMP.B        #$2F,D3
000010B0                           135             ;If so, then display an error and ask the user to enter startingAdd again
000010B0  6F00 0676                136             BLE          charError     
000010B4                           137   
000010B4                           138             ;Check to see if the character is greater than or equal to ':'
000010B4  B63C 003A                139             CMP.B        #$3A,D3
000010B8                           140             ;If so, then display an error and ask the user to enter startingAdd again
000010B8  6C00 066E                141             BGE          charError
000010BC                           142            
000010BC                           143             ;Subtract the Ascii value to convert to hex
000010BC  0403 0030                144             SUB.B        #$30,D3
000010C0                           145             ;Move the value back to our register
000010C0  14C3                     146             MOVE.B       D3,(A2)+
000010C2                           147   
000010C2                           148             ;Shift D5 left to make room for next hex value
000010C2  E986                     149             ASL.L        #4, D6
000010C4                           150             ;Move value to D5
000010C4  DC03                     151             ADD.B        D3, D6
000010C6                           152              
000010C6  60AC                     153             BRA          convert
000010C8                           154   
000010C8                           155            
000010C8                           156  moreChecks:
000010C8                           157              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010C8  BE3C 0001                158              CMP.B      #1,D7
000010CC  6700 0028                159              BEQ        moreChecks2
000010D0                           160              
000010D0  6000 0002                161              BRA        moreChecks1
000010D4                           162   
000010D4                           163  moreChecks1:
000010D4                           164              
000010D4                           165              ;Copy the hex value into a temp register
000010D4  2806                     166              MOVE.L      D6,D4
000010D6                           167              
000010D6                           168              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010D6  1A3C 001F                169              MOVE.B      #31,D5
000010DA                           170              
000010DA                           171              ;Shifts 31 bits, isolates last bit. 
000010DA  EBAC                     172              LSL.L       D5,D4
000010DC                           173  
000010DC                           174              ;Shifts it back 31 bit, isolating the last bit. 
000010DC  EAAC                     175              LSR.L       D5,D4
000010DE                           176  
000010DE                           177              ;If the last bit is 1, address was odd, and throw an error. 
000010DE  B83C 0001                178              CMP.B       #1,D4
000010E2  6700 0654                179              BEQ         oddError   
000010E6                           180                          
000010E6                           181              ;Reset address registers.
000010E6  247C 00000000            182              MOVE.L      #0,A2
000010EC                           183              
000010EC                           184              ;Copy the value to our staHex variable
000010EC  21C6 1000                185              MOVE.L      D6,staHex 
000010F0                           186              
000010F0  4286                     187              CLR.L       D6
000010F2  6000 FF58                188              BRA         endingPrompt     
000010F6                           189              
000010F6                           190  moreChecks2:       
000010F6                           191              
000010F6                           192              ;Copy the hex value into a temp register
000010F6  2806                     193              MOVE.L      D6,D4
000010F8                           194              
000010F8                           195              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010F8  1A3C 001F                196              MOVE.B      #31,D5
000010FC                           197              
000010FC                           198              ;Shifts 31 bits, isolates last bit. 
000010FC  EBAC                     199              LSL.L       D5,D4
000010FE                           200  
000010FE                           201              ;Shifts it back 31 bit, isolating the last bit. 
000010FE  EAAC                     202              LSR.L       D5,D4
00001100                           203  
00001100                           204              ;If the last bit is 1, address was odd, and throw an error. 
00001100  B83C 0001                205              CMP.B       #1,D4
00001104  6700 0632                206              BEQ         oddError   
00001108                           207                          
00001108                           208              ;Reset address registers.
00001108  247C 00000000            209              MOVE.L      #0,A2
0000110E                           210              
0000110E                           211              ;Place the value in our ending hex variable
0000110E  21C6 1004                212              MOVE.L      D6,endHex 
00001112                           213              
00001112                           214              ;Make D7 a temp location to compare our starting hex
00001112  2E38 1000                215              MOVE.L      staHex,D7
00001116                           216           
00001116                           217              
00001116                           218              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001116  BC87                     219              CMP.L       D7,D6
00001118  6B00 063E                220              BMI         endGreater
0000111C                           221              
0000111C                           222              ;done, start reading memory. 
0000111C                           223              
0000111C                           224              ;Clear all the registers since we have the addresses stored in our variables
0000111C  4283                     225              CLR.L       D3
0000111E  4285                     226              CLR.L       D5
00001120  4286                     227              CLR.L       D6
00001122  4287                     228              CLR.L       D7  
00001124                           229              
00001124                           230              ;Copy the value of our starting hex to A2 (temp register)
00001124  2478 1000                231              MOVEA.L     staHex,A2
00001128                           232                          
00001128                           233              
00001128                           234  LOOP:   
00001128                           235              ;--------------------------------------------------------
00001128                           236              ;Check for NOP or RTS
00001128                           237              ;--------------------------------------------------------
00001128                           238              
00001128                           239              ;Move the NOP binary value for comparing
00001128  243C 00004E71            240              MOVE.L      #%0100111001110001,D2
0000112E                           241              
0000112E                           242              ;Check and see i the instruction is NOP
0000112E  B452                     243              CMP.W       (A2),D2
00001130  6700 05D6                244              BEQ         printN
00001134                           245              
00001134                           246              ;Move the RTS binary value for comparing
00001134  243C 00004E75            247              MOVE.L      #%0100111001110101,D2
0000113A                           248              
0000113A                           249              ;Check and see if the instruction is RTS
0000113A  B452                     250              CMP.W       (A2),D2
0000113C  6700 05DA                251              BEQ         printMRTS
00001140                           252              
00001140                           253              ;Clear the contents for reusing
00001140  4282                     254              CLR.L       D2
00001142                           255              
00001142                           256              
00001142                           257              ;--------------------------------------------------------
00001142                           258              ;Check for MOVE, since it's the only word starting with 00
00001142                           259              ;--------------------------------------------------------            
00001142                           260              ;Move the value in A2 to a temp register
00001142  1412                     261              MOVE.B      (A2),D2
00001144                           262              
00001144                           263              ;Shift 6 bits to the right to isolate the left-most digits
00001144  EC8A                     264              LSR.L       #6,D2
00001146                           265              
00001146                           266              ;If the first two bits (left-most) are 00, then the instruction is MOVE
00001146  B43C 0000                267              CMP.B       #00,D2
0000114A  6F00 0070                268              BLE         M00
0000114E                           269              
0000114E                           270              ;Reuse the register
0000114E  4282                     271              CLR.L       D2
00001150                           272              
00001150                           273              
00001150                           274              ;--------------------------------------------------------
00001150                           275              ;Check for other OpCodes
00001150                           276              ;--------------------------------------------------------
00001150                           277              ;Move the word into a temp register 
00001150  3412                     278              MOVE.W      (A2),D2
00001152                           279              
00001152                           280              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001152  163C 000C                281              MOVE.B        #12,D3            ;Start bit index = 12
00001156  183C 0004                282              MOVE.B        #4,D4             ;Number of bits needed = 4
0000115A                           283              
0000115A                           284              ;Jumps to getBits and returns with isolated bits in D2
0000115A  6100 004A                285              BSR           getBits            
0000115E                           286  
0000115E                           287              
0000115E                           288              ;MOVEM,LEA,NOT,JSR
0000115E  B43C 0004                289              CMP.B       #%0100,D2
00001162  6700 007E                290              BEQ         M0100
00001166                           291              
00001166                           292              ;BRA,BLT,BGE,BEQ
00001166  B43C 0006                293              CMP.B       #%0110,D2
0000116A  6700 0146                294              BEQ         M0110
0000116E                           295              
0000116E                           296              ;DIVU
0000116E  B43C 0008                297              CMP.B       #%1000,D2
00001172  6700 013E                298              BEQ         M1000
00001176                           299              
00001176                           300              ;SUB
00001176  B43C 0009                301              CMP.B       #%1001,D2
0000117A  6700 0162                302              BEQ         M1001
0000117E                           303              
0000117E                           304              ;MULS,AND
0000117E  B43C 000C                305              CMP.B       #%1100,D2
00001182  6700 0198                306              BEQ         M1100
00001186                           307              
00001186                           308              ;LSL,LSR,ASL,ASR
00001186  B43C 000E                309              CMP.B       #%1110,D2
0000118A  6700 0204                310              BEQ         M1110
0000118E                           311              
0000118E                           312              ;ADD
0000118E  B43C 000D                313              CMP.B       #%1101,D2
00001192  6700 03B8                314              BEQ         M1101
00001196                           315              
00001196  6000 0844                316              BRA         ending
0000119A                           317              
0000119A                           318              
0000119A                           319              
0000119A                           320              ;display INVALID OPCODE, and display the raw hex
0000119A                           321              ;do this later
0000119A                           322  
0000119A                           323             
0000119A                           324  update:
0000119A                           325              ;Check and see if we are at the ending hex
0000119A  B5F8 1004                326              CMP.L      endHex,A2
0000119E  6700 083C                327              BEQ        ending
000011A2                           328  
000011A2                           329              ;Update address in A2
000011A2  548A                     330              ADD.L      #2,A2
000011A4                           331              
000011A4                           332              
000011A4  6082                     333              BRA        LOOP
000011A6                           334              
000011A6                           335              
000011A6                           336  getBits:
000011A6                           337              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
000011A6                           338              ;PARAMETERS:
000011A6                           339              ;D2 = the value the bits are extracted from & saved back in
000011A6                           340              ;D3 = the start bit index (starting from 0)
000011A6                           341              ;D4 = the number of bits we want to extract
000011A6                           342              
000011A6                           343              ;Calculate left shift
000011A6  3A3C 0010                344              MOVE.W      #16,D5
000011AA                           345              
000011AA  D843                     346              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
000011AC  9A44                     347              SUB.W       D4,D5             ; 16 - X = leftShift
000011AE                           348              
000011AE  EB6A                     349              LSL.W       D5,D2
000011B0                           350              
000011B0                           351              
000011B0                           352              ;Calculate right shift
000011B0  DA43                     353              ADD.W       D3,D5             ; start bit + leftShift = X
000011B2  EA6A                     354              LSR.W       D5,D2
000011B4                           355              
000011B4  4283                     356              CLR.L       D3
000011B6  4284                     357              CLR.L       D4
000011B8  4285                     358              CLR.L       D5   
000011BA  4E75                     359              RTS
000011BC                           360  
000011BC                           361  *-----------------------------------------------------------
000011BC                           362  * OpCode Implementation
000011BC                           363  *-----------------------------------------------------------
000011BC                           364  
000011BC                           365  
000011BC                           366  *-----------------------------------------------------------
000011BC                           367  * MOVE INSTRUCTION
000011BC                           368  *-----------------------------------------------------------
000011BC                           369  M00:
000011BC  43F9 00001814            370              LEA        printMOVE,A1
000011C2  103C 000E                371              MOVE.B     #14,D0
000011C6  4E4F                     372              TRAP       #15
000011C8                           373              
000011C8  4202                     374              CLR.B      D2
000011CA  4203                     375              CLR.B      D3
000011CC                           376              
000011CC                           377              ;======Isolate Size (S) Bits=======
000011CC                           378              ;Copy the address values into a register
000011CC  3412                     379              MOVE.W     (A2),D2
000011CE                           380              
000011CE                           381              ;Passing in parameters for isolating size bits 12,13
000011CE  163C 000D                382              MOVE.B      #13,D3             
000011D2  183C 0002                383              MOVE.B      #2,D4             
000011D6                           384              
000011D6                           385              ;Jumps to getBits and returns with isolated bits in D2
000011D6  61CE                     386              BSR         getBits  
000011D8                           387              
000011D8                           388              ;Jumps to printSizeSubroutine and returns after size has been printed
000011D8  6100 0436                389              BSR         printSizeSubroutine
000011DC                           390              
000011DC                           391              ;Clear the register so we can reuse it
000011DC  4282                     392              CLR.L       D2
000011DE                           393              
000011DE  1412                     394              MOVE.B      (A2),D2
000011E0                           395  
000011E0                           396              
000011E0                           397              ;Get bits 11-6 for the source
000011E0                           398              ;First we must figure out the register that is being used
000011E0                           399              ;Then find the addressing mode
000011E0                           400              
000011E0                           401              ;Get bits 0-15 for the destination
000011E0                           402              ;This uses the same procedure from previous opcodes
000011E0                           403              ;First find the addressing mode
000011E0                           404              ;Then find the register that is being used
000011E0                           405              
000011E0  60B8                     406              BRA        update
000011E2                           407            
000011E2                           408  
000011E2                           409  *-----------------------------------------------------------
000011E2                           410  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
000011E2                           411  *-----------------------------------------------------------
000011E2                           412  M0100:      
000011E2  4282                     413              CLR.L       D2
000011E4  4283                     414              CLR.L       D3
000011E6                           415              
000011E6                           416              ;--------------------------------------------------------
000011E6                           417              ;Check for LEA
000011E6                           418              ;--------------------------------------------------------
000011E6                           419              ;Copy the address values into a register to check for LEA
000011E6  3412                     420              MOVE.W     (A2),D2
000011E8                           421              
000011E8                           422              ;Passing in parameters for isolating bits 6,7,8
000011E8  163C 0006                423              MOVE.B      #6,D3             ;Start bit index = 6
000011EC  183C 0003                424              MOVE.B      #3,D4             ;Number of bits needed = 3
000011F0                           425              
000011F0                           426              ;Jumps to getBits and returns with isolated bits in D2
000011F0  61B4                     427              BSR         getBits
000011F2                           428  
000011F2  B43C 0007                429              CMP.B       #%111,D2
000011F6  6700 0046                430              BEQ         MLEA
000011FA                           431  
000011FA                           432              ;--------------------------------------------------------
000011FA                           433              ;Check for NOT
000011FA                           434              ;--------------------------------------------------------
000011FA                           435              ;Clear D2 and recopy it to check for NOT
000011FA  4282                     436              CLR.L       D2
000011FC  3412                     437              MOVE.W      (A2),D2
000011FE                           438              
000011FE                           439              ;Pass in parameters for isolating bits 8,9,10,11
000011FE  163C 0008                440              MOVE.B      #8,D3
00001202  183C 0004                441              MOVE.B      #4,D4
00001206                           442              
00001206                           443              ;Jumps to getBits and returns with isolated bits in D2
00001206  619E                     444              BSR         getBits
00001208                           445              
00001208  B43C 0006                446              CMP.B       #%0110,D2
0000120C  6700 0060                447              BEQ         MNOT      
00001210                           448              
00001210                           449              ;--------------------------------------------------------
00001210                           450              ;Check for JSR
00001210                           451              ;--------------------------------------------------------
00001210                           452              ;Clear D2 and recopy it to check for JSR
00001210  4282                     453              CLR.L       D2
00001212  3412                     454              MOVE.W     (A2),D2
00001214                           455              
00001214                           456              ;Pass in parameters for isolating bits 6-11
00001214  163C 0006                457              MOVE.B      #6,D3
00001218  183C 0006                458              MOVE.B      #6,D4
0000121C                           459              
0000121C                           460              ;Jumps to getBits and returns with isolated bits in D2
0000121C  6188                     461              BSR         getBits
0000121E                           462              
0000121E  B43C 003A                463              CMP.B       #%111010,D2
00001222  6700 0076                464              BEQ         MJSR
00001226                           465              
00001226                           466              ;--------------------------------------------------------
00001226                           467              ;Check for MOVEM
00001226                           468              ;--------------------------------------------------------
00001226                           469              ;Clear D2 and recopy it to check for MOVEM
00001226  4282                     470              CLR.L       D2
00001228  3412                     471              MOVE.W     (A2),D2
0000122A                           472              
0000122A                           473              ;Pass in parameters for isolating bit 9
0000122A  163C 0009                474              MOVE.B      #9,D3
0000122E  183C 0001                475              MOVE.B      #1,D4
00001232                           476              
00001232                           477              ;Jumps to getBits and returns with isolated bits in D2
00001232  6100 FF72                478              BSR         getBits
00001236                           479              
00001236  B43C 0000                480              CMP.B       #%0,D2
0000123A  6700 0002                481              BEQ         MOVEM
0000123E                           482              
0000123E                           483         
0000123E                           484  MOVEM:
0000123E                           485  
0000123E                           486  MLEA:
0000123E  43F9 00001843            487              LEA         printLEA,A1
00001244  103C 000E                488              MOVE.B      #14,D0
00001248  4E4F                     489              TRAP        #15
0000124A                           490              
0000124A                           491              ;*SOURCE*
0000124A                           492              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000124A                           493              ;D6 will contain mode & D7 will contain the register after this instruction
0000124A  6100 0386                494              BSR         isolateAddressBit0to5
0000124E                           495              
0000124E                           496              ;*Print source address*
0000124E  6100 0402                497              BSR         addressModeSR
00001252                           498              
00001252                           499              ;Print comma after source address
00001252  43F9 000018C9            500              LEA         printComma,A1
00001258  103C 000E                501              MOVE.B      #14,D0
0000125C  4E4F                     502              TRAP        #15
0000125E                           503              
0000125E                           504              ;*DESTINATION*
0000125E                           505              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000125E                           506              ;D7 will contain the register after this instruction
0000125E  6100 0398                507              BSR         isolateRegisterBit9to11
00001262                           508              
00001262                           509              ;Save #%001 into D6 to specify address register mode
00001262  1C3C 0001                510              MOVE.B      #1,D6
00001266                           511              
00001266                           512              
00001266                           513              ;*Print destination address*
00001266  6100 03EA                514              BSR         addressModeSR
0000126A                           515  
0000126A  6000 FF2E                516              BRA        update
0000126E                           517  
0000126E                           518  MNOT:
0000126E  43F9 00001850            519              LEA        printNOT,A1
00001274  103C 000E                520              MOVE.B     #14,D0
00001278  4E4F                     521              TRAP       #15
0000127A                           522              
0000127A  4282                     523              CLR.L      D2
0000127C                           524              ;Move the address into the register to check for size
0000127C  3412                     525              MOVE.W     (A2),D2
0000127E                           526              
0000127E                           527              ;Pass in parameters for isolating bits 6,7
0000127E  163C 0006                528              MOVE.B     #6,D3
00001282  183C 0002                529              MOVE.B     #2,D4
00001286                           530              
00001286                           531              ;Jump to getbits and return with isolated bits
00001286  6100 FF1E                532              BSR        getbits          
0000128A                           533              
0000128A                           534              ;Jumps to printSizeSubroutine and returns after size has been printed
0000128A  6100 0384                535              BSR        printSizeSubroutine
0000128E                           536              
0000128E                           537              ;*SOURCE*
0000128E                           538              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000128E                           539              ;D6 will contain mode & D7 will contain the register after this instruction
0000128E  6100 0342                540              BSR        isolateAddressBit0to5
00001292                           541              
00001292                           542              ;*Print source address*
00001292  6100 03BE                543              BSR        addressModeSR
00001296                           544              
00001296  6000 FF02                545              BRA        update 
0000129A                           546  
0000129A                           547  MJSR:
0000129A  43F9 00001880            548              LEA        printJSR,A1
000012A0  103C 000E                549              MOVE.B     #14,D0
000012A4  4E4F                     550              TRAP       #15
000012A6                           551              
000012A6                           552              ;*SOURCE*
000012A6                           553              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000012A6                           554              ;D6 will contain mode & D7 will contain the register after this instruction
000012A6  6100 032A                555              BSR        isolateAddressBit0to5
000012AA                           556              
000012AA                           557              ;*Print source address*
000012AA  6100 03A6                558              BSR        addressModeSR
000012AE                           559              
000012AE  6000 FEEA                560              BRA        update 
000012B2                           561              
000012B2                           562  
000012B2                           563  *-----------------------------------------------------------
000012B2                           564  * BRA,BLT,BGE,BEQ INSTRUCTIONS
000012B2                           565  *-----------------------------------------------------------       
000012B2                           566  M0110:
000012B2                           567              ;
000012B2                           568  MBRA:
000012B2                           569  MBLT:
000012B2                           570  MBGE:
000012B2                           571  MBEQ:            
000012B2                           572              
000012B2                           573  
000012B2                           574  *-----------------------------------------------------------
000012B2                           575  * DIVU INSTRUCTION
000012B2                           576  *-----------------------------------------------------------           
000012B2                           577  M1000:
000012B2                           578              
000012B2  4282                     579              CLR.L       D2
000012B4  4283                     580              CLR.L       D3
000012B6                           581              
000012B6                           582              ;Copy the address values into a register
000012B6  3412                     583              MOVE.W     (A2),D2
000012B8                           584              
000012B8                           585              ;Passing in parameters for isolating bits 6,7,8
000012B8  163C 0006                586              MOVE.B      #6,D3             ;Start bit index = 6
000012BC  183C 0003                587              MOVE.B      #3,D4             ;Number of bits needed = 3
000012C0                           588              
000012C0                           589              ;Jumps to getBits and returns with isolated bits in D2
000012C0  6100 FEE4                590              BSR         getBits
000012C4                           591              
000012C4                           592              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
000012C4  B4BC 00000003            593              CMP.L       #%011,D2
000012CA  6700 0002                594              BEQ         continueDIVU
000012CE                           595              
000012CE                           596              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
000012CE                           597  
000012CE                           598  continueDIVU:
000012CE                           599  
000012CE  43F9 00001839            600              LEA         printDIVU,A1
000012D4  103C 000E                601              MOVE.B      #14,D0
000012D8  4E4F                     602              TRAP        #15
000012DA                           603              
000012DA  6000 02AE                604              BRA         dnDest
000012DE                           605              
000012DE                           606              
000012DE                           607  *-----------------------------------------------------------
000012DE                           608  * SUB INSTRUCTION
000012DE                           609  *-----------------------------------------------------------  
000012DE                           610  M1001:
000012DE  43F9 00001829            611              LEA        printSUB,A1
000012E4  103C 000E                612              MOVE.B     #14,D0
000012E8  4E4F                     613              TRAP       #15
000012EA                           614              
000012EA  4202                     615              CLR.B      D2
000012EC  4203                     616              CLR.B      D3
000012EE                           617              
000012EE                           618              ;======Isolate Size (S) Bits=======
000012EE                           619              ;Copy the address values into a register
000012EE  3412                     620              MOVE.W     (A2),D2
000012F0                           621              
000012F0                           622              ;Passing in parameters for isolating size bits
000012F0  163C 0006                623              MOVE.B      #6,D3             ;Start bit index = 6
000012F4  183C 0002                624              MOVE.B      #2,D4             ;Number of bits needed = 2
000012F8                           625              
000012F8                           626              ;Jumps to getBits and returns with isolated bits in D2
000012F8  6100 FEAC                627              BSR         getBits  
000012FC                           628              
000012FC                           629              ;Jumps to printSizeSubroutine and returns after size has been printed
000012FC  6100 0312                630              BSR         printSizeSubroutine
00001300                           631              
00001300                           632         
00001300                           633              ;======Isolate direction (D) Bit=======
00001300                           634              ; 0 = data register is destination | 1 = Dn is source
00001300  4282                     635              CLR.L       D2
00001302                           636              
00001302                           637              ;Copy the address values into a register
00001302  3412                     638              MOVE.W      (A2),D2
00001304                           639              
00001304                           640              ;Passing in parameters for isolating direction bit
00001304  163C 0008                641              MOVE.B      #8,D3             ;Start bit index = 8
00001308  183C 0001                642              MOVE.B      #1,D4             ;Number of bits needed = 1
0000130C                           643              
0000130C                           644              ;Jumps to getBits and returns with isolated bit in D2
0000130C  6100 FE98                645              BSR         getBits
00001310                           646              
00001310                           647              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001310  B43C 0000                648              CMP.B       #0,D2
00001314  6700 0274                649              BEQ         dnDest
00001318  6000 0294                650              BRA         dnSource
0000131C                           651  
0000131C                           652  
0000131C                           653  *-----------------------------------------------------------
0000131C                           654  * MULS,AND INSTRUCTIONS
0000131C                           655  *-----------------------------------------------------------  
0000131C                           656  M1100:      
0000131C  4282                     657              CLR.L       D2
0000131E  4283                     658              CLR.L       D3
00001320                           659              
00001320                           660              ;Copy the address values into a register
00001320  3412                     661              MOVE.W     (A2),D2
00001322                           662              
00001322                           663              ;Passing in parameters for isolating bits 6 and 7
00001322  163C 0006                664              MOVE.B      #6,D3             ;Start bit index = 6
00001326  183C 0002                665              MOVE.B      #2,D4             ;Number of bits needed = 2
0000132A                           666              
0000132A                           667              ;Jumps to getBits and returns with isolated bits in D2
0000132A  6100 FE7A                668              BSR         getBits  
0000132E                           669              
0000132E                           670              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
0000132E  B43C 0003                671              CMP.B       #%11,D2
00001332  6700 0006                672              BEQ         mulsCheck
00001336  6000 0028                673              BRA         MAND
0000133A                           674              
0000133A                           675  mulsCheck:
0000133A                           676              ;Copy the address values into a register
0000133A  3412                     677              MOVE.W     (A2),D2
0000133C                           678              
0000133C                           679              ;Passing in parameters for isolating bit 8
0000133C  163C 0008                680              MOVE.B      #8,D3             ;Start bit index = 8
00001340  183C 0001                681              MOVE.B      #1,D4             ;Number of bits needed = 1
00001344                           682              
00001344                           683              ;Jumps to getBits and returns with isolated bits in D2
00001344  6100 FE60                684              BSR         getBits 
00001348                           685              
00001348                           686              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
00001348  B43C 0001                687              CMP.B       #1,D2
0000134C  6700 0002                688              BEQ         MMULS
00001350                           689              
00001350                           690              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001350                           691  
00001350                           692              
00001350                           693              
00001350                           694              
00001350                           695  MMULS:
00001350  43F9 0000182F            696              LEA         printMULS,A1
00001356  103C 000E                697              MOVE.B      #14,D0
0000135A  4E4F                     698              TRAP        #15
0000135C                           699              
0000135C  6000 022C                700              BRA         dnDest 
00001360                           701  
00001360                           702  
00001360                           703  MAND:
00001360  43F9 0000184A            704              LEA        printAND,A1
00001366  103C 000E                705              MOVE.B     #14,D0
0000136A  4E4F                     706              TRAP       #15
0000136C                           707              
0000136C                           708              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
0000136C                           709              ;Jumps to printSizeSubroutine and returns after size has been printed
0000136C  6100 02A2                710              BSR         printSizeSubroutine
00001370                           711              
00001370                           712              ;======Isolate direction (D) Bit=======
00001370                           713              ; 0 = data register is destination | 1 = Dn is source
00001370  4282                     714              CLR.L       D2
00001372                           715              
00001372                           716              ;Copy the address values into a register
00001372  3412                     717              MOVE.W      (A2),D2
00001374                           718              
00001374                           719              ;Passing in parameters for isolating direction bit
00001374  163C 0008                720              MOVE.B      #8,D3           ;Start bit index = 8
00001378  183C 0001                721              MOVE.B      #1,D4           ;Number of bits needed = 1
0000137C                           722  
0000137C                           723              ;Jumps to getBits and returns with isolated bit in D2
0000137C  6100 FE28                724              BSR         getBits
00001380                           725              
00001380                           726              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001380  B43C 0000                727              CMP.B       #0,D2
00001384  6700 0204                728              BEQ         dnDest
00001388  6000 0224                729              BRA         dnSource
0000138C                           730              
0000138C                           731              
0000138C  6000 FE0C                732              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001390                           733     
00001390                           734     
00001390                           735  *-----------------------------------------------------------
00001390                           736  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001390                           737  *-----------------------------------------------------------  
00001390                           738  M1110: 
00001390  4282                     739              CLR.L       D2
00001392  4283                     740              CLR.L       D3
00001394                           741              
00001394                           742              ;Copy the address values into a register
00001394  3412                     743              MOVE.W     (A2),D2
00001396                           744              
00001396                           745              ;Passing in parameters for isolating bits 6-7
00001396  163C 0006                746              MOVE.B      #6,D3             ;Start bit index = 6
0000139A  183C 0002                747              MOVE.B      #2,D4             ;Number of bits needed = 2
0000139E                           748              
0000139E                           749              ;Jumps to getBits and returns with isolated bits in D2
0000139E  6100 FE06                750              BSR         getBits  
000013A2                           751              
000013A2                           752              ;Check if Memory Shift
000013A2  B43C 0003                753              CMP.B       #%11,D2
000013A6  6700 00B8                754              BEQ         MemShift
000013AA                           755              
000013AA                           756              ;If not Memory Shift, is a Register Shift
000013AA                           757              
000013AA                           758              ;Copy the address values into a register
000013AA  3412                     759              MOVE.W     (A2),D2
000013AC                           760              
000013AC                           761              ;Passing in parameters for isolating bit 3
000013AC  163C 0003                762              MOVE.B      #3,D3             ;Start bit index = 3
000013B0  183C 0001                763              MOVE.B      #1,D4             ;Number of bits needed = 1
000013B4                           764              
000013B4                           765              ;Jumps to getBits and returns with isolated bits in D2
000013B4  6100 FDF0                766              BSR         getBits  
000013B8                           767              
000013B8                           768              ;Checks if ASd
000013B8  B43C 0000                769              CMP.B       #%0,D2
000013BC  6700 00E8                770              BEQ         RegAS
000013C0                           771              
000013C0                           772              ;Checks if LSd
000013C0  B43C 0001                773              CMP.B       #%1,D2
000013C4  6700 00E8                774              BEQ         RegLS
000013C8                           775  RegShift      
000013C8                           776              ;Copy the address values into a register
000013C8  3412                     777              MOVE.W     (A2),D2
000013CA                           778              
000013CA                           779              ;Passing in parameters for isolating bits 6-7
000013CA  163C 0006                780              MOVE.B      #6,D3             ;Start bit index = 6
000013CE  183C 0002                781              MOVE.B      #2,D4             ;Number of bits needed = 2
000013D2                           782              
000013D2                           783              ;Jumps to getBits and returns with isolated bits in D2
000013D2  6100 FDD2                784              BSR         getBits  
000013D6                           785              
000013D6                           786              ;Print Size
000013D6  6100 0238                787              BSR         printSizeSubroutine
000013DA                           788              
000013DA                           789              ;Copy the address values into a register
000013DA  3412                     790              MOVE.W     (A2),D2
000013DC                           791              
000013DC                           792              ;Passing in parameters for isolating bit 5
000013DC  163C 0005                793              MOVE.B      #5,D3             ;Start bit index = 5
000013E0  183C 0001                794              MOVE.B      #1,D4             ;Number of bits needed = 1
000013E4                           795              
000013E4                           796              ;Jumps to getBits and returns with isolated bits in D2
000013E4  6100 FDC0                797              BSR         getBits  
000013E8                           798              
000013E8                           799              ;Checks if shift count is immediate
000013E8  B43C 0000                800              CMP.B       #%0,D2
000013EC  6700 003C                801              BEQ         ImmediateCount
000013F0                           802              
000013F0                           803              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000013F0                           804              ;D7 will contain the register after this instruction
000013F0  6100 0206                805              BSR         isolateRegisterBit9to11
000013F4                           806              
000013F4                           807              ;Save #%000 into D6 to specify data register mode
000013F4  1C3C 0000                808              MOVE.B      #0,D6
000013F8                           809              
000013F8                           810              ;*Print Shift Count address*
000013F8  6100 0258                811              BSR         addressModeSR
000013FC                           812  
000013FC  6100 0002                813              BSR         RegShift2
00001400                           814  
00001400                           815  RegShift2   ;Print comma after shift count
00001400  43F9 000018C9            816              LEA         printComma,A1
00001406  103C 000E                817              MOVE.B      #14,D0
0000140A  4E4F                     818              TRAP        #15
0000140C                           819              
0000140C                           820              ;*Data Register to be Shifted*
0000140C  4282                     821              CLR.L       D2
0000140E                           822              
0000140E                           823              ;Copy the address values into a register
0000140E  3412                     824              MOVE.W      (A2),D2
00001410                           825              
00001410                           826              ;Passing in parameters for isolating bits 0-2
00001410  163C 0000                827              MOVE.B      #0,D3             ;Start bit index = 0
00001414  183C 0003                828              MOVE.B      #3,D4             ;Number of bits needed = 3
00001418                           829              
00001418                           830              ;Jumps to getBits and returns with isolated bits in D2
00001418  6100 FD8C                831              BSR         getBits
0000141C                           832              
0000141C                           833              ;Save Xn register bit into ***D7*** for later use in addressModeSR
0000141C  1E02                     834              MOVE.B      D2,D7
0000141E                           835              
0000141E                           836              ;Save #%000 into D6 to specify data register mode
0000141E  1C3C 0000                837              MOVE.B      #0,D6
00001422                           838              
00001422                           839              ;*Prints data register to be shifted*
00001422  6100 022E                840              BSR         addressModeSR
00001426                           841  
00001426  6000 FD72                842              BRA         update
0000142A                           843              
0000142A                           844  ImmediateCount
0000142A                           845              ;Print #$
0000142A  43F9 000018BB            846              LEA        printIA,A1
00001430  103C 000E                847              MOVE.B     #14,D0
00001434  4E4F                     848              TRAP       #15
00001436                           849              
00001436                           850              ;Copy the address values into a register
00001436  3412                     851              MOVE.W     (A2),D2
00001438                           852              
00001438                           853              ;Passing in parameters for isolating bits 9-11
00001438  163C 0009                854              MOVE.B      #9,D3             ;Start bit index = 9
0000143C  183C 0003                855              MOVE.B      #3,D4             ;Number of bits needed = 3
00001440                           856              
00001440                           857              ;Jumps to getBits and returns with isolated bits in D2
00001440  6100 FD64                858              BSR         getBits  
00001444                           859              
00001444                           860              ;Check if shift count is 8
00001444  B43C 0000                861              CMP.B       #%000,D2
00001448  6700 0010                862              BEQ         ShiftEight
0000144C                           863              
0000144C  1202                     864              MOVE.B      D2, D1
0000144E  6100 0002                865              BSR         ImmediateCount2
00001452                           866             
00001452                           867  ImmediateCount2
00001452                           868              ;Print shift count
00001452  103C 0003                869              MOVE.B      #3,D0
00001456  4E4F                     870              TRAP        #15
00001458  61A6                     871              BSR         RegShift2
0000145A                           872   
0000145A                           873  ShiftEight  ;Move 8 into D1    
0000145A  123C 0008                874              MOVE.B      #8, D1
0000145E  61F2                     875              BSR         ImmediateCount2
00001460                           876                                     
00001460                           877  MemShift
00001460                           878              ;Copy the address values into a register
00001460  3412                     879              MOVE.W     (A2),D2
00001462                           880              
00001462                           881              ;Passing in parameters for isolating bit 9
00001462  163C 0009                882              MOVE.B      #9,D3             ;Start bit index = 9
00001466  183C 0001                883              MOVE.B      #1,D4             ;Number of bits needed = 1
0000146A                           884              
0000146A                           885              ;Jumps to getBits and returns with isolated bits in D2
0000146A  6100 FD3A                886              BSR         getBits  
0000146E                           887              
0000146E                           888              ;Checks if ASd
0000146E  B43C 0000                889              CMP.B       #%0,D2
00001472  6700 0022                890              BEQ         MemAS
00001476                           891              
00001476                           892              ;Checks if LSd
00001476  B43C 0001                893              CMP.B       #%1,D2
0000147A  6700 0022                894              BEQ         MemLS
0000147E                           895  
0000147E                           896  MemShift2   
0000147E                           897              ;Print Space
0000147E  43F9 000018CB            898              LEA        printSpace,A1
00001484  103C 000E                899              MOVE.B     #14,D0
00001488  4E4F                     900              TRAP       #15
0000148A                           901              
0000148A                           902              ;*Memory Address*
0000148A                           903              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000148A                           904              ;D6 will contain mode & D7 will contain the register after this instruction
0000148A  6100 0146                905              BSR         isolateAddressBit0to5
0000148E                           906              
0000148E                           907              ;*Print source address*
0000148E  6100 01C2                908              BSR         addressModeSR
00001492                           909              
00001492  6000 FD06                910              BRA         update
00001496                           911              
00001496                           912  MemAS       ;Print AS
00001496  6100 002C                913              BSR         MAS      
0000149A  6100 0036                914              BSR         MemDirectionSubroutine                
0000149E                           915  
0000149E                           916              
0000149E                           917  MemLS       ;Print LS
0000149E  6100 0016                918              BSR         MLS      
000014A2  6100 002E                919              BSR         MemDirectionSubroutine
000014A6                           920              
000014A6                           921  RegAS       ;Print AS
000014A6  6100 001C                922              BSR         MAS      
000014AA  6100 0062                923              BSR         RegDirectionSubroutine                
000014AE                           924  
000014AE                           925              
000014AE                           926  RegLS       ;Print LS
000014AE  6100 0006                927              BSR         MLS      
000014B2  6100 005A                928              BSR         RegDirectionSubroutine
000014B6                           929  
000014B6                           930  MLS:
000014B6  43F9 00001897            931              LEA        printMLS,A1
000014BC  103C 000E                932              MOVE.B     #14,D0
000014C0  4E4F                     933              TRAP       #15
000014C2  4E75                     934              RTS
000014C4                           935  MAS:
000014C4  43F9 00001892            936              LEA        printMAS,A1
000014CA  103C 000E                937              MOVE.B     #14,D0
000014CE  4E4F                     938              TRAP       #15
000014D0  4E75                     939              RTS
000014D2                           940  
000014D2                           941  MemDirectionSubroutine
000014D2                           942              ;Copy the address values into a register
000014D2  3412                     943              MOVE.W     (A2),D2
000014D4                           944              
000014D4                           945              ;Passing in parameters for isolating bit 8
000014D4  163C 0008                946              MOVE.B      #8,D3             ;Start bit index = 8
000014D8  183C 0001                947              MOVE.B      #1,D4             ;Number of bits needed = 1
000014DC                           948              
000014DC                           949              ;Jumps to getBits and returns with isolated bits in D2
000014DC  6100 FCC8                950              BSR         getBits  
000014E0                           951              
000014E0                           952              ;Checks if Right
000014E0  B43C 0000                953              CMP.B       #%0,D2
000014E4  6700 000A                954              BEQ         MR
000014E8                           955              
000014E8                           956              ;Checks if Left
000014E8  B43C 0001                957              CMP.B       #%1,D2
000014EC  6700 0010                958              BEQ         ML
000014F0                           959                          
000014F0  43F9 0000189E            960  MR          LEA        printR,A1
000014F6  103C 000E                961              MOVE.B     #14,D0
000014FA  4E4F                     962              TRAP       #15
000014FC  6180                     963              BSR        MemShift2
000014FE                           964  
000014FE  43F9 0000189C            965  ML          LEA        printL,A1
00001504  103C 000E                966              MOVE.B     #14,D0
00001508  4E4F                     967              TRAP       #15
0000150A  6100 FF72                968              BSR        MemShift2
0000150E                           969              
0000150E                           970  RegDirectionSubroutine
0000150E                           971              ;Copy the address values into a register
0000150E  3412                     972              MOVE.W     (A2),D2
00001510                           973              
00001510                           974              ;Passing in parameters for isolating bit 8
00001510  163C 0008                975              MOVE.B      #8,D3             ;Start bit index = 8
00001514  183C 0001                976              MOVE.B      #1,D4             ;Number of bits needed = 1
00001518                           977              
00001518                           978              ;Jumps to getBits and returns with isolated bits in D2
00001518  6100 FC8C                979              BSR         getBits  
0000151C                           980              
0000151C                           981              ;Checks if Right
0000151C  B43C 0000                982              CMP.B       #%0,D2
00001520  6700 000A                983              BEQ         RR
00001524                           984              
00001524                           985              ;Checks if Left
00001524  B43C 0001                986              CMP.B       #%1,D2
00001528  6700 0012                987              BEQ         RL
0000152C                           988                          
0000152C  43F9 0000189E            989  RR          LEA        printR,A1
00001532  103C 000E                990              MOVE.B     #14,D0
00001536  4E4F                     991              TRAP       #15
00001538  6100 FE8E                992              BSR        RegShift
0000153C                           993  
0000153C  43F9 0000189C            994  RL          LEA        printL,A1
00001542  103C 000E                995              MOVE.B     #14,D0
00001546  4E4F                     996              TRAP       #15
00001548  6100 FE7E                997              BSR        RegShift
0000154C                           998  *-----------------------------------------------------------------------
0000154C                           999  *-----------------------------------------------------------------------
0000154C                          1000  *-----------------------------------------------------------------------
0000154C                          1001  
0000154C                          1002  
0000154C                          1003  
0000154C                          1004  
0000154C                          1005  ;ADD
0000154C                          1006  M1101:
0000154C  43F9 00001823           1007              LEA        printADD,A1
00001552  103C 000E               1008              MOVE.B     #14,D0
00001556  4E4F                    1009              TRAP       #15
00001558                          1010              
00001558  4202                    1011              CLR.B      D2
0000155A  4203                    1012              CLR.B      D3
0000155C                          1013              
0000155C                          1014              ;======Isolate Size (S) Bits=======
0000155C                          1015              ;Copy the address values into a register
0000155C  3412                    1016              MOVE.W     (A2),D2
0000155E                          1017              
0000155E                          1018              ;Passing in parameters for isolating size bits
0000155E  163C 0006               1019              MOVE.B      #6,D3             ;Start bit index = 6
00001562  183C 0002               1020              MOVE.B      #2,D4             ;Number of bits needed = 2
00001566                          1021              
00001566                          1022              ;Jumps to getBits and returns with isolated bits in D2
00001566  6100 FC3E               1023              BSR         getBits  
0000156A                          1024              
0000156A                          1025              ;Jumps to printSizeSubroutine and returns after size has been printed
0000156A  6100 00A4               1026              BSR         printSizeSubroutine
0000156E                          1027         
0000156E                          1028              ;======Isolate direction (D) Bit=======
0000156E                          1029              ; 0 = data register is destination | 1 = Dn is source
0000156E  4282                    1030              CLR.L       D2
00001570                          1031              
00001570                          1032              ;Copy the address values into a register
00001570  3412                    1033              MOVE.W      (A2),D2
00001572                          1034              
00001572                          1035              ;Passing in parameters for isolating direction bit
00001572  163C 0008               1036              MOVE.B      #8,D3             ;Start bit index = 8
00001576  183C 0001               1037              MOVE.B      #1,D4             ;Number of bits needed = 1
0000157A                          1038              
0000157A                          1039              ;Jumps to getBits and returns with isolated bit in D2
0000157A  6100 FC2A               1040              BSR         getBits
0000157E                          1041              
0000157E                          1042              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
0000157E  B43C 0000               1043              CMP.B       #0,D2
00001582  6700 0006               1044              BEQ         dnDest
00001586  6000 0026               1045              BRA         dnSource
0000158A                          1046              
0000158A                          1047  
0000158A                          1048  *-----------------------------------------------------------------
0000158A                          1049  * dnDest, dnSource, & other subroutines for isolating address bits
0000158A                          1050  *-----------------------------------------------------------------
0000158A                          1051  ;* dnDest,dnSource *
0000158A                          1052  ;For: MULS,AND,ADD,SUB,DIVU
0000158A                          1053  ;Used by instructions that require Dn as one of their addressing modes.
0000158A                          1054  ;dnDest isolates the addressing bits with Dn being the destination address
0000158A                          1055  ;dnSource isolates the addressing bits with Dn being the source address
0000158A                          1056  
0000158A                          1057  dnDest:
0000158A                          1058              ;**Used for isolating addressing bits when Dn is the destination**
0000158A                          1059              
0000158A                          1060              ;*SOURCE*
0000158A                          1061              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000158A                          1062              ;D6 will contain mode & D7 will contain the register after this instruction
0000158A  6100 0046               1063              BSR         isolateAddressBit0to5
0000158E                          1064              
0000158E                          1065              ;*Print source address*
0000158E  6100 00C2               1066              BSR         addressModeSR
00001592                          1067              
00001592                          1068              ;Print comma after source address
00001592  43F9 000018C9           1069              LEA         printComma,A1
00001598  103C 000E               1070              MOVE.B      #14,D0
0000159C  4E4F                    1071              TRAP        #15
0000159E                          1072              
0000159E                          1073              ;*DESTINATION*
0000159E                          1074              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000159E                          1075              ;D7 will contain the register after this instruction
0000159E  6100 0058               1076              BSR         isolateRegisterBit9to11
000015A2                          1077              
000015A2                          1078              ;Save #%000 into D6 to specify data register mode
000015A2  1C3C 0000               1079              MOVE.B      #0,D6
000015A6                          1080              
000015A6                          1081              ;*Print destination address*
000015A6  6100 00AA               1082              BSR         addressModeSR
000015AA                          1083  
000015AA  6000 FBEE               1084              BRA         update
000015AE                          1085              
000015AE                          1086  dnSource:
000015AE                          1087              ;**Used for isolating addressing bits when Dn is the destination**
000015AE                          1088                          
000015AE                          1089              ;*SOURCE*
000015AE                          1090              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000015AE                          1091              ;D7 will contain the register after this instruction
000015AE  6100 0048               1092              BSR         isolateRegisterBit9to11
000015B2                          1093              
000015B2                          1094              ;Save #%000 into D6 to specify data register mode
000015B2  1C3C 0000               1095              MOVE.B      #0,D6
000015B6                          1096              
000015B6                          1097              ;*Print Source address*
000015B6  6100 009A               1098              BSR         addressModeSR
000015BA                          1099              
000015BA                          1100              ;Print comma after source address
000015BA  43F9 000018C9           1101              LEA         printComma,A1
000015C0  103C 000E               1102              MOVE.B      #14,D0
000015C4  4E4F                    1103              TRAP        #15
000015C6                          1104              
000015C6                          1105              ;*DESTINATION*
000015C6                          1106              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000015C6                          1107              ;D6 will contain mode & D7 will contain the register after this instruction
000015C6  6100 000A               1108              BSR         isolateAddressBit0to5
000015CA                          1109              
000015CA                          1110              ;*Print destination address*
000015CA  6100 0086               1111              BSR         addressModeSR
000015CE                          1112  
000015CE  6000 FBCA               1113              BRA         update
000015D2                          1114                     
000015D2                          1115  isolateAddressBit0to5:
000015D2                          1116  ;Helper subroutine for isolating the address stored within bits 0-5
000015D2                          1117  ;Stores address mode in D6
000015D2                          1118  ;Stores address register in D7
000015D2                          1119  
000015D2                          1120              ;======Isolate Effective Address Mode (M) Bits=======
000015D2  4282                    1121              CLR.L       D2
000015D4                          1122              
000015D4                          1123              ;Copy the address values into a register
000015D4  3412                    1124              MOVE.W      (A2),D2
000015D6                          1125              
000015D6                          1126              ;Passing in parameters for isolating Mode bits
000015D6  163C 0003               1127              MOVE.B      #3,D3             ;Start bit index = 3
000015DA  183C 0003               1128              MOVE.B      #3,D4             ;Number of bits needed = 3
000015DE                          1129              
000015DE                          1130              ;Jumps to getBits and returns with isolated bits in D2
000015DE  4EB8 11A6               1131              JSR         getBits
000015E2                          1132              
000015E2                          1133              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000015E2  1C02                    1134              MOVE.B      D2,D6
000015E4                          1135              
000015E4                          1136                       
000015E4                          1137              ;======Isolate Effective Address Register (Xn) Bits=======
000015E4  4282                    1138              CLR.L       D2
000015E6                          1139              
000015E6                          1140              ;Copy the address values into a register
000015E6  3412                    1141              MOVE.W      (A2),D2
000015E8                          1142              
000015E8                          1143              ;Passing in parameters for isolating Xn bits
000015E8  163C 0000               1144              MOVE.B      #0,D3             ;Start bit index = 0
000015EC  183C 0003               1145              MOVE.B      #3,D4             ;Number of bits needed = 3
000015F0                          1146              
000015F0                          1147              ;Jumps to getBits and returns with isolated bits in D2
000015F0  6100 FBB4               1148              BSR         getBits
000015F4                          1149              
000015F4                          1150              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000015F4  1E02                    1151              MOVE.B      D2,D7
000015F6                          1152              
000015F6  4E75                    1153              RTS
000015F8                          1154  
000015F8                          1155  isolateRegisterBit9to11:
000015F8                          1156  ;Helper subroutine for isolating the register stored within bits 9-11
000015F8                          1157  ;Stores the address register in D7
000015F8                          1158  
000015F8                          1159              ;======Isolate Register Bits=======
000015F8  4282                    1160              CLR.L       D2
000015FA  4286                    1161              CLR.L       D6
000015FC  4287                    1162              CLR.L       D7
000015FE                          1163              
000015FE                          1164              ;Copy the address values into a register
000015FE  3412                    1165              MOVE.W      (A2),D2
00001600                          1166              
00001600                          1167              ;Passing in parameters for isolating register bits
00001600  163C 0009               1168              MOVE.B      #9,D3             ;Start bit index = 9
00001604  183C 0003               1169              MOVE.B      #3,D4             ;Number of bits needed = 3
00001608                          1170              
00001608                          1171              ;Jumps to getBits and returns with isolated bit in D2
00001608  6100 FB9C               1172              BSR         getBits
0000160C                          1173              
0000160C                          1174              ;Save register bit into ***D7*** for later use in addressModeSR
0000160C  1E02                    1175              MOVE.B      D2,D7
0000160E                          1176  
0000160E  4E75                    1177              RTS
00001610                          1178              
00001610                          1179  *-----------------------------------------------------------
00001610                          1180  * Print Sizes
00001610                          1181  *-----------------------------------------------------------
00001610                          1182  printSizeSubroutine:
00001610                          1183              ;Prints the apporpriate size
00001610                          1184              ;PARAMETER:
00001610                          1185              ;D2 = the size bits
00001610                          1186              
00001610                          1187              ;Compare to which size is being moved for the opcode
00001610  B43C 0000               1188              CMP.B      #%00,D2
00001614  6700 0012               1189              BEQ        PByte
00001618                          1190              
00001618  B43C 0001               1191              CMP.B      #%01,D2
0000161C  6700 0018               1192              BEQ        PWord
00001620                          1193              
00001620  B43C 0002               1194              CMP.B      #%10,D2
00001624  6700 001E               1195              BEQ        PLong
00001628                          1196              
00001628                          1197  PByte:
00001628  43F9 000018A0           1198              LEA        printSIZEB,A1
0000162E  103C 000E               1199              MOVE.B     #14,D0
00001632  4E4F                    1200              TRAP       #15
00001634                          1201              
00001634  4E75                    1202              RTS
00001636                          1203  PWord:
00001636  43F9 000018A4           1204              LEA        printSIZEW,A1
0000163C  103C 000E               1205              MOVE.B     #14,D0
00001640  4E4F                    1206              TRAP       #15
00001642                          1207              
00001642  4E75                    1208              RTS
00001644                          1209  PLong:            
00001644  43F9 000018AA           1210              LEA        printSIZEL,A1
0000164A  103C 000E               1211              MOVE.B     #14,D0
0000164E  4E4F                    1212              TRAP       #15
00001650                          1213              
00001650                          1214              ;NOTE: no error message for #%11 so ASd/LSd can use this subroutine
00001650  4E75                    1215              RTS
00001652                          1216              
00001652                          1217              
00001652                          1218  *-----------------------------------------------------------
00001652                          1219  * Addressing Mode Implementation
00001652                          1220  *-----------------------------------------------------------
00001652                          1221  addressModeSR:
00001652                          1222              ;Prints address according to the parameters passed in
00001652                          1223              ;PARAMETERS:
00001652                          1224              ;D6 = mode
00001652                          1225              ;D7 = register
00001652                          1226  
00001652                          1227              ;Data register direct
00001652  BC3C 0000               1228              CMP.B       #%000,D6
00001656  6700 0022               1229              BEQ         DRD
0000165A                          1230              
0000165A                          1231              ;Address register direct
0000165A  BC3C 0001               1232              CMP.B       #%001,D6
0000165E  6700 002E               1233              BEQ         ARD
00001662                          1234              
00001662                          1235              ;Address register indirect
00001662  BC3C 0002               1236              CMP.B       #%010,D6
00001666  6700 003A               1237              BEQ         ARI
0000166A                          1238              
0000166A                          1239              ;Post Increment
0000166A  BC3C 0003               1240              CMP.B       #%011,D6
0000166E  6700 0052               1241              BEQ         PI
00001672                          1242              
00001672                          1243              ;Pre Decrement
00001672  BC3C 0004               1244              CMP.B       #%100,D6
00001676  6700 006A               1245              BEQ         PD
0000167A                          1246  DRD:
0000167A                          1247              ;Print D __
0000167A  43F9 000018B2           1248              LEA         printDRD,A1
00001680  103C 000E               1249              MOVE.B      #14,D0
00001684  4E4F                    1250              TRAP        #15
00001686                          1251              
00001686                          1252              ;Print register number
00001686  7003                    1253              MOVE.L      #3,D0
00001688  2207                    1254              MOVE.L      D7,D1
0000168A  4E4F                    1255              TRAP        #15
0000168C                          1256              
0000168C  4E75                    1257              RTS
0000168E                          1258  ARD:
0000168E                          1259              ;Print A __
0000168E  43F9 000018B4           1260              LEA         printARD,A1
00001694  103C 000E               1261              MOVE.B      #14,D0
00001698  4E4F                    1262              TRAP        #15
0000169A                          1263              
0000169A                          1264              ;Print register number
0000169A  7003                    1265              MOVE.L      #3,D0
0000169C  2207                    1266              MOVE.L      D7,D1
0000169E  4E4F                    1267              TRAP        #15
000016A0                          1268              
000016A0  4E75                    1269              RTS
000016A2                          1270  ARI:
000016A2                          1271              ;Print (A __ )
000016A2  43F9 000018B6           1272              LEA         printARI,A1
000016A8  103C 000E               1273              MOVE.B      #14,D0
000016AC  4E4F                    1274              TRAP        #15
000016AE                          1275              
000016AE                          1276              ;Print register number
000016AE  7003                    1277              MOVE.L      #3,D0
000016B0  2207                    1278              MOVE.L      D7,D1
000016B2  4E4F                    1279              TRAP        #15
000016B4                          1280              
000016B4                          1281              ;Print closing ')'
000016B4  43F9 000018B9           1282              LEA         printARI2,A1
000016BA  103C 000E               1283              MOVE.B      #14,D0
000016BE  4E4F                    1284              TRAP        #15
000016C0                          1285              
000016C0  4E75                    1286              RTS
000016C2                          1287  PI:
000016C2                          1288              ;Print (A __)+
000016C2  43F9 000018BD           1289              LEA         printPI,A1
000016C8  103C 000E               1290              MOVE.B      #14,D0
000016CC  4E4F                    1291              TRAP        #15
000016CE                          1292              
000016CE                          1293              ;Print register number
000016CE  7003                    1294              MOVE.L      #3,D0
000016D0  2207                    1295              MOVE.L      D7,D1
000016D2  4E4F                    1296              TRAP        #15
000016D4                          1297              
000016D4                          1298              ;Print closing ')+'
000016D4  43F9 000018C0           1299              LEA         printPI2,A1
000016DA  103C 000E               1300              MOVE.B      #14,D0
000016DE  4E4F                    1301              TRAP        #15
000016E0                          1302              
000016E0  4E75                    1303              RTS
000016E2                          1304  PD:
000016E2                          1305              ;Print -(A __)
000016E2  43F9 000018C3           1306              LEA         printPD,A1
000016E8  103C 000E               1307              MOVE.B      #14,D0
000016EC  4E4F                    1308              TRAP        #15
000016EE                          1309              
000016EE                          1310              ;Print register number
000016EE  7003                    1311              MOVE.L      #3,D0
000016F0  2207                    1312              MOVE.L      D7,D1
000016F2  4E4F                    1313              TRAP        #15
000016F4                          1314              
000016F4                          1315              ;Print closing ')'
000016F4  43F9 000018C7           1316              LEA         printPD2,A1
000016FA  103C 000E               1317              MOVE.B      #14,D0
000016FE  4E4F                    1318              TRAP        #15
00001700                          1319              
00001700  4E75                    1320              RTS
00001702                          1321  IA:
00001702                          1322              ;Print #$ ______
00001702  4E75                    1323              RTS
00001704                          1324  ALA:
00001704                          1325              ;Print $-------- (8 digits)
00001704  4E75                    1326              RTS
00001706                          1327  AWA:
00001706                          1328              ;Print $---- (4 digits)
00001706  4E75                    1329              RTS
00001708                          1330  
00001708                          1331  
00001708                          1332  *-----------------------------------------------------------
00001708                          1333  * Print Instructions for NOP and RTS
00001708                          1334  *-----------------------------------------------------------
00001708                          1335  printN:
00001708  43F9 0000180E           1336              LEA        printNOP,A1
0000170E  103C 000E               1337              MOVE.B     #14,D0
00001712  4E4F                    1338              TRAP       #15
00001714                          1339              
00001714  6000 FA84               1340              BRA        update
00001718                          1341  
00001718                          1342  printMRTS:
00001718  43F9 00001886           1343              LEA        printRTS,A1
0000171E  103C 000E               1344              MOVE.B     #14,D0
00001722  4E4F                    1345              TRAP       #15
00001724                          1346              
00001724  6000 FA74               1347              BRA        update
00001728                          1348  ;-----------------------------------------------------------
00001728                          1349  ;ERROR MESSAGES FOR I/O portion
00001728                          1350  ;-----------------------------------------------------------
00001728                          1351  charError:
00001728                          1352              
00001728  43F9 000018EE           1353              LEA         invalCh,A1
0000172E  103C 000E               1354              MOVE.B      #14,D0
00001732  4E4F                    1355              TRAP        #15
00001734                          1356              
00001734  6000 F8EA               1357              BRA         startingPrompt
00001738                          1358            
00001738                          1359  oddError:
00001738  43F9 0000190F           1360              LEA         odd,A1
0000173E  103C 000E               1361              MOVE.B      #14,D0
00001742  4E4F                    1362              TRAP        #15
00001744                          1363              
00001744  6000 F8DA               1364              BRA         startingPrompt
00001748                          1365              
00001748                          1366  manyCharError:  
00001748  43F9 0000193C           1367              LEA         manyChar, A1
0000174E  103C 000E               1368              MOVE.B      #14,D0
00001752  4E4F                    1369              TRAP        #15
00001754                          1370              
00001754  6000 F8CA               1371              BRA         startingPrompt
00001758                          1372           
00001758                          1373  endGreater:
00001758  43F9 00001977           1374              LEA         endG,A1
0000175E  103C 000E               1375              MOVE.B      #14,D0
00001762  4E4F                    1376              TRAP        #15
00001764                          1377              
00001764  6000 F8BA               1378              BRA         startingPrompt
00001768                          1379      
00001768                          1380  ;-----------------------------------------------------------
00001768                          1381  ;MESSAGES
00001768                          1382  ;-----------------------------------------------------------
00001768= 57 65 6C 63 6F 6D ...   1383  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
0000178C= 50 6C 65 61 73 65 ...   1384  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
000017CE= 50 6C 65 61 73 65 ...   1385  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
0000180E                          1386  
0000180E                          1387  ;-----------------------------------------------------------
0000180E                          1388  ;OPCODE Messages
0000180E                          1389  ;-----------------------------------------------------------
0000180E= 0D 0A 4E 4F 50 00       1390  printNOP    DC.B        CR,LF,'NOP',0
00001814= 0D 0A 4D 4F 56 45 00    1391  printMOVE   DC.B        CR,LF,'MOVE',0
0000181B= 0D 0A 4D 4F 56 45 ...   1392  printMOVEM  DC.B        CR,LF,'MOVEM',0
00001823= 0D 0A 41 44 44 00       1393  printADD    DC.B        CR,LF,'ADD',0
00001829= 0D 0A 53 55 42 00       1394  printSUB    DC.B        CR,LF,'SUB',0
0000182F= 0D 0A 4D 55 4C 53 ...   1395  printMULS   DC.B        CR,LF,'MULS.W ',0
00001839= 0D 0A 44 49 56 55 ...   1396  printDIVU   DC.B        CR,LF,'DIVU.W ',0
00001843= 0D 0A 4C 45 41 20 00    1397  printLEA    DC.B        CR,LF,'LEA ',0
0000184A= 0D 0A 41 4E 44 00       1398  printAND    DC.B        CR,LF,'AND',0
00001850= 0D 0A 4E 4F 54 00       1399  printNOT    DC.B        CR,LF,'NOT',0
00001856= 0D 0A 4C 53 4C 00       1400  printLSL    DC.B        CR,LF,'LSL',0
0000185C= 0D 0A 4C 53 52 00       1401  printLSR    DC.B        CR,LF,'LSR',0
00001862= 0D 0A 41 53 4C 00       1402  printASL    DC.B        CR,LF,'ASL',0
00001868= 0D 0A 41 53 52 00       1403  printASR    DC.B        CR,LF,'ASR',0
0000186E= 0D 0A 42 4C 54 00       1404  printBLT    DC.B        CR,LF,'BLT',0
00001874= 0D 0A 42 47 45 00       1405  printBGE    DC.B        CR,LF,'BGE',0
0000187A= 0D 0A 42 45 51 00       1406  printBEQ    DC.B        CR,LF,'BEQ',0
00001880= 0D 0A 4A 53 52 00       1407  printJSR    DC.B        CR,LF,'JSR',0
00001886= 0D 0A 52 54 53 00       1408  printRTS    DC.B        CR,LF,'RTS',0
0000188C= 0D 0A 42 52 41 00       1409  printBRA    DC.B        CR,LF,'BRA',0
00001892= 0D 0A 41 53 00          1410  printMAS    DC.B        CR,LF,'AS',0
00001897= 0D 0A 4C 53 00          1411  printMLS    DC.B        CR,LF,'LS',0
0000189C= 4C 00                   1412  printL      DC.B        'L',0
0000189E= 52 00                   1413  printR      DC.B        'R',0
000018A0                          1414  
000018A0                          1415  
000018A0                          1416  ;-----------------------------------------------------------
000018A0                          1417  ;Size Messages
000018A0                          1418  ;-----------------------------------------------------------
000018A0= 2E 42 20 00             1419  printSIZEB   DC.B        '.B ',0
000018A4= 2E57 2000 0000          1420  printSIZEW   DC.W        '.W ',0
000018AA= 2E4C2000 00000000       1421  printSIZEL   DC.L        '.L ',0
000018B2                          1422  
000018B2                          1423  ;-----------------------------------------------------------
000018B2                          1424  ;Addressing Mode Messages
000018B2                          1425  ;-----------------------------------------------------------
000018B2= 44 00                   1426  printDRD      DC.B        'D',0
000018B4= 41 00                   1427  printARD      DC.B        'A',0
000018B6= 28 41 00                1428  printARI      DC.B        '(A',0
000018B9= 29 00                   1429  printARI2     DC.B        ')',0
000018BB= 23 00                   1430  printIA       DC.B        '#',0
000018BD= 28 41 00                1431  printPI       DC.B        '(A',0
000018C0= 29 2B 00                1432  printPI2      DC.B        ')+',0
000018C3= 2D 28 41 00             1433  printPD       DC.B        '-(A',0
000018C7= 29 00                   1434  printPD2      DC.B        ')',0
000018C9                          1435  ;printAA       DC.B        ''   /TBD
000018C9                          1436  
000018C9= 2C 00                   1437  printComma    DC.B        ',',0
000018CB= 20 00                   1438  printSpace    DC.B        ' ',0
000018CD                          1439  
000018CD= 0D 0A 59 6F 75 20 ...   1440  theEnd      DC.B        CR,LF,'You are now ending the program',0
000018EE                          1441  
000018EE                          1442  ;-----------------------------------------------------------
000018EE                          1443  ;ERRORS
000018EE                          1444  ;-----------------------------------------------------------
000018EE= 45 52 52 4F 52 3A ...   1445  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
0000190F= 45 52 52 4F 52 3A ...   1446  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
0000193C= 45 52 52 4F 52 3A ...   1447  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001977= 45 52 52 4F 52 3A ...   1448  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
000019BC= 45 52 52 4F 52 3A ...   1449  sizeError   DC.B        'ERROR: Invalid size instruction',0
000019DC                          1450  
000019DC                          1451  ;-----------------------------------------------------------
000019DC                          1452  ;Ending function that ends our program 
000019DC                          1453  ;-----------------------------------------------------------
000019DC                          1454  ending:
000019DC  43F8 18CD               1455              LEA         theEnd,A1
000019E0  303C 000E               1456              MOVE        #14,D0
000019E4  4E4F                    1457              TRAP        #15
000019E6                          1458              
000019E6                          1459              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESSMODESR       1652
ALA                 1704
ARD                 168E
ARI                 16A2
AWA                 1706
CHARERROR           1728
CONTINUEDIVU        12CE
CONVERT             1074
CR                  D
DNDEST              158A
DNSOURCE            15AE
DRD                 167A
ENDG                1977
ENDGREATER          1758
ENDHEX              1004
ENDING              19DC
ENDINGPROMPT        104C
GETBITS             11A6
IA                  1702
IMMEDIATECOUNT      142A
IMMEDIATECOUNT2     1452
INVALCH             18EE
ISOLATEADDRESSBIT0TO5  15D2
ISOLATEREGISTERBIT9TO11  15F8
LETTER              1098
LF                  A
LOOP                1128
M00                 11BC
M0100               11E2
M0110               12B2
M1000               12B2
M1001               12DE
M1100               131C
M1101               154C
M1110               1390
MAIN                1000
MAND                1360
MANYCHAR            193C
MANYCHARERROR       1748
MAS                 14C4
MBEQ                12B2
MBGE                12B2
MBLT                12B2
MBRA                12B2
MEMAS               1496
MEMDIRECTIONSUBROUTINE  14D2
MEMLS               149E
MEMSHIFT            1460
MEMSHIFT2           147E
MJSR                129A
ML                  14FE
MLEA                123E
MLS                 14B6
MMULS               1350
MNOT                126E
MORECHECKS          10C8
MORECHECKS1         10D4
MORECHECKS2         10F6
MOVEM               123E
MR                  14F0
MULSCHECK           133A
NUMBER              10AC
ODD                 190F
ODDERROR            1738
PBYTE               1628
PD                  16E2
PI                  16C2
PLONG               1644
PRINTADD            1823
PRINTAND            184A
PRINTARD            18B4
PRINTARI            18B6
PRINTARI2           18B9
PRINTASL            1862
PRINTASR            1868
PRINTBEQ            187A
PRINTBGE            1874
PRINTBLT            186E
PRINTBRA            188C
PRINTCOMMA          18C9
PRINTDIVU           1839
PRINTDRD            18B2
PRINTIA             18BB
PRINTJSR            1880
PRINTL              189C
PRINTLEA            1843
PRINTLSL            1856
PRINTLSR            185C
PRINTMAS            1892
PRINTMLS            1897
PRINTMOVE           1814
PRINTMOVEM          181B
PRINTMRTS           1718
PRINTMULS           182F
PRINTN              1708
PRINTNOP            180E
PRINTNOT            1850
PRINTPD             18C3
PRINTPD2            18C7
PRINTPI             18BD
PRINTPI2            18C0
PRINTR              189E
PRINTRTS            1886
PRINTSIZEB          18A0
PRINTSIZEL          18AA
PRINTSIZESUBROUTINE  1610
PRINTSIZEW          18A4
PRINTSPACE          18CB
PRINTSUB            1829
PWORD               1636
REGAS               14A6
REGDIRECTIONSUBROUTINE  150E
REGLS               14AE
REGSHIFT            13C8
REGSHIFT2           1400
RL                  153C
RR                  152C
SHIFTEIGHT          145A
SIZEERROR           19BC
STAHEX              1000
STARTINGPROMPT      1020
THEEND              18CD
UPDATE              119A
USEREA              17CE
USERSA              178C
WELCOME             1768
