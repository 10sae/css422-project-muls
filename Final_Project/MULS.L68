00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/29/2021 3:01:46 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  
00000000                             7  
00000000                             8  *Current version on the virtual machine
00000000                             9  
00000000                            10  *-----------------------------------------------------------
00001000                            11  MAIN:       ORG         $1000
00001000                            12  
00001000  =0000000D                 13  CR:         EQU         $0D
00001000  =0000000A                 14  LF:         EQU         $0A
00001000                            15  
00001000= 00000000                  16  staHex:     DC.L        $0
00001004= 00000000                  17  endHex:     DC.L        $0
00001008                            18  *-----------------------------------------------------------
00001008                            19  * I/O Implementation
00001008                            20  ;1. Prompt user for start and ending addresses (In hex)
00001008                            21  ;2. User inputs their values
00001008                            22  ;3. Check for errors
00001008                            23  ;        Check to see if hex is too big
00001008                            24  ;        Check to see value doesn't contain G-Z
00001008                            25  ;        Check to see if there are no commas/special chars
00001008                            26  ;        Check to see that starting loc, is before ending loc
00001008                            27  ;        Check to see if value starts at odd mem location
00001008                            28  *-----------------------------------------------------------
00001008                            29              ;Show welcome to user
00001008  43F9 000019E2             30              LEA         Welcome,A1
0000100E  103C 000E                 31              MOVE.B      #14,D0
00001012  4E4F                      32              TRAP        #15
00001014                            33                     
00001014                            34              ;===TESTING===
00001014  4EB9 0000101A             35              JSR      testing
0000101A                            36              
0000101A                            37  ;===TESTING================            
0000101A                            38  testing:
0000101A                            39  
0000101A                            40  ;See what you can do with MOVEM
0000101A                            41  ;Implement the rest of the opcodes when the other members have them
0000101A  0603 000C                 42              ADD.B       #12,D3
0000101E  0647 04D2                 43              ADD.W       #1234,D7
00001022  0684 00BC614E             44              ADD.L       #12345678,D4
00001028                            45              
00001028                            46              
00001028  0403 000C                 47              SUB.B       #12,D3
0000102C  0445 04D2                 48              SUB.W       #1234,D5
00001030  0486 00BC614E             49              SUB.L       #12345678,D6
00001036                            50              
00001036                            51  ;==========================            
00001036                            52              
00001036                            53  startingPrompt:
00001036                            54              ;Ask the user for the starting hex3
00001036  43F9 00001A06             55              LEA         userSA,A1
0000103C  103C 000E                 56              MOVE.B      #14,D0
00001040  4E4F                      57              TRAP        #15        
00001042                            58              
00001042                            59              ;Clear the registers in case we had an error
00001042  227C 00000000             60              MOVE.L      #0,A1
00001048  247C 00000000             61              MOVE.L      #0,A2
0000104E  4283                      62              CLR.L       D3
00001050  4284                      63              CLR.L       D4
00001052  4285                      64              CLR.L       D5
00001054  4286                      65              CLR.L       D6
00001056                            66             
00001056                            67              
00001056                            68              ;Input for the hex (D1 equals number of chars)
00001056  303C 0002                 69              MOVE.W      #2,D0
0000105A  4E4F                      70              TRAP        #15
0000105C                            71              
0000105C                            72              ;Moves A1 into A2      
0000105C                            73              ;MOVEA.L     A1,A2
0000105C                            74              
0000105C                            75              ;Makes sure D7 is clear incase we're looping back after an error.
0000105C  4207                      76              CLR.B       D7
0000105E                            77              
0000105E  6000 002A                 78              BRA         convert  
00001062                            79              
00001062                            80  endingPrompt:
00001062                            81              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001062  1E3C 0001                 82              MOVE.B       #1,D7
00001066                            83              
00001066                            84              ;Ask the user for the ending hex
00001066  43F9 00001A48             85              LEA         userEA,A1
0000106C  103C 000E                 86              MOVE.B      #14,D0
00001070  4E4F                      87              TRAP        #15
00001072                            88              
00001072                            89              ;Clearing the registers so we can reuse them for the ending address
00001072  227C 00000000             90              MOVE.L      #0,A1
00001078  247C 00000000             91              MOVE.L      #0,A2
0000107E  4286                      92              CLR.L       D6
00001080                            93  
00001080                            94              ;Input for the hex (D1 equals number of chars)
00001080  303C 0002                 95              MOVE.W      #2,D0
00001084  4E4F                      96              TRAP        #15
00001086                            97              
00001086                            98              ;Moves A1 into A2      
00001086                            99              ;MOVEA.L     A1,A2
00001086                           100              
00001086  6000 0002                101              BRA         convert
0000108A                           102  
0000108A                           103  convert:    
0000108A                           104              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
0000108A  B23C 0006                105              CMP.B       #6, D1
0000108E  6E00 0932                106              BGT         manyCharError  
00001092                           107              
00001092                           108              ;See if our counter variable is 0
00001092  B23C 0000                109              CMP.B       #0,D1
00001096                           110              
00001096                           111              ;This means that we have gone through all the characters
00001096  6700 0046                112              BEQ         moreChecks
0000109A                           113              
0000109A                           114              ;Decrement the counter, this means we're about to go through another char
0000109A  5301                     115              SUB.B       #1,D1
0000109C                           116  
0000109C                           117              ;Let's move the byte stored at A1
0000109C  1612                     118              MOVE.B      (A2),D3
0000109E                           119              
0000109E                           120              ;If the byte is greater than or equal to hex $40, then it's a letter
0000109E  B63C 0041                121              CMP.B       #$41,D3
000010A2  6C00 000A                122              BGE         letter
000010A6                           123              
000010A6                           124              ;If the byte is less than or equal to hex $39, then it's a number
000010A6  B63C 0040                125              CMP.B       #$40,D3
000010AA  6F00 0016                126              BLE         number
000010AE                           127              
000010AE                           128  letter:
000010AE                           129              ;We do this check to see if the character is greater than or equal 'G'
000010AE  B63C 0047                130              CMP.B       #$47,D3
000010B2                           131              ;If so, then display an error and ask the user to enter startingAdd again
000010B2  6C00 08EE                132              BGE         charError
000010B6                           133              
000010B6                           134              ;Subtract the Ascii value to convert to hex
000010B6  0403 0037                135              SUB.B       #$37,D3
000010BA                           136              ;Move the value back to our register
000010BA  14C3                     137              MOVE.B      D3,(A2)+
000010BC                           138              
000010BC                           139              ;Shift D5 left to make room for next hex value
000010BC  E986                     140              ASL.L       #4, D6
000010BE                           141              ;Move value to D5
000010BE  DC03                     142              ADD.B      D3, D6
000010C0                           143              
000010C0  60C8                     144              BRA         convert
000010C2                           145             
000010C2                           146  
000010C2                           147  number:          
000010C2                           148             ;We do this check to see if the character is less than or equal to '/'  
000010C2  B63C 002F                149             CMP.B        #$2F,D3
000010C6                           150             ;If so, then display an error and ask the user to enter startingAdd again
000010C6  6F00 08DA                151             BLE          charError     
000010CA                           152   
000010CA                           153             ;Check to see if the character is greater than or equal to ':'
000010CA  B63C 003A                154             CMP.B        #$3A,D3
000010CE                           155             ;If so, then display an error and ask the user to enter startingAdd again
000010CE  6C00 08D2                156             BGE          charError
000010D2                           157            
000010D2                           158             ;Subtract the Ascii value to convert to hex
000010D2  0403 0030                159             SUB.B        #$30,D3
000010D6                           160             ;Move the value back to our register
000010D6  14C3                     161             MOVE.B       D3,(A2)+
000010D8                           162   
000010D8                           163             ;Shift D5 left to make room for next hex value
000010D8  E986                     164             ASL.L        #4, D6
000010DA                           165             ;Move value to D5
000010DA  DC03                     166             ADD.B        D3, D6
000010DC                           167              
000010DC  60AC                     168             BRA          convert
000010DE                           169   
000010DE                           170            
000010DE                           171  moreChecks:
000010DE                           172              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010DE  BE3C 0001                173              CMP.B      #1,D7
000010E2  6700 0028                174              BEQ        moreChecks2
000010E6                           175              
000010E6  6000 0002                176              BRA        moreChecks1
000010EA                           177   
000010EA                           178  moreChecks1:
000010EA                           179              
000010EA                           180              ;Copy the hex value into a temp register
000010EA  2806                     181              MOVE.L      D6,D4
000010EC                           182              
000010EC                           183              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010EC  1A3C 001F                184              MOVE.B      #31,D5
000010F0                           185              
000010F0                           186              ;Shifts 31 bits, isolates last bit. 
000010F0  EBAC                     187              LSL.L       D5,D4
000010F2                           188  
000010F2                           189              ;Shifts it back 31 bit, isolating the last bit. 
000010F2  EAAC                     190              LSR.L       D5,D4
000010F4                           191  
000010F4                           192              ;If the last bit is 1, address was odd, and throw an error. 
000010F4  B83C 0001                193              CMP.B       #1,D4
000010F8  6700 08B8                194              BEQ         oddError   
000010FC                           195                          
000010FC                           196              ;Reset address registers.
000010FC  247C 00000000            197              MOVE.L      #0,A2
00001102                           198              
00001102                           199              ;Copy the value to our staHex variable
00001102  21C6 1000                200              MOVE.L      D6,staHex 
00001106                           201              
00001106  4286                     202              CLR.L       D6
00001108  6000 FF58                203              BRA         endingPrompt     
0000110C                           204              
0000110C                           205  moreChecks2:       
0000110C                           206              
0000110C                           207              ;Copy the hex value into a temp register
0000110C  2806                     208              MOVE.L      D6,D4
0000110E                           209              
0000110E                           210              ;Placeholder to shift bits, used for seeing if the address is odd. 
0000110E  1A3C 001F                211              MOVE.B      #31,D5
00001112                           212              
00001112                           213              ;Shifts 31 bits, isolates last bit. 
00001112  EBAC                     214              LSL.L       D5,D4
00001114                           215  
00001114                           216              ;Shifts it back 31 bit, isolating the last bit. 
00001114  EAAC                     217              LSR.L       D5,D4
00001116                           218  
00001116                           219              ;If the last bit is 1, address was odd, and throw an error. 
00001116  B83C 0001                220              CMP.B       #1,D4
0000111A  6700 0896                221              BEQ         oddError   
0000111E                           222                          
0000111E                           223              ;Reset address registers.
0000111E  247C 00000000            224              MOVE.L      #0,A2
00001124                           225              
00001124                           226              ;Place the value in our ending hex variable
00001124  21C6 1004                227              MOVE.L      D6,endHex 
00001128                           228              
00001128                           229              ;Make D7 a temp location to compare our starting hex
00001128  2E38 1000                230              MOVE.L      staHex,D7
0000112C                           231           
0000112C                           232              
0000112C                           233              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
0000112C  BC87                     234              CMP.L       D7,D6
0000112E  6B00 08A2                235              BMI         endGreater
00001132                           236              
00001132                           237              ;done, start reading memory. 
00001132                           238              
00001132                           239              ;Clear all the registers since we have the addresses stored in our variables
00001132  4283                     240              CLR.L       D3
00001134  4285                     241              CLR.L       D5
00001136  4286                     242              CLR.L       D6
00001138  4287                     243              CLR.L       D7  
0000113A                           244              
0000113A                           245              ;Copy the value of our starting hex to A2 (temp register)
0000113A  2478 1000                246              MOVEA.L     staHex,A2
0000113E                           247                          
0000113E                           248              
0000113E                           249  LOOP:   
0000113E                           250              ;--------------------------------------------------------
0000113E                           251              ;Check for NOP or RTS
0000113E                           252              ;--------------------------------------------------------
0000113E                           253              
0000113E                           254              ;Move the NOP binary value for comparing
0000113E  243C 00004E71            255              MOVE.L      #%0100111001110001,D2
00001144                           256              
00001144                           257              ;Check and see i the instruction is NOP
00001144  B452                     258              CMP.W       (A2),D2
00001146  6700 083A                259              BEQ         printMNOP
0000114A                           260              
0000114A                           261              ;Move the RTS binary value for comparing
0000114A  243C 00004E75            262              MOVE.L      #%0100111001110101,D2
00001150                           263              
00001150                           264              ;Check and see if the instruction is RTS
00001150  B452                     265              CMP.W       (A2),D2
00001152  6700 083E                266              BEQ         printMRTS
00001156                           267              
00001156                           268              ;Clear the contents for reusing
00001156  4282                     269              CLR.L       D2
00001158                           270              
00001158                           271              ;--------------------------------------------------------
00001158                           272              ;Check for ADDI or SUBI, check for four 0's since it's the only
00001158                           273              ;opcode with this pattern
00001158                           274              ;--------------------------------------------------------  
00001158                           275              ;Move the value in A2 to a temp register
00001158  3412                     276              MOVE.W      (A2),D2
0000115A                           277              
0000115A                           278              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
0000115A  163C 000C                279              MOVE.B      #12,D3
0000115E  183C 0004                280              MOVE.B      #4,D4
00001162                           281              
00001162                           282              ;Jumps to getBits and returns with isolated bits in D2
00001162  6100 0070                283              BSR         getBits
00001166                           284              
00001166  B43C 0000                285              CMP.B       #%0000,D2
0000116A  6700 007E                286              BEQ         M0000
0000116E                           287              
0000116E                           288              ;--------------------------------------------------------
0000116E                           289              ;Check for MOVE, since it's the only word starting with 00
0000116E                           290              ;--------------------------------------------------------            
0000116E                           291              ;Move the value in A2 to a temp register
0000116E  1412                     292              MOVE.B      (A2),D2
00001170                           293              
00001170                           294              ;Shift 6 bits to the right to isolate the left-most digits
00001170  EC8A                     295              LSR.L       #6,D2
00001172                           296              
00001172                           297              ;If the first two bits (left-most) are 00, then the instruction is MOVE
00001172  B43C 0000                298              CMP.B       #00,D2
00001176  6F00 013E                299              BLE         M00
0000117A                           300              
0000117A                           301              ;Reuse the register
0000117A  4282                     302              CLR.L       D2
0000117C                           303              
0000117C                           304              
0000117C                           305              ;--------------------------------------------------------
0000117C                           306              ;Check for other OpCodes
0000117C                           307              ;--------------------------------------------------------
0000117C                           308              ;Move the word into a temp register 
0000117C  3412                     309              MOVE.W      (A2),D2
0000117E                           310              
0000117E                           311              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
0000117E  163C 000C                312              MOVE.B        #12,D3            ;Start bit index = 12
00001182  183C 0004                313              MOVE.B        #4,D4             ;Number of bits needed = 4
00001186                           314              
00001186                           315              ;Jumps to getBits and returns with isolated bits in D2
00001186  6100 004C                316              BSR           getBits            
0000118A                           317  
0000118A                           318              
0000118A                           319              ;MOVEM,LEA,NOT,JSR
0000118A  B43C 0004                320              CMP.B       #%0100,D2
0000118E  6700 01A2                321              BEQ         M0100
00001192                           322              
00001192                           323              ;BRA,BLT,BGE,BEQ
00001192  B43C 0006                324              CMP.B       #%0110,D2
00001196  6700 02FC                325              BEQ         M0110
0000119A                           326              
0000119A                           327              ;DIVU
0000119A  B43C 0008                328              CMP.B       #%1000,D2
0000119E  6700 02F4                329              BEQ         M1000
000011A2                           330              
000011A2                           331              ;SUB
000011A2  B43C 0009                332              CMP.B       #%1001,D2
000011A6  6700 0318                333              BEQ         M1001
000011AA                           334              
000011AA                           335              ;MULS,AND
000011AA  B43C 000C                336              CMP.B       #%1100,D2
000011AE  6700 0350                337              BEQ         M1100
000011B2                           338              
000011B2                           339              ;LSL,LSR,ASL,ASR
000011B2  B43C 000E                340              CMP.B       #%1110,D2
000011B6  6700 03BC                341              BEQ         M1110
000011BA                           342              
000011BA                           343              ;ADD
000011BA  B43C 000D                344              CMP.B       #%1101,D2
000011BE  6700 0570                345              BEQ         M1101
000011C2                           346              
000011C2  6000 0AA4                347              BRA         ending
000011C6                           348              
000011C6                           349              
000011C6                           350              
000011C6                           351              ;display INVALID OPCODE, and display the raw hex
000011C6                           352              ;do this later
000011C6                           353  
000011C6                           354             
000011C6                           355  update:
000011C6                           356              ;Check and see if we are at the ending hex
000011C6  B5F8 1004                357              CMP.L      endHex,A2
000011CA  6E00 0A9C                358              BGT        ending
000011CE                           359  
000011CE                           360              ;Update address in A2
000011CE  544A                     361              ADDA.W      #2,A2
000011D0                           362              
000011D0                           363              
000011D0  6000 FF6C                364              BRA        LOOP
000011D4                           365              
000011D4                           366              
000011D4                           367  getBits:
000011D4                           368              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
000011D4                           369              ;PARAMETERS:
000011D4                           370              ;D2 = the value the bits are extracted from & saved back in
000011D4                           371              ;D3 = the start bit index (starting from 0)
000011D4                           372              ;D4 = the number of bits we want to extract
000011D4                           373              
000011D4                           374              ;Calculate left shift
000011D4  3A3C 0010                375              MOVE.W      #16,D5
000011D8                           376              
000011D8  D843                     377              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
000011DA  9A44                     378              SUB.W       D4,D5             ; 16 - X = leftShift
000011DC                           379              
000011DC  EB6A                     380              LSL.W       D5,D2
000011DE                           381              
000011DE                           382              
000011DE                           383              ;Calculate right shift
000011DE  DA43                     384              ADD.W       D3,D5             ; start bit + leftShift = X
000011E0  EA6A                     385              LSR.W       D5,D2
000011E2                           386              
000011E2  4283                     387              CLR.L       D3
000011E4  4284                     388              CLR.L       D4
000011E6  4285                     389              CLR.L       D5   
000011E8  4E75                     390              RTS
000011EA                           391  
000011EA                           392  *-----------------------------------------------------------
000011EA                           393  * 
000011EA                           394  *
000011EA                           395  *
000011EA                           396  * OpCode Implementation
000011EA                           397  *
000011EA                           398  *
000011EA                           399  *
000011EA                           400  *-----------------------------------------------------------
000011EA                           401  
000011EA                           402  
000011EA                           403  *-----------------------------------------------------------
000011EA                           404  * ADDI/SUBI INSTRUCTION
000011EA                           405  *-----------------------------------------------------------
000011EA                           406  M0000:
000011EA  4282                     407              CLR.L       D2
000011EC  4283                     408              CLR.L       D3
000011EE                           409              
000011EE                           410              ;Copy the address values into a register to check for ADDI or SUBI
000011EE  3412                     411              MOVE.W      (A2),D2
000011F0                           412              
000011F0                           413              ;Passing in paramters for isolating bits
000011F0  163C 0008                414              MOVE.B      #8,D3
000011F4  183C 0004                415              MOVE.B      #4,D4
000011F8                           416              
000011F8                           417              ;Jumps to getBits and returns with isolated bits in D2
000011F8  61DA                     418              BSR         getBits
000011FA                           419              
000011FA                           420              ;--------------------------------------------------------
000011FA                           421              ;Check for ADDI
000011FA                           422              ;--------------------------------------------------------
000011FA  B43C 0006                423              CMP.B       #%0110,D2
000011FE  6700 000A                424              BEQ         MADDI
00001202                           425             
00001202                           426              ;--------------------------------------------------------
00001202                           427              ;Check for SUBI
00001202                           428              ;--------------------------------------------------------
00001202  B43C 0004                429              CMP.B       #%0100,D2
00001206  6700 0032                430              BEQ         MSUBI
0000120A                           431  
0000120A                           432  MADDI:
0000120A  43F9 00001AA3            433              LEA         printADDI,A1
00001210  103C 000E                434              MOVE.B      #14,D0
00001214  4E4F                     435              TRAP        #15
00001216                           436              
00001216  4282                     437              CLR.L       D2
00001218  4283                     438              CLR.L       D3
0000121A                           439              
0000121A                           440              ;======Isolate Size (S) Bits======
0000121A                           441              ;Copy the address values into a register
0000121A  3412                     442              MOVE.W      (A2),D2
0000121C                           443              
0000121C                           444              ;Passing in parameters for isolating size bits
0000121C  163C 0006                445              MOVE.B      #6,D3
00001220  183C 0002                446              MOVE.B      #2,D4
00001224                           447              
00001224                           448              ;Jumps to getBits and returns with isolated bits in D2
00001224  61AE                     449              BSR         getBits
00001226                           450              
00001226                           451              ;Jumps to printSizeSubroutine and returns after size has been printed
00001226  6100 05CE                452              BSR         printSizeSubroutine
0000122A                           453              
0000122A                           454              ;Let's store the size indicator since it will help us determine how many times
0000122A                           455              ;we have to iterate through addresses to print out the whole instruction
0000122A                           456              ;We will use A4 as the register to temporary store the size
0000122A  3842                     457              MOVE.W      D2,A4
0000122C                           458              
0000122C                           459              ;Clear the register so we can reuse it
0000122C  4282                     460              CLR.L       D2
0000122E                           461              
0000122E  1412                     462              MOVE.B      (A2),D2
00001230                           463              
00001230                           464              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001230                           465              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001230  264A                     466              MOVE.L      A2,A3
00001232                           467              
00001232  6100 003A                468              BSR         mEffect
00001236                           469              
00001236  4283                     470              CLR.L       D3
00001238                           471              
00001238  608C                     472              BRA         update
0000123A                           473              
0000123A                           474              
0000123A                           475  MSUBI:
0000123A  43F9 00001AB0            476              LEA         printSUBI,A1
00001240  103C 000E                477              MOVE.B      #14,D0
00001244  4E4F                     478              TRAP        #15
00001246                           479              
00001246  4282                     480              CLR.L       D2
00001248  4283                     481              CLR.L       D3
0000124A                           482              
0000124A                           483              ;======Isolate Size (S) Bits======
0000124A                           484              ;Copy the address values into a register
0000124A  3412                     485              MOVE.W      (A2),D2
0000124C                           486              
0000124C                           487              ;Passing in parameters for isolating size bits
0000124C  163C 0006                488              MOVE.B      #6,D3
00001250  183C 0002                489              MOVE.B      #2,D4
00001254                           490              
00001254                           491              ;Jumps to getBits and returns with isolated bits in D2
00001254  6100 FF7E                492              BSR         getBits
00001258                           493              
00001258                           494              ;Jumps to printSizeSubroutine and returns after size has been printed
00001258  6100 059C                495              BSR         printSizeSubroutine
0000125C                           496              
0000125C                           497              ;Let's store the size indicator since it will help us determine how many times
0000125C                           498              ;we have to iterate through addresses to print out the whole instruction
0000125C                           499              ;We will use A4 as the register to temporary store the size
0000125C  3842                     500              MOVE.W      D2,A4
0000125E                           501              
0000125E                           502              ;Clear the register so we can reuse it
0000125E  4282                     503              CLR.L       D2
00001260                           504              
00001260  1412                     505              MOVE.B      (A2),D2
00001262                           506              
00001262                           507              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001262                           508              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001262  264A                     509              MOVE.L      A2,A3
00001264                           510              
00001264  6100 0008                511              BSR         mEffect
00001268                           512              
00001268  4283                     513              CLR.L       D3
0000126A                           514              
0000126A  6000 FF5A                515              BRA         update
0000126E                           516  
0000126E                           517              
0000126E                           518  mEffect:
0000126E                           519              ;Male D6 #%111 since the source will always be an immediate value 
0000126E  1C3C 0007                520              MOVE.B      #7,D6
00001272                           521              ;Make D7 #%100 since the source will always be an immediate value
00001272  1E3C 0004                522              MOVE.B      #4,D7     
00001276                           523  
00001276                           524              ;Print source address
00001276  6100 05F0                525              BSR         addressModeSR
0000127A                           526              
0000127A                           527              ;Print the comma after the source address
0000127A  43F9 00001B55            528              LEA        printComma,A1
00001280  103C 000E                529              MOVE.B     #14,D0
00001284  4E4F                     530              TRAP       #15
00001286                           531              
00001286                           532              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001286  6100 0008                533              BSR        isoAddBit0to5
0000128A                           534              
0000128A                           535              ;Print source address
0000128A  6100 05DC                536              BSR        addressModeSR
0000128E                           537              
0000128E  4E75                     538              RTS            
00001290                           539              
00001290                           540              
00001290                           541  isoAddBit0to5:
00001290                           542              ;===Isolate the Destination Mode (M)Bits===
00001290  4282                     543              CLR.L      D2
00001292                           544              
00001292                           545              ;Copy the address value into a register
00001292  3413                     546              MOVE.W     (A3),D2
00001294                           547              
00001294                           548              ;Passing in parameters for isolating Mode bits
00001294  163C 0003                549              MOVE.B     #3,D3
00001298  183C 0003                550              MOVE.B     #3,D4
0000129C                           551              
0000129C                           552              ;Jumps to getBits and returns with isolated bits in D2
0000129C  4EB8 11D4                553              JSR        getBits
000012A0                           554              
000012A0                           555              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000012A0  1C02                     556              MOVE.B     D2,D6
000012A2                           557              
000012A2                           558              ;===Isolate the Destination Address Register (Xn)Bits===
000012A2  4282                     559              CLR.L      D2
000012A4                           560              
000012A4                           561              ;Copy the address values into a register
000012A4  3413                     562              MOVE.W     (A3),D2
000012A6                           563              
000012A6                           564              ;Passing in parameters for isolating Xn bits
000012A6  163C 0000                565              MOVE.B     #0,D3
000012AA  183C 0003                566              MOVE.B     #3,D4
000012AE                           567              
000012AE                           568              ;Jumps to getBits and returns with isolated bits in D2
000012AE  4EB8 11D4                569              JSR        getBits
000012B2                           570              
000012B2                           571              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000012B2  1E02                     572              MOVE.B      D2,D7
000012B4                           573  
000012B4  4E75                     574              RTS
000012B6                           575              
000012B6                           576  *-----------------------------------------------------------
000012B6                           577  * MOVE INSTRUCTION
000012B6                           578  *-----------------------------------------------------------
000012B6                           579  M00:
000012B6  43F9 00001A8E            580              LEA        printMOVE,A1
000012BC  103C 000E                581              MOVE.B     #14,D0
000012C0  4E4F                     582              TRAP       #15
000012C2                           583              
000012C2  4202                     584              CLR.B      D2
000012C4  4203                     585              CLR.B      D3
000012C6                           586              
000012C6                           587              ;======Isolate Size (S) Bits=======
000012C6                           588              ;Copy the address values into a register
000012C6  3412                     589              MOVE.W     (A2),D2
000012C8                           590              
000012C8                           591              ;Passing in parameters for isolating size bits 12,13
000012C8  163C 000C                592              MOVE.B      #12,D3             
000012CC  183C 0002                593              MOVE.B      #2,D4             
000012D0                           594              
000012D0                           595              ;Jumps to getBits and returns with isolated bits in D2
000012D0  6100 FF02                596              BSR         getBits  
000012D4                           597              
000012D4                           598              ;Indicate to our print function we are doing this for the MOVE opcode
000012D4  163C 0001                599              MOVE.B      #1,D3
000012D8                           600              
000012D8                           601              ;Jumps to printSizeSubroutine and returns after size has been printed
000012D8  6100 051C                602              BSR         printSizeSubroutine
000012DC                           603              
000012DC                           604              ;Let's store the size indicator since it will help us determine how many times
000012DC                           605              ;we have to iterate through addresses to print out the whole instruction
000012DC                           606              ;We will use A4 as the register to temporary store the size
000012DC  3842                     607              MOVE.W      D2,A4
000012DE                           608              
000012DE                           609              ;Clear the register so we can reuse it
000012DE  4282                     610              CLR.L       D2
000012E0                           611              
000012E0  1412                     612              MOVE.B      (A2),D2
000012E2                           613              
000012E2                           614              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
000012E2                           615              ;This is meant so we can use the copy to figure out the destination addressing mode
000012E2  264A                     616              MOVE.L      A2,A3
000012E4                           617  
000012E4  6100 0008                618              BSR         mSourceDest
000012E8                           619              
000012E8  4283                     620              CLR.L       D3
000012EA                           621              
000012EA  6000 FEDA                622              BRA         update
000012EE                           623            
000012EE                           624  ;======Helper function to find the destination for MOVE======
000012EE                           625  mSourceDest:
000012EE                           626              ;SOURCE
000012EE                           627              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
000012EE  6100 04C8                628              BSR        isolateAddressBit0to5
000012F2                           629              
000012F2                           630              ;Print source address
000012F2  6100 0574                631              BSR        addressModeSR
000012F6                           632              
000012F6                           633              ;Print the comma after the source address
000012F6  43F9 00001B55            634              LEA        printComma,A1
000012FC  103C 000E                635              MOVE.B     #14,D0
00001300  4E4F                     636              TRAP       #15
00001302                           637              
00001302                           638              ;DESTINATION
00001302                           639              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001302  6100 0008                640              BSR        isolateAddressBit6to11
00001306                           641              
00001306                           642              ;Print destination address
00001306  6100 0560                643              BSR        addressModeSR
0000130A                           644              
0000130A  4E75                     645              RTS
0000130C                           646  
0000130C                           647  isolateAddressBit6to11:
0000130C                           648              ;===Isolate the Destination Mode (M)Bits===
0000130C  4282                     649              CLR.L      D2
0000130E                           650              
0000130E                           651              ;Copy the address value into a register
0000130E  3413                     652              MOVE.W     (A3),D2
00001310                           653              
00001310                           654              ;Passing in parameters for isolating Mode bits
00001310  163C 0006                655              MOVE.B     #6,D3
00001314  183C 0003                656              MOVE.B     #3,D4
00001318                           657              
00001318                           658              ;Jumps to getBits and returns with isolated bits in D2
00001318  4EB8 11D4                659              JSR        getBits
0000131C                           660              
0000131C                           661              ;Save M bit into ***D6*** for later use in addressModeSubroutine
0000131C  1C02                     662              MOVE.B     D2,D6
0000131E                           663              
0000131E                           664              ;===Isolate the Destination Address Register (Xn)Bits===
0000131E  4282                     665              CLR.L      D2
00001320                           666              
00001320                           667              ;Copy the address values into a register
00001320  3413                     668              MOVE.W     (A3),D2
00001322                           669              
00001322                           670              ;Passing in parameters for isolating Xn bits
00001322  163C 0009                671              MOVE.B     #9,D3
00001326  183C 0003                672              MOVE.B     #3,D4
0000132A                           673              
0000132A                           674              ;Jumps to getBits and returns with isolated bits in D2
0000132A  4EB8 11D4                675              JSR        getBits
0000132E                           676              
0000132E                           677              ;Save Xn register bit into ***D7*** for later use in addressModeSR
0000132E  1E02                     678              MOVE.B      D2,D7
00001330                           679  
00001330  4E75                     680              RTS
00001332                           681              
00001332                           682              
00001332                           683  *-----------------------------------------------------------
00001332                           684  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
00001332                           685  *-----------------------------------------------------------
00001332                           686  M0100:      
00001332  4282                     687              CLR.L       D2
00001334  4283                     688              CLR.L       D3
00001336                           689              
00001336                           690              ;--------------------------------------------------------
00001336                           691              ;Check for LEA
00001336                           692              ;--------------------------------------------------------
00001336                           693              ;Copy the address values into a register to check for LEA
00001336  3412                     694              MOVE.W     (A2),D2
00001338                           695              
00001338                           696              ;Passing in parameters for isolating bits 6,7,8
00001338  163C 0006                697              MOVE.B      #6,D3             ;Start bit index = 6
0000133C  183C 0003                698              MOVE.B      #3,D4             ;Number of bits needed = 3
00001340                           699              
00001340                           700              ;Jumps to getBits and returns with isolated bits in D2
00001340  6100 FE92                701              BSR         getBits
00001344                           702  
00001344  B43C 0007                703              CMP.B       #%111,D2
00001348  6700 00D6                704              BEQ         MLEA
0000134C                           705  
0000134C                           706              ;--------------------------------------------------------
0000134C                           707              ;Check for NOT
0000134C                           708              ;--------------------------------------------------------
0000134C                           709              ;Clear D2 and recopy it to check for NOT
0000134C  4282                     710              CLR.L       D2
0000134E  3412                     711              MOVE.W      (A2),D2
00001350                           712              
00001350                           713              ;Pass in parameters for isolating bits 8,9,10,11
00001350  163C 0008                714              MOVE.B      #8,D3
00001354  183C 0004                715              MOVE.B      #4,D4
00001358                           716              
00001358                           717              ;Jumps to getBits and returns with isolated bits in D2
00001358  6100 FE7A                718              BSR         getBits
0000135C                           719              
0000135C  B43C 0006                720              CMP.B       #%0110,D2
00001360  6700 00EE                721              BEQ         MNOT      
00001364                           722              
00001364                           723              ;--------------------------------------------------------
00001364                           724              ;Check for JSR
00001364                           725              ;--------------------------------------------------------
00001364                           726              ;Clear D2 and recopy it to check for JSR
00001364  4282                     727              CLR.L       D2
00001366  3412                     728              MOVE.W     (A2),D2
00001368                           729              
00001368                           730              ;Pass in parameters for isolating bits 6-11
00001368  163C 0006                731              MOVE.B      #6,D3
0000136C  183C 0006                732              MOVE.B      #6,D4
00001370                           733              
00001370                           734              ;Jumps to getBits and returns with isolated bits in D2
00001370  6100 FE62                735              BSR         getBits
00001374                           736              
00001374  B43C 003A                737              CMP.B       #%111010,D2
00001378  6700 0102                738              BEQ         MJSR
0000137C                           739              
0000137C                           740              ;--------------------------------------------------------
0000137C                           741              ;Check for MOVEM
0000137C                           742              ;--------------------------------------------------------
0000137C                           743              ;Clear D2 and recopy it to check for MOVEM
0000137C  4282                     744              CLR.L       D2
0000137E  3412                     745              MOVE.W     (A2),D2
00001380                           746              
00001380                           747              ;Pass in parameters for isolating bit 9
00001380  163C 0009                748              MOVE.B      #9,D3
00001384  183C 0001                749              MOVE.B      #1,D4
00001388                           750              
00001388                           751              ;Jumps to getBits and returns with isolated bits in D2
00001388  6100 FE4A                752              BSR         getBits
0000138C                           753              
0000138C  B43C 0000                754              CMP.B       #%0,D2
00001390  6700 0002                755              BEQ         MOVEM
00001394                           756              
00001394                           757         
00001394                           758  MOVEM:
00001394                           759              *******************
00001394                           760              *Must finish!!!!!!
00001394                           761              *******************
00001394  43F9 00001A95            762              LEA         printMOVEM,A1
0000139A  1038 0014                763              MOVE.B      $14,D0
0000139E  4E4F                     764              TRAP        #15
000013A0                           765  
000013A0                           766              ***Isolate Size Bit
000013A0                           767              ;Clear D2 and recopy it to check for D bit
000013A0  4282                     768              CLR.L       D2
000013A2  3412                     769              MOVE.W     (A2),D2
000013A4                           770              
000013A4                           771              ;Pass in parameters for isolating bit 6
000013A4  163C 0006                772              MOVE.B      #6,D3
000013A8  183C 0001                773              MOVE.B      #1,D4
000013AC                           774              
000013AC                           775              ;Jumps to getBits and returns with isolated bits in D2
000013AC  6100 FE26                776              BSR         getBits
000013B0                           777              
000013B0                           778              ;Print size
000013B0  4EB9 0000182E            779              JSR         printMOVEMSize
000013B6                           780              
000013B6                           781              ***Isolate Direction bit
000013B6                           782              ;Clear D2 and recopy it to check for D bit
000013B6  4282                     783              CLR.L       D2
000013B8  3412                     784              MOVE.W     (A2),D2
000013BA                           785              
000013BA                           786              ;Pass in parameters for isolating bit 10
000013BA  163C 000A                787              MOVE.B      #10,D3
000013BE  183C 0001                788              MOVE.B      #1,D4
000013C2                           789              
000013C2                           790              ;Jumps to getBits and returns with isolated bits in D2
000013C2  6100 FE10                791              BSR         getBits
000013C6                           792              
000013C6                           793              ***Determine the direction of the instruction
000013C6                           794              ;Register list to Memory
000013C6  B43C 0000                795              CMP.B       #0,D2
000013CA  6700 000A                796              BEQ         ListToMem
000013CE                           797              
000013CE                           798              ;Memory to Register list
000013CE  B43C 0001                799              CMP.B       #1,D2
000013D2  6700 0012                800              BEQ         MemToList
000013D6                           801  
000013D6                           802  ListToMem:
000013D6                           803              ***SOURCE(Register list)
000013D6                           804              
000013D6                           805              ;..TO DO
000013D6                           806  
000013D6                           807              ***DESTINATION(Memory)
000013D6                           808              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
000013D6  4282                     809              CLR.L       D2
000013D8  3412                     810              MOVE.W     (A2),D2
000013DA                           811              
000013DA                           812              ;Isolate bits 0 to 5
000013DA  4EB9 000017B8            813              JSR         isolateAddressBit0to5
000013E0                           814              
000013E0                           815              ;Print memory address
000013E0  4EB9 00001868            816              JSR         addressModeSR
000013E6                           817  
000013E6                           818  MemToList:
000013E6                           819              ***SOURCE(Memory)
000013E6                           820              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
000013E6  4282                     821              CLR.L       D2
000013E8  3412                     822              MOVE.W     (A2),D2
000013EA                           823              
000013EA                           824              ;Isolate addressing bits 0 to 5
000013EA  4EB9 000017B8            825              JSR         isolateAddressBit0to5
000013F0                           826              
000013F0                           827              ;If addressing mode (M) = 111
000013F0  BC3C 0007                828              CMP.B       #%111,D6
000013F4  6700 000C                829              BEQ         absoluteAddressMOVEM
000013F8                           830              
000013F8                           831              ;Print memory address if non absolute address
000013F8  4EB9 00001868            832              JSR         addressModeSR
000013FE                           833              
000013FE  6000 0018                834              BRA         MemToListDestination            ;branch to destination portion
00001402                           835  
00001402                           836  absoluteAddressMOVEM:
00001402                           837  
00001402  584A                     838              ADDA.W      #4,A2         
00001404                           839  
00001404                           840              ;See if we have to print out a long 
00001404  BE3C 0000                841              CMP.B       #%000,D7
00001408  4EB9 00001942            842              JSR         wordAddress
0000140E                           843              
0000140E  BE3C 0001                844              CMP.B       #%001,D7
00001412  4EB9 0000194A            845              JSR         updateLong 
00001418                           846  
00001418                           847  MemToListDestination:
00001418                           848  
00001418                           849              ***DESTINATION(Register list)
00001418                           850              ;Move to the next word which contains the Register list bits
00001418  544A                     851              ADDA.W      #2,A2
0000141A                           852              
0000141A                           853              *branch to registerList subroutine
0000141A  4EB9 00001420            854              JSR         regListSR
00001420                           855              
00001420                           856  regListSR:
00001420                           857  
00001420                           858  
00001420                           859  MLEA:
00001420  43F9 00001ACB            860              LEA         printLEA,A1
00001426  103C 000E                861              MOVE.B      #14,D0
0000142A  4E4F                     862              TRAP        #15
0000142C                           863              
0000142C                           864              ;*SOURCE*
0000142C                           865              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000142C                           866              ;D6 will contain mode & D7 will contain the register after this instruction
0000142C  6100 038A                867              BSR         isolateAddressBit0to5
00001430                           868              
00001430                           869              ;*Print source address*
00001430  6100 0436                870              BSR         addressModeSR
00001434                           871              
00001434                           872              ;Print comma after source address
00001434  43F9 00001B55            873              LEA         printComma,A1
0000143A  103C 000E                874              MOVE.B      #14,D0
0000143E  4E4F                     875              TRAP        #15
00001440                           876              
00001440                           877              ;*DESTINATION*
00001440                           878              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001440                           879              ;D7 will contain the register after this instruction
00001440  6100 039C                880              BSR         isolateRegisterBit9to11
00001444                           881              
00001444                           882              ;Save #%001 into D6 to specify address register mode
00001444  1C3C 0001                883              MOVE.B      #1,D6
00001448                           884              
00001448                           885              
00001448                           886              ;*Print destination address*
00001448  6100 041E                887              BSR         addressModeSR
0000144C                           888  
0000144C  6000 FD78                889              BRA        update
00001450                           890  
00001450                           891  MNOT:
00001450  43F9 00001AD8            892              LEA        printNOT,A1
00001456  103C 000E                893              MOVE.B     #14,D0
0000145A  4E4F                     894              TRAP       #15
0000145C                           895              
0000145C  4282                     896              CLR.L      D2
0000145E                           897              ;Move the address into the register to check for size
0000145E  3412                     898              MOVE.W     (A2),D2
00001460                           899              
00001460                           900              ;Pass in parameters for isolating bits 6,7
00001460  163C 0006                901              MOVE.B     #6,D3
00001464  183C 0002                902              MOVE.B     #2,D4
00001468                           903              
00001468                           904              ;Jump to getbits and return with isolated bits
00001468  6100 FD6A                905              BSR        getbits          
0000146C                           906              
0000146C                           907              ;Jumps to printSizeSubroutine and returns after size has been printed
0000146C  6100 0388                908              BSR        printSizeSubroutine
00001470                           909              
00001470                           910              ;*SOURCE*
00001470                           911              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001470                           912              ;D6 will contain mode & D7 will contain the register after this instruction
00001470  6100 0346                913              BSR        isolateAddressBit0to5
00001474                           914              
00001474                           915              ;*Print source address*
00001474  6100 03F2                916              BSR        addressModeSR
00001478                           917              
00001478  6000 FD4C                918              BRA        update 
0000147C                           919  
0000147C                           920  MJSR:
0000147C  43F9 00001B08            921              LEA        printJSR,A1
00001482  103C 000E                922              MOVE.B     #14,D0
00001486  4E4F                     923              TRAP       #15
00001488                           924              
00001488                           925              ;*SOURCE*
00001488                           926              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001488                           927              ;D6 will contain mode & D7 will contain the register after this instruction
00001488  6100 032E                928              BSR        isolateAddressBit0to5
0000148C                           929              
0000148C                           930              ;*Print source address*
0000148C  6100 03DA                931              BSR        addressModeSR
00001490                           932              
00001490  6000 FD34                933              BRA        update 
00001494                           934              
00001494                           935  
00001494                           936  *-----------------------------------------------------------
00001494                           937  * BRA,BLT,BGE,BEQ INSTRUCTIONS
00001494                           938  *-----------------------------------------------------------       
00001494                           939  M0110:
00001494                           940              ;
00001494                           941  MBRA:
00001494                           942  MBLT:
00001494                           943  MBGE:
00001494                           944  MBEQ:            
00001494                           945              
00001494                           946  
00001494                           947  *-----------------------------------------------------------
00001494                           948  * DIVU INSTRUCTION
00001494                           949  *-----------------------------------------------------------           
00001494                           950  M1000:
00001494                           951              
00001494  4282                     952              CLR.L       D2
00001496  4283                     953              CLR.L       D3
00001498                           954              
00001498                           955              ;Copy the address values into a register
00001498  3412                     956              MOVE.W     (A2),D2
0000149A                           957              
0000149A                           958              ;Passing in parameters for isolating bits 6,7,8
0000149A  163C 0006                959              MOVE.B      #6,D3             ;Start bit index = 6
0000149E  183C 0003                960              MOVE.B      #3,D4             ;Number of bits needed = 3
000014A2                           961              
000014A2                           962              ;Jumps to getBits and returns with isolated bits in D2
000014A2  6100 FD30                963              BSR         getBits
000014A6                           964              
000014A6                           965              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
000014A6  B4BC 00000003            966              CMP.L       #%011,D2
000014AC  6700 0002                967              BEQ         continueDIVU
000014B0                           968              
000014B0                           969              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
000014B0                           970  
000014B0                           971  continueDIVU:
000014B0                           972  
000014B0  43F9 00001AC1            973              LEA         printDIVU,A1
000014B6  103C 000E                974              MOVE.B      #14,D0
000014BA  4E4F                     975              TRAP        #15
000014BC                           976              
000014BC  6000 02B2                977              BRA         dnDest
000014C0                           978              
000014C0                           979              
000014C0                           980  *-----------------------------------------------------------
000014C0                           981  * SUB INSTRUCTION
000014C0                           982  *-----------------------------------------------------------  
000014C0                           983  M1001:
000014C0  43F9 00001AAA            984              LEA        printSUB,A1
000014C6  103C 000E                985              MOVE.B     #14,D0
000014CA  4E4F                     986              TRAP       #15
000014CC                           987              
000014CC  4202                     988              CLR.B      D2
000014CE  4203                     989              CLR.B      D3
000014D0                           990              
000014D0                           991              ;======Isolate Size (S) Bits=======
000014D0                           992              ;Copy the address values into a register
000014D0  3412                     993              MOVE.W     (A2),D2
000014D2                           994              
000014D2                           995              ;Passing in parameters for isolating size bits
000014D2  163C 0006                996              MOVE.B      #6,D3             ;Start bit index = 6
000014D6  183C 0002                997              MOVE.B      #2,D4             ;Number of bits needed = 2
000014DA                           998              
000014DA                           999              ;Jumps to getBits and returns with isolated bits in D2
000014DA  6100 FCF8               1000              BSR         getBits  
000014DE                          1001              
000014DE                          1002              ;Jumps to printSizeSubroutine and returns after size has been printed
000014DE  6100 0316               1003              BSR         printSizeSubroutine
000014E2                          1004              
000014E2                          1005              ;Let's store the size indicator since it will help us determine how many times
000014E2                          1006              ;we have to iterate through addresses to print out the whole instruction
000014E2                          1007              ;We will use A4 as the register to temporary store the size
000014E2  3842                    1008              MOVE.W      D2,A4
000014E4                          1009         
000014E4                          1010              ;======Isolate direction (D) Bit=======
000014E4                          1011              ; 0 = data register is destination | 1 = Dn is source
000014E4  4282                    1012              CLR.L       D2
000014E6                          1013              
000014E6                          1014              ;Copy the address values into a register
000014E6  3412                    1015              MOVE.W      (A2),D2
000014E8                          1016              
000014E8                          1017              ;Passing in parameters for isolating direction bit
000014E8  163C 0008               1018              MOVE.B      #8,D3             ;Start bit index = 8
000014EC  183C 0001               1019              MOVE.B      #1,D4             ;Number of bits needed = 1
000014F0                          1020              
000014F0                          1021              ;Jumps to getBits and returns with isolated bit in D2
000014F0  6100 FCE2               1022              BSR         getBits
000014F4                          1023              
000014F4                          1024              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000014F4  B43C 0000               1025              CMP.B       #0,D2
000014F8  6700 0276               1026              BEQ         dnDest
000014FC  6000 0296               1027              BRA         dnSource
00001500                          1028  
00001500                          1029  
00001500                          1030  *-----------------------------------------------------------
00001500                          1031  * MULS,AND INSTRUCTIONS
00001500                          1032  *-----------------------------------------------------------  
00001500                          1033  M1100:      
00001500  4282                    1034              CLR.L       D2
00001502  4283                    1035              CLR.L       D3
00001504                          1036              
00001504                          1037              ;Copy the address values into a register
00001504  3412                    1038              MOVE.W     (A2),D2
00001506                          1039              
00001506                          1040              ;Passing in parameters for isolating bits 6 and 7
00001506  163C 0006               1041              MOVE.B      #6,D3             ;Start bit index = 6
0000150A  183C 0002               1042              MOVE.B      #2,D4             ;Number of bits needed = 2
0000150E                          1043              
0000150E                          1044              ;Jumps to getBits and returns with isolated bits in D2
0000150E  6100 FCC4               1045              BSR         getBits  
00001512                          1046              
00001512                          1047              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
00001512  B43C 0003               1048              CMP.B       #%11,D2
00001516  6700 0006               1049              BEQ         mulsCheck
0000151A  6000 0028               1050              BRA         MAND
0000151E                          1051              
0000151E                          1052  mulsCheck:
0000151E                          1053              ;Copy the address values into a register
0000151E  3412                    1054              MOVE.W     (A2),D2
00001520                          1055              
00001520                          1056              ;Passing in parameters for isolating bit 8
00001520  163C 0008               1057              MOVE.B      #8,D3             ;Start bit index = 8
00001524  183C 0001               1058              MOVE.B      #1,D4             ;Number of bits needed = 1
00001528                          1059              
00001528                          1060              ;Jumps to getBits and returns with isolated bits in D2
00001528  6100 FCAA               1061              BSR         getBits 
0000152C                          1062              
0000152C                          1063              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
0000152C  B43C 0001               1064              CMP.B       #1,D2
00001530  6700 0002               1065              BEQ         MMULS
00001534                          1066              
00001534                          1067              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001534                          1068  
00001534                          1069              
00001534                          1070              
00001534                          1071              
00001534                          1072  MMULS:
00001534  43F9 00001AB7           1073              LEA         printMULS,A1
0000153A  103C 000E               1074              MOVE.B      #14,D0
0000153E  4E4F                    1075              TRAP        #15
00001540                          1076              
00001540  6000 022E               1077              BRA         dnDest 
00001544                          1078  
00001544                          1079  
00001544                          1080  MAND:
00001544  43F9 00001AD2           1081              LEA        printAND,A1
0000154A  103C 000E               1082              MOVE.B     #14,D0
0000154E  4E4F                    1083              TRAP       #15
00001550                          1084              
00001550                          1085              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
00001550                          1086              ;Jumps to printSizeSubroutine and returns after size has been printed
00001550  6100 02A4               1087              BSR         printSizeSubroutine
00001554                          1088              
00001554                          1089              ;======Isolate direction (D) Bit=======
00001554                          1090              ; 0 = data register is destination | 1 = Dn is source
00001554  4282                    1091              CLR.L       D2
00001556                          1092              
00001556                          1093              ;Copy the address values into a register
00001556  3412                    1094              MOVE.W      (A2),D2
00001558                          1095              
00001558                          1096              ;Passing in parameters for isolating direction bit
00001558  163C 0008               1097              MOVE.B      #8,D3           ;Start bit index = 8
0000155C  183C 0001               1098              MOVE.B      #1,D4           ;Number of bits needed = 1
00001560                          1099  
00001560                          1100              ;Jumps to getBits and returns with isolated bit in D2
00001560  6100 FC72               1101              BSR         getBits
00001564                          1102              
00001564                          1103              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001564  B43C 0000               1104              CMP.B       #0,D2
00001568  6700 0206               1105              BEQ         dnDest
0000156C  6000 0226               1106              BRA         dnSource
00001570                          1107              
00001570                          1108              
00001570  6000 FC54               1109              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001574                          1110     
00001574                          1111     
00001574                          1112  *-----------------------------------------------------------
00001574                          1113  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001574                          1114  *-----------------------------------------------------------  
00001574                          1115  M1110:
00001574  4282                    1116              CLR.L       D2
00001576  4283                    1117              CLR.L       D3
00001578                          1118              
00001578                          1119              ;Copy the address values into a register
00001578  3412                    1120              MOVE.W     (A2),D2
0000157A                          1121              
0000157A                          1122              ;Passing in parameters for isolating bits 6-7
0000157A  163C 0006               1123              MOVE.B      #6,D3             ;Start bit index = 6
0000157E  183C 0002               1124              MOVE.B      #2,D4             ;Number of bits needed = 2
00001582                          1125              
00001582                          1126              ;Jumps to getBits and returns with isolated bits in D2
00001582  6100 FC50               1127              BSR         getBits  
00001586                          1128              
00001586                          1129              ;Check if Memory Shift
00001586  B43C 0003               1130              CMP.B       #%11,D2
0000158A  6700 00B8               1131              BEQ         MemShift
0000158E                          1132              
0000158E                          1133              ;If not Memory Shift, is a Register Shift
0000158E                          1134              
0000158E                          1135              ;Copy the address values into a register
0000158E  3412                    1136              MOVE.W     (A2),D2
00001590                          1137              
00001590                          1138              ;Passing in parameters for isolating bit 3
00001590  163C 0003               1139              MOVE.B      #3,D3             ;Start bit index = 3
00001594  183C 0001               1140              MOVE.B      #1,D4             ;Number of bits needed = 1
00001598                          1141              
00001598                          1142              ;Jumps to getBits and returns with isolated bits in D2
00001598  6100 FC3A               1143              BSR         getBits  
0000159C                          1144              
0000159C                          1145              ;Checks if ASd
0000159C  B43C 0000               1146              CMP.B       #%0,D2
000015A0  6700 00E8               1147              BEQ         RegAS
000015A4                          1148              
000015A4                          1149              ;Checks if LSd
000015A4  B43C 0001               1150              CMP.B       #%1,D2
000015A8  6700 00E8               1151              BEQ         RegLS
000015AC                          1152  RegShift      
000015AC                          1153              ;Copy the address values into a register
000015AC  3412                    1154              MOVE.W     (A2),D2
000015AE                          1155              
000015AE                          1156              ;Passing in parameters for isolating bits 6-7
000015AE  163C 0006               1157              MOVE.B      #6,D3             ;Start bit index = 6
000015B2  183C 0002               1158              MOVE.B      #2,D4             ;Number of bits needed = 2
000015B6                          1159              
000015B6                          1160              ;Jumps to getBits and returns with isolated bits in D2
000015B6  6100 FC1C               1161              BSR         getBits  
000015BA                          1162              
000015BA                          1163              ;Print Size
000015BA  6100 023A               1164              BSR         printSizeSubroutine
000015BE                          1165              
000015BE                          1166              ;Copy the address values into a register
000015BE  3412                    1167              MOVE.W     (A2),D2
000015C0                          1168              
000015C0                          1169              ;Passing in parameters for isolating bit 5
000015C0  163C 0005               1170              MOVE.B      #5,D3             ;Start bit index = 5
000015C4  183C 0001               1171              MOVE.B      #1,D4             ;Number of bits needed = 1
000015C8                          1172              
000015C8                          1173              ;Jumps to getBits and returns with isolated bits in D2
000015C8  6100 FC0A               1174              BSR         getBits  
000015CC                          1175              
000015CC                          1176              ;Checks if shift count is immediate
000015CC  B43C 0000               1177              CMP.B       #%0,D2
000015D0  6700 003C               1178              BEQ         ImmediateCount
000015D4                          1179              
000015D4                          1180              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000015D4                          1181              ;D7 will contain the register after this instruction
000015D4  6100 0208               1182              BSR         isolateRegisterBit9to11
000015D8                          1183              
000015D8                          1184              ;Save #%000 into D6 to specify data register mode
000015D8  1C3C 0000               1185              MOVE.B      #0,D6
000015DC                          1186              
000015DC                          1187              ;*Print Shift Count address*
000015DC  6100 028A               1188              BSR         addressModeSR
000015E0                          1189  
000015E0  6100 0002               1190              BSR         RegShift2
000015E4                          1191  
000015E4                          1192  RegShift2   ;Print comma after shift count
000015E4  43F9 00001B55           1193              LEA         printComma,A1
000015EA  103C 000E               1194              MOVE.B      #14,D0
000015EE  4E4F                    1195              TRAP        #15
000015F0                          1196              
000015F0                          1197              ;*Data Register to be Shifted*
000015F0  4282                    1198              CLR.L       D2
000015F2                          1199              
000015F2                          1200              ;Copy the address values into a register
000015F2  3412                    1201              MOVE.W      (A2),D2
000015F4                          1202              
000015F4                          1203              ;Passing in parameters for isolating bits 0-2
000015F4  163C 0000               1204              MOVE.B      #0,D3             ;Start bit index = 0
000015F8  183C 0003               1205              MOVE.B      #3,D4             ;Number of bits needed = 3
000015FC                          1206              
000015FC                          1207              ;Jumps to getBits and returns with isolated bits in D2
000015FC  6100 FBD6               1208              BSR         getBits
00001600                          1209              
00001600                          1210              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001600  1E02                    1211              MOVE.B      D2,D7
00001602                          1212              
00001602                          1213              ;Save #%000 into D6 to specify data register mode
00001602  1C3C 0000               1214              MOVE.B      #0,D6
00001606                          1215              
00001606                          1216              ;*Prints data register to be shifted*
00001606  6100 0260               1217              BSR         addressModeSR
0000160A                          1218  
0000160A  6000 FBBA               1219              BRA         update
0000160E                          1220              
0000160E                          1221  ImmediateCount
0000160E                          1222              ;Print #$
0000160E  43F9 00001B45           1223              LEA        printIA,A1
00001614  103C 000E               1224              MOVE.B     #14,D0
00001618  4E4F                    1225              TRAP       #15
0000161A                          1226              
0000161A                          1227              ;Copy the address values into a register
0000161A  3412                    1228              MOVE.W     (A2),D2
0000161C                          1229              
0000161C                          1230              ;Passing in parameters for isolating bits 9-11
0000161C  163C 0009               1231              MOVE.B      #9,D3             ;Start bit index = 9
00001620  183C 0003               1232              MOVE.B      #3,D4             ;Number of bits needed = 3
00001624                          1233              
00001624                          1234              ;Jumps to getBits and returns with isolated bits in D2
00001624  6100 FBAE               1235              BSR         getBits  
00001628                          1236              
00001628                          1237              ;Check if shift count is 8
00001628  B43C 0000               1238              CMP.B       #%000,D2
0000162C  6700 0010               1239              BEQ         ShiftEight
00001630                          1240              
00001630  1202                    1241              MOVE.B      D2, D1
00001632  6100 0002               1242              BSR         ImmediateCount2
00001636                          1243             
00001636                          1244  ImmediateCount2
00001636                          1245              ;Print shift count
00001636  103C 0003               1246              MOVE.B      #3,D0
0000163A  4E4F                    1247              TRAP        #15
0000163C  61A6                    1248              BSR         RegShift2
0000163E                          1249   
0000163E                          1250  ShiftEight  ;Move 8 into D1    
0000163E  123C 0008               1251              MOVE.B      #8, D1
00001642  61F2                    1252              BSR         ImmediateCount2
00001644                          1253                                     
00001644                          1254  MemShift
00001644                          1255              ;Copy the address values into a register
00001644  3412                    1256              MOVE.W     (A2),D2
00001646                          1257              
00001646                          1258              ;Passing in parameters for isolating bit 9
00001646  163C 0009               1259              MOVE.B      #9,D3             ;Start bit index = 9
0000164A  183C 0001               1260              MOVE.B      #1,D4             ;Number of bits needed = 1
0000164E                          1261              
0000164E                          1262              ;Jumps to getBits and returns with isolated bits in D2
0000164E  6100 FB84               1263              BSR         getBits  
00001652                          1264              
00001652                          1265              ;Checks if ASd
00001652  B43C 0000               1266              CMP.B       #%0,D2
00001656  6700 0022               1267              BEQ         MemAS
0000165A                          1268              
0000165A                          1269              ;Checks if LSd
0000165A  B43C 0001               1270              CMP.B       #%1,D2
0000165E  6700 0022               1271              BEQ         MemLS
00001662                          1272  
00001662                          1273  MemShift2   
00001662                          1274              ;Print Space
00001662  43F9 00001B57           1275              LEA        printSpace,A1
00001668  103C 000E               1276              MOVE.B     #14,D0
0000166C  4E4F                    1277              TRAP       #15
0000166E                          1278              
0000166E                          1279              ;*Memory Address*
0000166E                          1280              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000166E                          1281              ;D6 will contain mode & D7 will contain the register after this instruction
0000166E  6100 0148               1282              BSR         isolateAddressBit0to5
00001672                          1283              
00001672                          1284              ;*Print source address*
00001672  6100 01F4               1285              BSR         addressModeSR
00001676                          1286              
00001676  6000 FB4E               1287              BRA         update
0000167A                          1288              
0000167A                          1289  MemAS       ;Print AS
0000167A  6100 002C               1290              BSR         MAS      
0000167E  6100 0036               1291              BSR         MemDirectionSubroutine                
00001682                          1292  
00001682                          1293              
00001682                          1294  MemLS       ;Print LS
00001682  6100 0016               1295              BSR         MLS      
00001686  6100 002E               1296              BSR         MemDirectionSubroutine
0000168A                          1297              
0000168A                          1298  RegAS       ;Print AS
0000168A  6100 001C               1299              BSR         MAS      
0000168E  6100 0062               1300              BSR         RegDirectionSubroutine                
00001692                          1301  
00001692                          1302              
00001692                          1303  RegLS       ;Print LS
00001692  6100 0006               1304              BSR         MLS      
00001696  6100 005A               1305              BSR         RegDirectionSubroutine
0000169A                          1306  
0000169A                          1307  MLS:
0000169A  43F9 00001B20           1308              LEA        printMLS,A1
000016A0  103C 000E               1309              MOVE.B     #14,D0
000016A4  4E4F                    1310              TRAP       #15
000016A6  4E75                    1311              RTS
000016A8                          1312  MAS:
000016A8  43F9 00001B1B           1313              LEA        printMAS,A1
000016AE  103C 000E               1314              MOVE.B     #14,D0
000016B2  4E4F                    1315              TRAP       #15
000016B4  4E75                    1316              RTS
000016B6                          1317  
000016B6                          1318  MemDirectionSubroutine
000016B6                          1319              ;Copy the address values into a register
000016B6  3412                    1320              MOVE.W     (A2),D2
000016B8                          1321              
000016B8                          1322              ;Passing in parameters for isolating bit 8
000016B8  163C 0008               1323              MOVE.B      #8,D3             ;Start bit index = 8
000016BC  183C 0001               1324              MOVE.B      #1,D4             ;Number of bits needed = 1
000016C0                          1325              
000016C0                          1326              ;Jumps to getBits and returns with isolated bits in D2
000016C0  6100 FB12               1327              BSR         getBits  
000016C4                          1328              
000016C4                          1329              ;Checks if Right
000016C4  B43C 0000               1330              CMP.B       #%0,D2
000016C8  6700 000A               1331              BEQ         MR
000016CC                          1332              
000016CC                          1333              ;Checks if Left
000016CC  B43C 0001               1334              CMP.B       #%1,D2
000016D0  6700 0010               1335              BEQ         ML
000016D4                          1336                          
000016D4  43F9 00001B27           1337  MR          LEA        printR,A1
000016DA  103C 000E               1338              MOVE.B     #14,D0
000016DE  4E4F                    1339              TRAP       #15
000016E0  6180                    1340              BSR        MemShift2
000016E2                          1341  
000016E2  43F9 00001B25           1342  ML          LEA        printL,A1
000016E8  103C 000E               1343              MOVE.B     #14,D0
000016EC  4E4F                    1344              TRAP       #15
000016EE  6100 FF72               1345              BSR        MemShift2
000016F2                          1346              
000016F2                          1347  RegDirectionSubroutine
000016F2                          1348              ;Copy the address values into a register
000016F2  3412                    1349              MOVE.W     (A2),D2
000016F4                          1350              
000016F4                          1351              ;Passing in parameters for isolating bit 8
000016F4  163C 0008               1352              MOVE.B      #8,D3             ;Start bit index = 8
000016F8  183C 0001               1353              MOVE.B      #1,D4             ;Number of bits needed = 1
000016FC                          1354              
000016FC                          1355              ;Jumps to getBits and returns with isolated bits in D2
000016FC  6100 FAD6               1356              BSR         getBits  
00001700                          1357              
00001700                          1358              ;Checks if Right
00001700  B43C 0000               1359              CMP.B       #%0,D2
00001704  6700 000A               1360              BEQ         RR
00001708                          1361              
00001708                          1362              ;Checks if Left
00001708  B43C 0001               1363              CMP.B       #%1,D2
0000170C  6700 0012               1364              BEQ         RL
00001710                          1365                          
00001710  43F9 00001B27           1366  RR          LEA        printR,A1
00001716  103C 000E               1367              MOVE.B     #14,D0
0000171A  4E4F                    1368              TRAP       #15
0000171C  6100 FE8E               1369              BSR        RegShift
00001720                          1370  
00001720  43F9 00001B25           1371  RL          LEA        printL,A1
00001726  103C 000E               1372              MOVE.B     #14,D0
0000172A  4E4F                    1373              TRAP       #15
0000172C  6100 FE7E               1374              BSR        RegShift
00001730                          1375  
00001730                          1376  
00001730                          1377  *-----------------------------------------------------------------------
00001730                          1378  *-----------------------------------------------------------------------
00001730                          1379  *-----------------------------------------------------------------------
00001730                          1380  
00001730                          1381  
00001730                          1382  
00001730                          1383  
00001730                          1384  ;ADD
00001730                          1385  M1101:
00001730  43F9 00001A9D           1386              LEA        printADD,A1
00001736  103C 000E               1387              MOVE.B     #14,D0
0000173A  4E4F                    1388              TRAP       #15
0000173C                          1389              
0000173C  4202                    1390              CLR.B      D2
0000173E  4203                    1391              CLR.B      D3
00001740                          1392              
00001740                          1393              ;======Isolate Size (S) Bits=======
00001740                          1394              ;Copy the address values into a register
00001740  3412                    1395              MOVE.W     (A2),D2
00001742                          1396              
00001742                          1397              ;Passing in parameters for isolating size bits
00001742  163C 0006               1398              MOVE.B      #6,D3             ;Start bit index = 6
00001746  183C 0002               1399              MOVE.B      #2,D4             ;Number of bits needed = 2
0000174A                          1400              
0000174A                          1401              ;Jumps to getBits and returns with isolated bits in D2
0000174A  6100 FA88               1402              BSR         getBits  
0000174E                          1403              
0000174E                          1404              ;Jumps to printSizeSubroutine and returns after size has been printed
0000174E  6100 00A6               1405              BSR         printSizeSubroutine
00001752                          1406         
00001752                          1407              ;Let's store the size indicator since it will help us determine how many times
00001752                          1408              ;we have to iterate through addresses to print out the whole instruction
00001752                          1409              ;We will use A4 as the register to temporary store the size
00001752  3842                    1410              MOVE.W      D2,A4
00001754                          1411         
00001754                          1412              ;======Isolate direction (D) Bit=======
00001754                          1413              ; 0 = data register is destination | 1 = Dn is source
00001754  4282                    1414              CLR.L       D2
00001756                          1415              
00001756                          1416              ;Copy the address values into a register
00001756  3412                    1417              MOVE.W      (A2),D2
00001758                          1418              
00001758                          1419              ;Passing in parameters for isolating direction bit
00001758  163C 0008               1420              MOVE.B      #8,D3             ;Start bit index = 8
0000175C  183C 0001               1421              MOVE.B      #1,D4             ;Number of bits needed = 1
00001760                          1422              
00001760                          1423              ;Jumps to getBits and returns with isolated bit in D2
00001760  6100 FA72               1424              BSR         getBits
00001764                          1425              
00001764                          1426              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001764  B43C 0000               1427              CMP.B       #0,D2
00001768  6700 0006               1428              BEQ         dnDest
0000176C  6000 0026               1429              BRA         dnSource
00001770                          1430              
00001770                          1431  
00001770                          1432  *-----------------------------------------------------------------
00001770                          1433  * dnDest, dnSource, & other subroutines for isolating address bits
00001770                          1434  *-----------------------------------------------------------------
00001770                          1435  ;* dnDest,dnSource *
00001770                          1436  ;For: MULS,AND,ADD,SUB,DIVU
00001770                          1437  ;Used by instructions that require Dn as one of their addressing modes.
00001770                          1438  ;dnDest isolates the addressing bits with Dn being the destination address
00001770                          1439  ;dnSource isolates the addressing bits with Dn being the source address
00001770                          1440  
00001770                          1441  dnDest:
00001770                          1442              ;**Used for isolating addressing bits when Dn is the destination**
00001770                          1443              
00001770                          1444              ;*SOURCE*
00001770                          1445              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001770                          1446              ;D6 will contain mode & D7 will contain the register after this instruction
00001770  6100 0046               1447              BSR         isolateAddressBit0to5
00001774                          1448              
00001774                          1449              ;*Print source address*
00001774  6100 00F2               1450              BSR         addressModeSR
00001778                          1451              
00001778                          1452              ;Print comma after source address
00001778  43F9 00001B55           1453              LEA         printComma,A1
0000177E  103C 000E               1454              MOVE.B      #14,D0
00001782  4E4F                    1455              TRAP        #15
00001784                          1456              
00001784                          1457              ;*DESTINATION*
00001784                          1458              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001784                          1459              ;D7 will contain the register after this instruction
00001784  6100 0058               1460              BSR         isolateRegisterBit9to11
00001788                          1461              
00001788                          1462              ;Save #%000 into D6 to specify data register mode
00001788  1C3C 0000               1463              MOVE.B      #0,D6
0000178C                          1464              
0000178C                          1465              ;*Print destination address*
0000178C  6100 00DA               1466              BSR         addressModeSR
00001790                          1467  
00001790  6000 FA34               1468              BRA         update
00001794                          1469              
00001794                          1470  dnSource:
00001794                          1471              ;**Used for isolating addressing bits when Dn is the destination**
00001794                          1472                          
00001794                          1473              ;*SOURCE*
00001794                          1474              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001794                          1475              ;D7 will contain the register after this instruction
00001794  6100 0048               1476              BSR         isolateRegisterBit9to11
00001798                          1477              
00001798                          1478              ;Save #%000 into D6 to specify data register mode
00001798  1C3C 0000               1479              MOVE.B      #0,D6
0000179C                          1480              
0000179C                          1481              ;*Print Source address*
0000179C  6100 00CA               1482              BSR         addressModeSR
000017A0                          1483              
000017A0                          1484              ;Print comma after source address
000017A0  43F9 00001B55           1485              LEA         printComma,A1
000017A6  103C 000E               1486              MOVE.B      #14,D0
000017AA  4E4F                    1487              TRAP        #15
000017AC                          1488              
000017AC                          1489              ;*DESTINATION*
000017AC                          1490              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000017AC                          1491              ;D6 will contain mode & D7 will contain the register after this instruction
000017AC  6100 000A               1492              BSR         isolateAddressBit0to5
000017B0                          1493              
000017B0                          1494              ;*Print destination address*
000017B0  6100 00B6               1495              BSR         addressModeSR
000017B4                          1496  
000017B4  6000 FA10               1497              BRA         update
000017B8                          1498                     
000017B8                          1499  isolateAddressBit0to5:
000017B8                          1500  ;Helper subroutine for isolating the address stored within bits 0-5
000017B8                          1501  ;Stores address mode in D6
000017B8                          1502  ;Stores address register in D7
000017B8                          1503  
000017B8                          1504              ;======Isolate Effective Address Mode (M) Bits=======
000017B8  4282                    1505              CLR.L       D2
000017BA                          1506              
000017BA                          1507              ;Copy the address values into a register
000017BA  3412                    1508              MOVE.W      (A2),D2
000017BC                          1509              
000017BC                          1510              ;Passing in parameters for isolating Mode bits
000017BC  163C 0003               1511              MOVE.B      #3,D3             ;Start bit index = 3
000017C0  183C 0003               1512              MOVE.B      #3,D4             ;Number of bits needed = 3
000017C4                          1513              
000017C4                          1514              ;Jumps to getBits and returns with isolated bits in D2
000017C4  4EB8 11D4               1515              JSR         getBits
000017C8                          1516              
000017C8                          1517              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000017C8  1C02                    1518              MOVE.B      D2,D6
000017CA                          1519              
000017CA                          1520                       
000017CA                          1521              ;======Isolate Effective Address Register (Xn) Bits=======
000017CA  4282                    1522              CLR.L       D2
000017CC                          1523              
000017CC                          1524              ;Copy the address values into a register
000017CC  3412                    1525              MOVE.W      (A2),D2
000017CE                          1526              
000017CE                          1527              ;Passing in parameters for isolating Xn bits
000017CE  163C 0000               1528              MOVE.B      #0,D3             ;Start bit index = 0
000017D2  183C 0003               1529              MOVE.B      #3,D4             ;Number of bits needed = 3
000017D6                          1530              
000017D6                          1531              ;Jumps to getBits and returns with isolated bits in D2
000017D6  6100 F9FC               1532              BSR         getBits
000017DA                          1533              
000017DA                          1534              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000017DA  1E02                    1535              MOVE.B      D2,D7
000017DC                          1536              
000017DC  4E75                    1537              RTS
000017DE                          1538  
000017DE                          1539  isolateRegisterBit9to11:
000017DE                          1540  ;Helper subroutine for isolating the register stored within bits 9-11
000017DE                          1541  ;Stores the address register in D7
000017DE                          1542  
000017DE                          1543              ;======Isolate Register Bits=======
000017DE  4282                    1544              CLR.L       D2
000017E0  4286                    1545              CLR.L       D6
000017E2  4287                    1546              CLR.L       D7
000017E4                          1547              
000017E4                          1548              ;Copy the address values into a register
000017E4  3412                    1549              MOVE.W      (A2),D2
000017E6                          1550              
000017E6                          1551              ;Passing in parameters for isolating register bits
000017E6  163C 0009               1552              MOVE.B      #9,D3             ;Start bit index = 9
000017EA  183C 0003               1553              MOVE.B      #3,D4             ;Number of bits needed = 3
000017EE                          1554              
000017EE                          1555              ;Jumps to getBits and returns with isolated bit in D2
000017EE  6100 F9E4               1556              BSR         getBits
000017F2                          1557              
000017F2                          1558              ;Save register bit into ***D7*** for later use in addressModeSR
000017F2  1E02                    1559              MOVE.B      D2,D7
000017F4                          1560  
000017F4  4E75                    1561              RTS
000017F6                          1562              
000017F6                          1563  *-----------------------------------------------------------
000017F6                          1564  * Print Sizes
000017F6                          1565  *-----------------------------------------------------------
000017F6                          1566  printSizeSubroutine:
000017F6                          1567              ;Prints the apporpriate size
000017F6                          1568              ;PARAMETER:
000017F6                          1569              ;D2 = the size bits
000017F6                          1570              
000017F6                          1571              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
000017F6  B63C 0001               1572              CMP.B      #1,D3
000017FA  6700 001A               1573              BEQ        printMOVESize
000017FE                          1574              
000017FE                          1575              ;Compare to which size is being moved for the opcode
000017FE  B43C 0000               1576              CMP.B      #%00,D2
00001802  6700 003A               1577              BEQ        PByte
00001806                          1578              
00001806  B43C 0001               1579              CMP.B      #%01,D2
0000180A  6700 0040               1580              BEQ        PWord
0000180E                          1581              
0000180E  B43C 0002               1582              CMP.B      #%10,D2
00001812  6700 0046               1583              BEQ        PLong
00001816                          1584           
00001816                          1585  printMOVESize:
00001816                          1586              ;Now that we know we have a MOVE opcode
00001816                          1587              ;Compare to which size is being moved for the opcode
00001816  B43C 0001               1588              CMP.B      #%01,D2
0000181A  6700 0022               1589              BEQ        PByte
0000181E                          1590  
0000181E  B43C 0003               1591              CMP.B      #%11,D2
00001822  6700 0028               1592              BEQ        PWord            
00001826                          1593    
00001826  B43C 0002               1594              CMP.B      #%10,D2
0000182A  6700 002E               1595              BEQ        PLong
0000182E                          1596  
0000182E                          1597  printMOVEMSize:
0000182E                          1598              ;Now that we know we have a MOVEM opcode
0000182E                          1599              ;Compare to which size is being moved for the opcode
0000182E  B43C 0000               1600              CMP.B      #%0,D2
00001832  6700 0018               1601              BEQ        PWord
00001836                          1602  
00001836  B43C 0001               1603              CMP.B      #%1,D2
0000183A  6700 001E               1604              BEQ        PLong 
0000183E                          1605  
0000183E                          1606  PByte:
0000183E  43F9 00001B29           1607              LEA        printSIZEB,A1
00001844  103C 000E               1608              MOVE.B     #14,D0
00001848  4E4F                    1609              TRAP       #15
0000184A                          1610              
0000184A  4E75                    1611              RTS
0000184C                          1612  PWord:
0000184C  43F9 00001B2E           1613              LEA        printSIZEW,A1
00001852  103C 000E               1614              MOVE.B     #14,D0
00001856  4E4F                    1615              TRAP       #15
00001858                          1616              
00001858  4E75                    1617              RTS
0000185A                          1618  PLong:            
0000185A  43F9 00001B34           1619              LEA        printSIZEL,A1
00001860  103C 000E               1620              MOVE.B     #14,D0
00001864  4E4F                    1621              TRAP       #15
00001866                          1622              
00001866  4E75                    1623              RTS
00001868                          1624              
00001868                          1625  *-----------------------------------------------------------
00001868                          1626  * Addressing Mode Implementation
00001868                          1627  *-----------------------------------------------------------
00001868                          1628  addressModeSR:
00001868                          1629              ;Prints address according to the parameters passed in
00001868                          1630              ;PARAMETERS:
00001868                          1631              ;D6 = mode
00001868                          1632              ;D7 = register
00001868                          1633  
00001868                          1634              ;Data register direct
00001868  BC3C 0000               1635              CMP.B       #%000,D6
0000186C  6700 002A               1636              BEQ         DRD
00001870                          1637              
00001870                          1638              ;Address register direct
00001870  BC3C 0001               1639              CMP.B       #%001,D6
00001874  6700 0036               1640              BEQ         ARD
00001878                          1641              
00001878                          1642              ;Address register indirect
00001878  BC3C 0002               1643              CMP.B       #%010,D6
0000187C  6700 0042               1644              BEQ         ARI
00001880                          1645              
00001880                          1646              ;Post Increment
00001880  BC3C 0003               1647              CMP.B       #%011,D6
00001884  6700 005A               1648              BEQ         PI
00001888                          1649              
00001888                          1650              ;Pre Decrement
00001888  BC3C 0004               1651              CMP.B       #%100,D6
0000188C  6700 0072               1652              BEQ         PD
00001890                          1653              
00001890                          1654              ;Immediate/Absolute Addressing
00001890  BC3C 0007               1655              CMP.B       #%111,D6
00001894  6700 008A               1656              BEQ         Address
00001898                          1657  DRD:
00001898                          1658              ;Print D __
00001898  43F9 00001B3C           1659              LEA         printDRD,A1
0000189E  103C 000E               1660              MOVE.B      #14,D0
000018A2  4E4F                    1661              TRAP        #15
000018A4                          1662              
000018A4                          1663              ;Print register number
000018A4  7003                    1664              MOVE.L      #3,D0
000018A6  2207                    1665              MOVE.L      D7,D1
000018A8  4E4F                    1666              TRAP        #15
000018AA                          1667              
000018AA  4E75                    1668              RTS
000018AC                          1669  ARD:
000018AC                          1670              ;Print A __
000018AC  43F9 00001B3E           1671              LEA         printARD,A1
000018B2  103C 000E               1672              MOVE.B      #14,D0
000018B6  4E4F                    1673              TRAP        #15
000018B8                          1674              
000018B8                          1675              ;Print register number
000018B8  7003                    1676              MOVE.L      #3,D0
000018BA  2207                    1677              MOVE.L      D7,D1
000018BC  4E4F                    1678              TRAP        #15
000018BE                          1679              
000018BE  4E75                    1680              RTS
000018C0                          1681  ARI:
000018C0                          1682              ;Print (A __ )
000018C0  43F9 00001B40           1683              LEA         printARI,A1
000018C6  103C 000E               1684              MOVE.B      #14,D0
000018CA  4E4F                    1685              TRAP        #15
000018CC                          1686              
000018CC                          1687              ;Print register number
000018CC  7003                    1688              MOVE.L      #3,D0
000018CE  2207                    1689              MOVE.L      D7,D1
000018D0  4E4F                    1690              TRAP        #15
000018D2                          1691              
000018D2                          1692              ;Print closing ')'
000018D2  43F9 00001B43           1693              LEA         printARI2,A1
000018D8  103C 000E               1694              MOVE.B      #14,D0
000018DC  4E4F                    1695              TRAP        #15
000018DE                          1696              
000018DE  4E75                    1697              RTS
000018E0                          1698  PI:
000018E0                          1699              ;Print (A __)+
000018E0  43F9 00001B49           1700              LEA         printPI,A1
000018E6  103C 000E               1701              MOVE.B      #14,D0
000018EA  4E4F                    1702              TRAP        #15
000018EC                          1703              
000018EC                          1704              ;Print register number
000018EC  7003                    1705              MOVE.L      #3,D0
000018EE  2207                    1706              MOVE.L      D7,D1
000018F0  4E4F                    1707              TRAP        #15
000018F2                          1708              
000018F2                          1709              ;Print closing ')+'
000018F2  43F9 00001B4C           1710              LEA         printPI2,A1
000018F8  103C 000E               1711              MOVE.B      #14,D0
000018FC  4E4F                    1712              TRAP        #15
000018FE                          1713              
000018FE  4E75                    1714              RTS
00001900                          1715  PD:
00001900                          1716              ;Print -(A __)
00001900  43F9 00001B4F           1717              LEA         printPD,A1
00001906  103C 000E               1718              MOVE.B      #14,D0
0000190A  4E4F                    1719              TRAP        #15
0000190C                          1720              
0000190C                          1721              ;Print register number
0000190C  7003                    1722              MOVE.L      #3,D0
0000190E  2207                    1723              MOVE.L      D7,D1
00001910  4E4F                    1724              TRAP        #15
00001912                          1725              
00001912                          1726              ;Print closing ')'
00001912  43F9 00001B53           1727              LEA         printPD2,A1
00001918  103C 000E               1728              MOVE.B      #14,D0
0000191C  4E4F                    1729              TRAP        #15
0000191E                          1730              
0000191E  4E75                    1731              RTS
00001920                          1732              
00001920                          1733  Address:
00001920                          1734              ;Print #--------          
00001920  BE3C 0004               1735              CMP.B       #%100,D7
00001924  6700 0038               1736              BEQ         printImmediate
00001928                          1737              
00001928                          1738              ;Print $--------
00001928  BE3C 0000               1739              CMP.B       #%000,D7
0000192C  6700 0042               1740              BEQ         printAbsolute
00001930                          1741              
00001930                          1742              ;Print $----
00001930  BE3C 0001               1743              CMP.B       #%001,D7
00001934  6700 003A               1744              BEQ         printAbsolute
00001938                          1745              
00001938                          1746              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001938                          1747              ;We will be able to access the contents of either size B or W
00001938  544A                    1748              ADDA.W      #2,A2         
0000193A                          1749  
0000193A                          1750              ;See if we have to print out a long 
0000193A  0C14 0002               1751              CMP.B       #%10,(A4)
0000193E  6700 000A               1752              BEQ         updateLong
00001942                          1753    
00001942                          1754  wordAddress:          
00001942                          1755              ;If we don't branch, then we assume we're printing out a byte or word      
00001942  7003                    1756              MOVE.L      #3,D0
00001944  3212                    1757              MOVE.W      (A2),D1
00001946  4E4F                    1758              TRAP        #15
00001948                          1759              
00001948  4E75                    1760              RTS
0000194A                          1761  
0000194A                          1762  
0000194A                          1763  updateLong:
0000194A                          1764              ;Place the current value into a temp register
0000194A  3812                    1765              MOVE.W      (A2),D4
0000194C                          1766              
0000194C                          1767              ;Shift the bits so we can enter the rest of the values
0000194C  1E3C 0010               1768              MOVE.B      #16,D7
00001950  EFAC                    1769              LSL.L       D7,D4
00001952                          1770              
00001952                          1771              ;Increment A2 to account for the next values in the machine code
00001952  544A                    1772              ADDA.W      #2,A2
00001954                          1773              
00001954                          1774              ;Move the rest of the machine code into our register
00001954                          1775              ;This register should have the whole long values
00001954  3812                    1776              MOVE.W      (A2),D4
00001956                          1777              
00001956                          1778              ;Print out the value in the address
00001956  7003                    1779              MOVE.L      #3,D0
00001958  2204                    1780              MOVE.L      D4,D1
0000195A  4E4F                    1781              TRAP        #15
0000195C                          1782              
0000195C  4E75                    1783              RTS
0000195E                          1784  
0000195E                          1785  *-----------------------------------------------------------
0000195E                          1786  * Print Immediate, or Absolute Addressing symbol
0000195E                          1787  *-----------------------------------------------------------
0000195E                          1788  printImmediate:
0000195E  43F9 00001B45           1789              LEA         printIA,A1
00001964  103C 000E               1790              MOVE.B      #14,D0
00001968  4E4F                    1791              TRAP        #15
0000196A                          1792              
0000196A                          1793              ;Clear D7 so we can branch back and not repeat the process in Address
0000196A  1E3C 0007               1794              MOVE.B      #7,D7
0000196E                          1795              
0000196E  60B0                    1796              BRA         Address
00001970                          1797   
00001970                          1798  printAbsolute:
00001970  43F9 00001B47           1799              LEA         printA,A1
00001976  103C 000E               1800              MOVE.B      #14,D0
0000197A  4E4F                    1801              TRAP        #15
0000197C                          1802              
0000197C                          1803              ;Clear D7 so we can branch back and not repeat the process in Address
0000197C  1E3C 0007               1804              MOVE.B      #7,D7
00001980                          1805              
00001980  609E                    1806              BRA         Address
00001982                          1807  
00001982                          1808  *-----------------------------------------------------------
00001982                          1809  * Print Instructions for NOP and RTS
00001982                          1810  *-----------------------------------------------------------
00001982                          1811  printMNOP:
00001982  43F9 00001A88           1812              LEA        printNOP,A1
00001988  103C 000E               1813              MOVE.B     #14,D0
0000198C  4E4F                    1814              TRAP       #15
0000198E                          1815              
0000198E  6000 F836               1816              BRA        update
00001992                          1817  
00001992                          1818  printMRTS:
00001992  43F9 00001B0F           1819              LEA        printRTS,A1
00001998  103C 000E               1820              MOVE.B     #14,D0
0000199C  4E4F                    1821              TRAP       #15
0000199E                          1822              
0000199E  6000 F826               1823              BRA        update
000019A2                          1824  ;-----------------------------------------------------------
000019A2                          1825  ;ERROR MESSAGES FOR I/O portion
000019A2                          1826  ;-----------------------------------------------------------
000019A2                          1827  charError:
000019A2                          1828              
000019A2  43F9 00001B7A           1829              LEA         invalCh,A1
000019A8  103C 000E               1830              MOVE.B      #14,D0
000019AC  4E4F                    1831              TRAP        #15
000019AE                          1832              
000019AE  6000 F686               1833              BRA         startingPrompt
000019B2                          1834            
000019B2                          1835  oddError:
000019B2  43F9 00001B9B           1836              LEA         odd,A1
000019B8  103C 000E               1837              MOVE.B      #14,D0
000019BC  4E4F                    1838              TRAP        #15
000019BE                          1839              
000019BE  6000 F676               1840              BRA         startingPrompt
000019C2                          1841              
000019C2                          1842  manyCharError:  
000019C2  43F9 00001BC8           1843              LEA         manyChar, A1
000019C8  103C 000E               1844              MOVE.B      #14,D0
000019CC  4E4F                    1845              TRAP        #15
000019CE                          1846              
000019CE  6000 F666               1847              BRA         startingPrompt
000019D2                          1848           
000019D2                          1849  endGreater:
000019D2  43F9 00001C03           1850              LEA         endG,A1
000019D8  103C 000E               1851              MOVE.B      #14,D0
000019DC  4E4F                    1852              TRAP        #15
000019DE                          1853              
000019DE  6000 F656               1854              BRA         startingPrompt
000019E2                          1855      
000019E2                          1856  ;-----------------------------------------------------------
000019E2                          1857  ;MESSAGES
000019E2                          1858  ;-----------------------------------------------------------
000019E2= 57 65 6C 63 6F 6D ...   1859  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001A06= 50 6C 65 61 73 65 ...   1860  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001A48= 50 6C 65 61 73 65 ...   1861  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001A88                          1862  
00001A88                          1863  ;-----------------------------------------------------------
00001A88                          1864  ;OPCODE Messages
00001A88                          1865  ;-----------------------------------------------------------
00001A88= 0D 0A 4E 4F 50 00       1866  printNOP    DC.B        CR,LF,'NOP',0
00001A8E= 0D 0A 4D 4F 56 45 00    1867  printMOVE   DC.B        CR,LF,'MOVE',0
00001A95= 0D 0A 4D 4F 56 45 ...   1868  printMOVEM  DC.B        CR,LF,'MOVEM',0
00001A9D= 0D 0A 41 44 44 00       1869  printADD    DC.B        CR,LF,'ADD',0
00001AA3= 0D 0A 41 44 44 49 00    1870  printADDI   DC.B        CR,LF,'ADDI',0
00001AAA= 0D 0A 53 55 42 00       1871  printSUB    DC.B        CR,LF,'SUB',0
00001AB0= 0D 0A 53 55 42 49 00    1872  printSUBI   DC.B        CR,LF,'SUBI',0
00001AB7= 0D 0A 4D 55 4C 53 ...   1873  printMULS   DC.B        CR,LF,'MULS.W ',0
00001AC1= 0D 0A 44 49 56 55 ...   1874  printDIVU   DC.B        CR,LF,'DIVU.W ',0
00001ACB= 0D 0A 4C 45 41 20 00    1875  printLEA    DC.B        CR,LF,'LEA ',0
00001AD2= 0D 0A 41 4E 44 00       1876  printAND    DC.B        CR,LF,'AND',0
00001AD8= 0D 0A 4E 4F 54 00       1877  printNOT    DC.B        CR,LF,'NOT',0
00001ADE= 0D 0A 4C 53 4C 00       1878  printLSL    DC.B        CR,LF,'LSL',0
00001AE4= 0D 0A 4C 53 52 00       1879  printLSR    DC.B        CR,LF,'LSR',0
00001AEA= 0D 0A 41 53 4C 00       1880  printASL    DC.B        CR,LF,'ASL',0
00001AF0= 0D 0A 41 53 52 00       1881  printASR    DC.B        CR,LF,'ASR',0
00001AF6= 0D 0A 42 4C 54 00       1882  printBLT    DC.B        CR,LF,'BLT',0
00001AFC= 0D 0A 42 47 45 00       1883  printBGE    DC.B        CR,LF,'BGE',0
00001B02= 0D 0A 42 45 51 00       1884  printBEQ    DC.B        CR,LF,'BEQ',0
00001B08= 0D 0A 4A 53 52 20 00    1885  printJSR    DC.B        CR,LF,'JSR ',0
00001B0F= 0D 0A 52 54 53 00       1886  printRTS    DC.B        CR,LF,'RTS',0
00001B15= 0D 0A 42 52 41 00       1887  printBRA    DC.B        CR,LF,'BRA',0
00001B1B= 0D 0A 41 53 00          1888  printMAS    DC.B        CR,LF,'AS',0
00001B20= 0D 0A 4C 53 00          1889  printMLS    DC.B        CR,LF,'LS',0
00001B25= 4C 00                   1890  printL      DC.B        'L',0    
00001B27= 52 00                   1891  printR      DC.B        'R',0
00001B29                          1892  ;-----------------------------------------------------------
00001B29                          1893  ;Size Messages
00001B29                          1894  ;-----------------------------------------------------------
00001B29= 2E 42 20 00             1895  printSIZEB  DC.B        '.B ',0
00001B2E= 2E57 2000 0000          1896  printSIZEW  DC.W        '.W ',0
00001B34= 2E4C2000 00000000       1897  printSIZEL  DC.L        '.L ',0
00001B3C                          1898  
00001B3C                          1899  ;-----------------------------------------------------------
00001B3C                          1900  ;Addressing Mode Messages
00001B3C                          1901  ;-----------------------------------------------------------
00001B3C= 44 00                   1902  printDRD      DC.B        'D',0
00001B3E= 41 00                   1903  printARD      DC.B        'A',0
00001B40= 28 41 00                1904  printARI      DC.B        '(A',0
00001B43= 29 00                   1905  printARI2     DC.B        ')',0
00001B45= 23 00                   1906  printIA       DC.B        '#',0
00001B47= 24 00                   1907  printA        DC.B        '$',0
00001B49= 28 41 00                1908  printPI       DC.B        '(A',0
00001B4C= 29 2B 00                1909  printPI2      DC.B        ')+',0
00001B4F= 2D 28 41 00             1910  printPD       DC.B        '-(A',0
00001B53= 29 00                   1911  printPD2      DC.B        ')',0
00001B55                          1912  
00001B55= 2C 00                   1913  printComma    DC.B        ',',0
00001B57= 20 00                   1914  printSpace    DC.B        ' ',0
00001B59                          1915  
00001B59= 0D 0A 59 6F 75 20 ...   1916  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001B7A                          1917  
00001B7A                          1918  ;-----------------------------------------------------------
00001B7A                          1919  ;ERRORS
00001B7A                          1920  ;-----------------------------------------------------------
00001B7A= 45 52 52 4F 52 3A ...   1921  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001B9B= 45 52 52 4F 52 3A ...   1922  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001BC8= 45 52 52 4F 52 3A ...   1923  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001C03= 45 52 52 4F 52 3A ...   1924  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00001C48= 45 52 52 4F 52 3A ...   1925  sizeError   DC.B        'ERROR: Invalid size instruction',0
00001C68                          1926  
00001C68                          1927  ;-----------------------------------------------------------
00001C68                          1928  ;Ending function that ends our program 
00001C68                          1929  ;-----------------------------------------------------------
00001C68                          1930  ending:
00001C68  43F8 1B59               1931              LEA         theEnd,A1
00001C6C  303C 000E               1932              MOVE        #14,D0
00001C70  4E4F                    1933              TRAP        #15
00001C72                          1934              
00001C72                          1935              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTEADDRESSMOVEM  1402
ADDRESS             1920
ADDRESSMODESR       1868
ARD                 18AC
ARI                 18C0
CHARERROR           19A2
CONTINUEDIVU        14B0
CONVERT             108A
CR                  D
DNDEST              1770
DNSOURCE            1794
DRD                 1898
ENDG                1C03
ENDGREATER          19D2
ENDHEX              1004
ENDING              1C68
ENDINGPROMPT        1062
GETBITS             11D4
IMMEDIATECOUNT      160E
IMMEDIATECOUNT2     1636
INVALCH             1B7A
ISOADDBIT0TO5       1290
ISOLATEADDRESSBIT0TO5  17B8
ISOLATEADDRESSBIT6TO11  130C
ISOLATEREGISTERBIT9TO11  17DE
LETTER              10AE
LF                  A
LISTTOMEM           13D6
LOOP                113E
M00                 12B6
M0000               11EA
M0100               1332
M0110               1494
M1000               1494
M1001               14C0
M1100               1500
M1101               1730
M1110               1574
MADDI               120A
MAIN                1000
MAND                1544
MANYCHAR            1BC8
MANYCHARERROR       19C2
MAS                 16A8
MBEQ                1494
MBGE                1494
MBLT                1494
MBRA                1494
MEFFECT             126E
MEMAS               167A
MEMDIRECTIONSUBROUTINE  16B6
MEMLS               1682
MEMSHIFT            1644
MEMSHIFT2           1662
MEMTOLIST           13E6
MEMTOLISTDESTINATION  1418
MJSR                147C
ML                  16E2
MLEA                1420
MLS                 169A
MMULS               1534
MNOT                1450
MORECHECKS          10DE
MORECHECKS1         10EA
MORECHECKS2         110C
MOVEM               1394
MR                  16D4
MSOURCEDEST         12EE
MSUBI               123A
MULSCHECK           151E
NUMBER              10C2
ODD                 1B9B
ODDERROR            19B2
PBYTE               183E
PD                  1900
PI                  18E0
PLONG               185A
PRINTA              1B47
PRINTABSOLUTE       1970
PRINTADD            1A9D
PRINTADDI           1AA3
PRINTAND            1AD2
PRINTARD            1B3E
PRINTARI            1B40
PRINTARI2           1B43
PRINTASL            1AEA
PRINTASR            1AF0
PRINTBEQ            1B02
PRINTBGE            1AFC
PRINTBLT            1AF6
PRINTBRA            1B15
PRINTCOMMA          1B55
PRINTDIVU           1AC1
PRINTDRD            1B3C
PRINTIA             1B45
PRINTIMMEDIATE      195E
PRINTJSR            1B08
PRINTL              1B25
PRINTLEA            1ACB
PRINTLSL            1ADE
PRINTLSR            1AE4
PRINTMAS            1B1B
PRINTMLS            1B20
PRINTMNOP           1982
PRINTMOVE           1A8E
PRINTMOVEM          1A95
PRINTMOVEMSIZE      182E
PRINTMOVESIZE       1816
PRINTMRTS           1992
PRINTMULS           1AB7
PRINTNOP            1A88
PRINTNOT            1AD8
PRINTPD             1B4F
PRINTPD2            1B53
PRINTPI             1B49
PRINTPI2            1B4C
PRINTR              1B27
PRINTRTS            1B0F
PRINTSIZEB          1B29
PRINTSIZEL          1B34
PRINTSIZESUBROUTINE  17F6
PRINTSIZEW          1B2E
PRINTSPACE          1B57
PRINTSUB            1AAA
PRINTSUBI           1AB0
PWORD               184C
REGAS               168A
REGDIRECTIONSUBROUTINE  16F2
REGLISTSR           1420
REGLS               1692
REGSHIFT            15AC
REGSHIFT2           15E4
RL                  1720
RR                  1710
SHIFTEIGHT          163E
SIZEERROR           1C48
STAHEX              1000
STARTINGPROMPT      1036
TESTING             101A
THEEND              1B59
UPDATE              11C6
UPDATELONG          194A
USEREA              1A48
USERSA              1A06
WELCOME             19E2
WORDADDRESS         1942
