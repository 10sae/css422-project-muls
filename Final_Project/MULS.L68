00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/3/2021 5:04:03 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 0000115C             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29    
00001014                            30  startingPrompt:
00001014                            31              ;Ask the user for the starting hex
00001014  43F9 00001180             32              LEA         userSA,A1
0000101A  103C 000E                 33              MOVE.B      #14,D0
0000101E  4E4F                      34              TRAP        #15
00001020                            35              
00001020                            36              ;Clear the registers in case we had an error
00001020  227C 00000000             37              MOVE.L      #0,A1
00001026  247C 00000000             38              MOVE.L      #0,A2
0000102C  4283                      39              CLR.L       D3
0000102E  4284                      40              CLR.L       D4
00001030  4285                      41              CLR.L       D5
00001032  4286                      42              CLR.L       D6
00001034                            43             
00001034                            44              
00001034                            45              ;Input for the hex (D1 equals number of chars)
00001034  303C 0002                 46              MOVE.W      #2,D0
00001038  4E4F                      47              TRAP        #15
0000103A                            48              
0000103A                            49              ;Moves A1 into A2      
0000103A                            50              ;MOVEA.L     A1,A2
0000103A                            51              
0000103A                            52              ;Makes sure D7 is clear incase we're looping back after an error.
0000103A  4207                      53              CLR.B       D7
0000103C                            54              
0000103C  6000 002A                 55              BRA         convert  
00001040                            56              
00001040                            57  endingPrompt:
00001040                            58              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001040  1E3C 0001                 59              MOVE.B       #1,D7
00001044                            60              
00001044                            61              ;Ask the user for the ending hex
00001044  43F9 000011C2             62              LEA         userEA,A1
0000104A  103C 000E                 63              MOVE.B      #14,D0
0000104E  4E4F                      64              TRAP        #15
00001050                            65              
00001050                            66              ;Clearing the registers so we can reuse them for the ending address
00001050  227C 00000000             67              MOVE.L      #0,A1
00001056  247C 00000000             68              MOVE.L      #0,A2
0000105C  4286                      69              CLR.L       D6
0000105E                            70  
0000105E                            71              ;Input for the hex (D1 equals number of chars)
0000105E  303C 0002                 72              MOVE.W      #2,D0
00001062  4E4F                      73              TRAP        #15
00001064                            74              
00001064                            75              ;Moves A1 into A2      
00001064                            76              ;MOVEA.L     A1,A2
00001064                            77              
00001064  6000 0002                 78              BRA         convert
00001068                            79  
00001068                            80  convert:    
00001068                            81              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001068  B23C 0006                 82              CMP.B       #6, D1
0000106C  6E00 00CE                 83              BGT         manyCharError  
00001070                            84              
00001070                            85              ;See if our counter variable is 0
00001070  B23C 0000                 86              CMP.B       #0,D1
00001074                            87              
00001074                            88              ;This means that we have gone through all the characters
00001074  6700 0046                 89              BEQ         moreChecks
00001078                            90              
00001078                            91              ;Decrement the counter, this means we're about to go through another char
00001078  5301                      92              SUB.B       #1,D1
0000107A                            93  
0000107A                            94              ;Let's move the byte stored at A1
0000107A  1612                      95              MOVE.B      (A2),D3
0000107C                            96              
0000107C                            97              ;If the byte is greater than or equal to hex $40, then it's a letter
0000107C  B63C 0041                 98              CMP.B       #$41,D3
00001080  6C00 000A                 99              BGE         letter
00001084                           100              
00001084                           101              ;If the byte is less than or equal to hex $39, then it's a number
00001084  B63C 0040                102              CMP.B       #$40,D3
00001088  6F00 0016                103              BLE         number
0000108C                           104              
0000108C                           105  letter:
0000108C                           106              ;We do this check to see if the character is greater than or equal 'G'
0000108C  B63C 0047                107              CMP.B       #$47,D3
00001090                           108              ;If so, then display an error and ask the user to enter startingAdd again
00001090  6C00 008A                109              BGE         charError
00001094                           110              
00001094                           111              ;Subtract the Ascii value to convert to hex
00001094  0403 0037                112              SUB.B       #$37,D3
00001098                           113              ;Move the value back to our register
00001098  14C3                     114              MOVE.B      D3,(A2)+
0000109A                           115              
0000109A                           116              ;Shift D5 left to make room for next hex value
0000109A  E986                     117              ASL.L       #4, D6
0000109C                           118              ;Move value to D5
0000109C  DC03                     119              ADD.B      D3, D6
0000109E                           120              
0000109E  60C8                     121              BRA         convert
000010A0                           122             
000010A0                           123  
000010A0                           124  number:          
000010A0                           125             ;We do this check to see if the character is less than or equal to '/'  
000010A0  B63C 002F                126             CMP.B        #$2F,D3
000010A4                           127             ;If so, then display an error and ask the user to enter startingAdd again
000010A4  6F00 0076                128             BLE          charError     
000010A8                           129   
000010A8                           130             ;Check to see if the character is greater than or equal to ':'
000010A8  B63C 003A                131             CMP.B        #$3A,D3
000010AC                           132             ;If so, then display an error and ask the user to enter startingAdd again
000010AC  6C00 006E                133             BGE          charError
000010B0                           134            
000010B0                           135             ;Subtract the Ascii value to convert to hex
000010B0  0403 0030                136             SUB.B        #$30,D3
000010B4                           137             ;Move the value back to our register
000010B4  14C3                     138             MOVE.B       D3,(A2)+
000010B6                           139   
000010B6                           140             ;Shift D5 left to make room for next hex value
000010B6  E986                     141             ASL.L        #4, D6
000010B8                           142             ;Move value to D5
000010B8  DC03                     143             ADD.B        D3, D6
000010BA                           144              
000010BA  60AC                     145             BRA          convert
000010BC                           146   
000010BC                           147            
000010BC                           148  moreChecks:
000010BC                           149              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010BC  BE3C 0001                150              CMP.B      #1,D7
000010C0  6700 0028                151              BEQ        moreChecks2
000010C4                           152              
000010C4  6000 0002                153              BRA        moreChecks1
000010C8                           154   
000010C8                           155  moreChecks1:
000010C8                           156              
000010C8                           157              ;Copy the hex value into a temp register
000010C8  2806                     158              MOVE.L      D6,D4
000010CA                           159              
000010CA                           160              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010CA  1A3C 001F                161              MOVE.B      #31,D5
000010CE                           162              
000010CE                           163              ;Shifts 31 bits, isolates last bit. 
000010CE  EBAC                     164              LSL.L       D5,D4
000010D0                           165  
000010D0                           166              ;Shifts it back 31 bit, isolating the last bit. 
000010D0  EAAC                     167              LSR.L       D5,D4
000010D2                           168  
000010D2                           169              ;If the last bit is 1, address was odd, and throw an error. 
000010D2  B83C 0001                170              CMP.B       #1,D4
000010D6  6700 0054                171              BEQ         oddError   
000010DA                           172                          
000010DA                           173              ;Reset address registers.
000010DA  247C 00000000            174              MOVE.L      #0,A2
000010E0                           175              
000010E0                           176              ;Copy the value to our staHex variable
000010E0  21C6 1000                177              MOVE.L      D6,staHex 
000010E4                           178              
000010E4  4286                     179              CLR.L       D6
000010E6  6000 FF58                180              BRA         endingPrompt     
000010EA                           181              
000010EA                           182  moreChecks2:       
000010EA                           183              
000010EA                           184              ;Copy the hex value into a temp register
000010EA  2806                     185              MOVE.L      D6,D4
000010EC                           186              
000010EC                           187              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010EC  1A3C 001F                188              MOVE.B      #31,D5
000010F0                           189              
000010F0                           190              ;Shifts 31 bits, isolates last bit. 
000010F0  EBAC                     191              LSL.L       D5,D4
000010F2                           192  
000010F2                           193              ;Shifts it back 31 bit, isolating the last bit. 
000010F2  EAAC                     194              LSR.L       D5,D4
000010F4                           195  
000010F4                           196              ;If the last bit is 1, address was odd, and throw an error. 
000010F4  B83C 0001                197              CMP.B       #1,D4
000010F8  6700 0032                198              BEQ         oddError   
000010FC                           199                          
000010FC                           200              ;Reset address registers.
000010FC  247C 00000000            201              MOVE.L      #0,A2
00001102                           202              
00001102                           203              ;Place the value in our ending hex variable
00001102  21C6 1004                204              MOVE.L      D6,endHex 
00001106                           205              
00001106                           206              ;Make D7 a temp location to compare our starting hex
00001106  2E38 1000                207              MOVE.L      staHex,D7
0000110A                           208           
0000110A                           209              
0000110A                           210              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
0000110A  BC87                     211              CMP.L       D7,D6
0000110C  6B00 003E                212              BMI         endGreater
00001110                           213              
00001110                           214              ;done, start reading memory. 
00001110                           215              
00001110                           216              ;Clear all the registers since we have the addresses stored in our variables
00001110  4283                     217              CLR.L       D3
00001112  4285                     218              CLR.L       D5
00001114  4286                     219              CLR.L       D6
00001116  4287                     220              CLR.L       D7
00001118                           221              
00001118  6000 01D6                222              BRA         ending    
0000111C                           223  
0000111C                           224  charError:
0000111C                           225              
0000111C  43F9 00001222            226              LEA         invalCh,A1
00001122  103C 000E                227              MOVE.B      #14,D0
00001126  4E4F                     228              TRAP        #15
00001128                           229              
00001128  6000 FEEA                230              BRA         startingPrompt
0000112C                           231            
0000112C                           232  oddError:
0000112C  43F9 00001243            233              LEA         odd,A1
00001132  103C 000E                234              MOVE.B      #14,D0
00001136  4E4F                     235              TRAP        #15
00001138                           236              
00001138  6000 FEDA                237              BRA         startingPrompt
0000113C                           238              
0000113C                           239  manyCharError:  
0000113C  43F9 00001270            240              LEA         manyChar, A1
00001142  103C 000E                241              MOVE.B      #14,D0
00001146  4E4F                     242              TRAP        #15
00001148                           243              
00001148  6000 FECA                244              BRA         startingPrompt
0000114C                           245           
0000114C                           246  endGreater:
0000114C  43F9 000012AB            247              LEA         endG,A1
00001152  103C 000E                248              MOVE.B      #14,D0
00001156  4E4F                     249              TRAP        #15
00001158                           250              
00001158  6000 FEBA                251              BRA         startingPrompt
0000115C                           252      
0000115C                           253  ;-----------------------------------------------------------
0000115C                           254  ;MESSAGES
0000115C                           255  ;-----------------------------------------------------------
0000115C= 57 65 6C 63 6F 6D ...    256  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001180= 50 6C 65 61 73 65 ...    257  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
000011C2= 50 6C 65 61 73 65 ...    258  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001202                           259  
00001202                           260  ;-----------------------------------------------------------
00001202                           261  ;ERRORS
00001202                           262  ;-----------------------------------------------------------
00001202= 45 52 52 4F 52 3A ...    263  toobig      DC.B        'ERROR: The address is too big',CR,LF,0
00001222= 45 52 52 4F 52 3A ...    264  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001243= 45 52 52 4F 52 3A ...    265  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001270= 45 52 52 4F 52 3A ...    266  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
000012AB= 45 52 52 4F 52 3A ...    267  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
000012F0                           268  
000012F0                           269  ending:
000012F0                           270              END         MAIN 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CHARERROR           111C
CONVERT             1068
CR                  D
ENDG                12AB
ENDGREATER          114C
ENDHEX              1004
ENDING              12F0
ENDINGPROMPT        1040
INVALCH             1222
LETTER              108C
LF                  A
MAIN                1000
MANYCHAR            1270
MANYCHARERROR       113C
MORECHECKS          10BC
MORECHECKS1         10C8
MORECHECKS2         10EA
NUMBER              10A0
ODD                 1243
ODDERROR            112C
STAHEX              1000
STARTINGPROMPT      1014
TOOBIG              1202
USEREA              11C2
USERSA              1180
WELCOME             115C
