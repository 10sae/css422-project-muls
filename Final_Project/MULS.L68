00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/4/2021 12:17:07 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  
00001008                            15  ;Used for MOVEM
00001008= 00                        16  counter:    DC.B        $0
00001009= 00                        17  totalCount: DC.B        $0
0000100A= 00                        18  dORa:       DC.B        $0
0000100C= 0000                      19  curAdd:     DC.W        $0
0000100E= 00                        20  movemAdd:   DC.B        $0
0000100F                            21  *-----------------------------------------------------------
0000100F                            22  * I/O Implementation
0000100F                            23  ;1. Prompt user for start and ending addresses (In hex)
0000100F                            24  ;2. User inputs their values
0000100F                            25  ;3. Check for errors
0000100F                            26  ;        Check to see if hex is too big
0000100F                            27  ;        Check to see value doesn't contain G-Z
0000100F                            28  ;        Check to see if there are no commas/special chars
0000100F                            29  ;        Check to see that starting loc, is before ending loc
0000100F                            30  ;        Check to see if value starts at odd mem location
0000100F                            31  *-----------------------------------------------------------
0000100F                            32  
0000100F                            33             ;Show welcome to user
00001010  43F9 00001D0E             34              LEA         Welcome,A1
00001016  103C 000E                 35              MOVE.B      #14,D0
0000101A  4E4F                      36              TRAP        #15
0000101C                            37                       
0000101C                            38              
0000101C                            39        
0000101C                            40              ;MOVEM.L     D0-D7/A0-A6,$23485926
0000101C                            41              ;MOVEM.L     (A5)+,D0-D2/D5-D7/A0-A3/A6
0000101C                            42              ;MOVEM.L     $1234,D0-D5/D7/A0-A6
0000101C                            43              ;MOVEM.L      $3000,A0-A6
0000101C                            44              ;MOVEM.L     D1/D3-D5/A2-A7,$3004
0000101C                            45  
0000101C                            46              ;MOVEM.L     D0-D5/D7/A0-A6,-(A7)     
0000101C                            47              
0000101C                            48  ;==========================            
0000101C                            49              
0000101C                            50  startingPrompt:
0000101C                            51              ;Ask the user for the starting hex3
0000101C  43F9 00001D32             52              LEA         userSA,A1
00001022  103C 000E                 53              MOVE.B      #14,D0
00001026  4E4F                      54              TRAP        #15        
00001028                            55              
00001028                            56              ;Clear the registers in case we had an error
00001028  227C 00000000             57              MOVE.L      #0,A1
0000102E  247C 00000000             58              MOVE.L      #0,A2
00001034  4283                      59              CLR.L       D3
00001036  4284                      60              CLR.L       D4
00001038  4285                      61              CLR.L       D5
0000103A  4286                      62              CLR.L       D6
0000103C                            63             
0000103C                            64              
0000103C                            65              ;Input for the hex (D1 equals number of chars)
0000103C  303C 0002                 66              MOVE.W      #2,D0
00001040  4E4F                      67              TRAP        #15
00001042                            68              
00001042                            69              ;Moves A1 into A2      
00001042                            70              ;MOVEA.L     A1,A2
00001042                            71              
00001042                            72              ;Makes sure D7 is clear incase we're looping back after an error.
00001042  4207                      73              CLR.B       D7
00001044                            74              
00001044  6000 002A                 75              BRA         convert  
00001048                            76              
00001048                            77  endingPrompt:
00001048                            78              ;D7 is if we're working with the first or second prompt, used in the more checks section. 
00001048  1E3C 0001                 79              MOVE.B       #1,D7
0000104C                            80              
0000104C                            81              ;Ask the user for the ending hex
0000104C  43F9 00001D74             82              LEA         userEA,A1
00001052  103C 000E                 83              MOVE.B      #14,D0
00001056  4E4F                      84              TRAP        #15
00001058                            85              
00001058                            86              ;Clearing the registers so we can reuse them for the ending address
00001058  227C 00000000             87              MOVE.L      #0,A1
0000105E  247C 00000000             88              MOVE.L      #0,A2
00001064  4286                      89              CLR.L       D6
00001066                            90  
00001066                            91              ;Input for the hex (D1 equals number of chars)
00001066  303C 0002                 92              MOVE.W      #2,D0
0000106A  4E4F                      93              TRAP        #15
0000106C                            94              
0000106C                            95              ;Moves A1 into A2      
0000106C                            96              ;MOVEA.L     A1,A2
0000106C                            97              
0000106C  6000 0002                 98              BRA         convert
00001070                            99  
00001070                           100  convert:    
00001070                           101              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001070  B23C 0008                102              CMP.B       #8, D1
00001074  6E00 0C78                103              BGT         manyCharError  
00001078                           104              
00001078                           105              ;See if our counter variable is 0
00001078  B23C 0000                106              CMP.B       #0,D1
0000107C                           107              
0000107C                           108              ;This means that we have gone through all the characters
0000107C  6700 0046                109              BEQ         moreChecks
00001080                           110              
00001080                           111              ;Decrement the counter, this means we're about to go through another char
00001080  5301                     112              SUB.B       #1,D1
00001082                           113  
00001082                           114              ;Let's move the byte stored at A1
00001082  1612                     115              MOVE.B      (A2),D3
00001084                           116              
00001084                           117              ;If the byte is greater than or equal to hex $40, then it's a letter
00001084  B63C 0041                118              CMP.B       #$41,D3
00001088  6C00 000A                119              BGE         letter
0000108C                           120              
0000108C                           121              ;If the byte is less than or equal to hex $39, then it's a number
0000108C  B63C 0040                122              CMP.B       #$40,D3
00001090  6F00 0016                123              BLE         number
00001094                           124              
00001094                           125  letter:
00001094                           126              ;We do this check to see if the character is greater than or equal 'G'
00001094  B63C 0047                127              CMP.B       #$47,D3
00001098                           128              ;If so, then display an error and ask the user to enter startingAdd again
00001098  6C00 0C34                129              BGE         charError
0000109C                           130              
0000109C                           131              ;Subtract the Ascii value to convert to hex
0000109C  0403 0037                132              SUB.B       #$37,D3
000010A0                           133              ;Move the value back to our register
000010A0  14C3                     134              MOVE.B      D3,(A2)+
000010A2                           135              
000010A2                           136              ;Shift D5 left to make room for next hex value
000010A2  E986                     137              ASL.L       #4, D6
000010A4                           138              ;Move value to D5
000010A4  DC03                     139              ADD.B      D3, D6
000010A6                           140              
000010A6  60C8                     141              BRA         convert
000010A8                           142             
000010A8                           143  
000010A8                           144  number:          
000010A8                           145             ;We do this check to see if the character is less than or equal to '/'  
000010A8  B63C 002F                146             CMP.B        #$2F,D3
000010AC                           147             ;If so, then display an error and ask the user to enter startingAdd again
000010AC  6F00 0C20                148             BLE          charError     
000010B0                           149   
000010B0                           150             ;Check to see if the character is greater than or equal to ':'
000010B0  B63C 003A                151             CMP.B        #$3A,D3
000010B4                           152             ;If so, then display an error and ask the user to enter startingAdd again
000010B4  6C00 0C18                153             BGE          charError
000010B8                           154            
000010B8                           155             ;Subtract the Ascii value to convert to hex
000010B8  0403 0030                156             SUB.B        #$30,D3
000010BC                           157             ;Move the value back to our register
000010BC  14C3                     158             MOVE.B       D3,(A2)+
000010BE                           159   
000010BE                           160             ;Shift D5 left to make room for next hex value
000010BE  E986                     161             ASL.L        #4, D6
000010C0                           162             ;Move value to D5
000010C0  DC03                     163             ADD.B        D3, D6
000010C2                           164              
000010C2  60AC                     165             BRA          convert
000010C4                           166   
000010C4                           167            
000010C4                           168  moreChecks:
000010C4                           169              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010C4  BE3C 0001                170              CMP.B      #1,D7
000010C8  6700 0028                171              BEQ        moreChecks2
000010CC                           172              
000010CC  6000 0002                173              BRA        moreChecks1
000010D0                           174   
000010D0                           175  moreChecks1:
000010D0                           176              
000010D0                           177              ;Copy the hex value into a temp register
000010D0  2806                     178              MOVE.L      D6,D4
000010D2                           179              
000010D2                           180              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010D2  1A3C 001F                181              MOVE.B      #31,D5
000010D6                           182              
000010D6                           183              ;Shifts 31 bits, isolates last bit. 
000010D6  EBAC                     184              LSL.L       D5,D4
000010D8                           185  
000010D8                           186              ;Shifts it back 31 bit, isolating the last bit. 
000010D8  EAAC                     187              LSR.L       D5,D4
000010DA                           188  
000010DA                           189              ;If the last bit is 1, address was odd, and throw an error. 
000010DA  B83C 0001                190              CMP.B       #1,D4
000010DE  6700 0BFE                191              BEQ         oddError   
000010E2                           192                          
000010E2                           193              ;Reset address registers.
000010E2  247C 00000000            194              MOVE.L      #0,A2
000010E8                           195              
000010E8                           196              ;Copy the value to our staHex variable
000010E8  21C6 1000                197              MOVE.L      D6,staHex 
000010EC                           198              
000010EC  4286                     199              CLR.L       D6
000010EE  6000 FF58                200              BRA         endingPrompt     
000010F2                           201              
000010F2                           202  moreChecks2:       
000010F2                           203              
000010F2                           204              ;Copy the hex value into a temp register
000010F2  2806                     205              MOVE.L      D6,D4
000010F4                           206              
000010F4                           207              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010F4  1A3C 001F                208              MOVE.B      #31,D5
000010F8                           209              
000010F8                           210              ;Shifts 31 bits, isolates last bit. 
000010F8  EBAC                     211              LSL.L       D5,D4
000010FA                           212  
000010FA                           213              ;Shifts it back 31 bit, isolating the last bit. 
000010FA  EAAC                     214              LSR.L       D5,D4
000010FC                           215  
000010FC                           216              ;If the last bit is 1, address was odd, and throw an error. 
000010FC  B83C 0001                217              CMP.B       #1,D4
00001100  6700 0BDC                218              BEQ         oddError   
00001104                           219                          
00001104                           220              ;Reset address registers.
00001104  247C 00000000            221              MOVE.L      #0,A2
0000110A                           222              
0000110A                           223              ;Place the value in our ending hex variable
0000110A  21C6 1004                224              MOVE.L      D6,endHex 
0000110E                           225              
0000110E                           226              ;Make D7 a temp location to compare our starting hex
0000110E  2E38 1000                227              MOVE.L      staHex,D7
00001112                           228           
00001112                           229              
00001112                           230              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001112  BC87                     231              CMP.L       D7,D6
00001114  6B00 0BE8                232              BMI         endGreater
00001118                           233              
00001118                           234              ;done, start reading memory. 
00001118                           235              
00001118                           236              ;Clear all the registers since we have the addresses stored in our variables
00001118  4283                     237              CLR.L       D3
0000111A  4285                     238              CLR.L       D5
0000111C  4286                     239              CLR.L       D6
0000111E  4287                     240              CLR.L       D7  
00001120                           241              
00001120                           242              ;Copy the value of our starting hex to A2 (temp register)
00001120  2478 1000                243              MOVEA.L     staHex,A2
00001124                           244                          
00001124                           245              
00001124                           246  LOOP:   
00001124                           247              ;We will be printing out the address, regardless if the opcode is valid or not
00001124  43F9 00001DB4            248              LEA         AddressNum,A1
0000112A  103C 000E                249              MOVE.B      #14,D0
0000112E  4E4F                     250              TRAP        #15
00001130                           251              
00001130                           252              ;Print out the address
00001130  700F                     253              MOVE.L      #15,D0
00001132  7410                     254              MOVE.L      #16,D2
00001134  220A                     255              MOVE.L      A2,D1
00001136  4E4F                     256              TRAP        #15
00001138                           257              
00001138  43F9 00001E63            258              LEA         printSpace,A1
0000113E  103C 000E                259              MOVE.B      #14,D0
00001142  4E4F                     260              TRAP        #15
00001144                           261  
00001144                           262              ;--------------------------------------------------------
00001144                           263              ;Check for NOP or RTS
00001144                           264              ;--------------------------------------------------------
00001144                           265              
00001144                           266              ;Move the NOP binary value for comparing
00001144  243C 00004E71            267              MOVE.L      #%0100111001110001,D2
0000114A                           268              
0000114A                           269              ;Check and see i the instruction is NOP
0000114A  B452                     270              CMP.W       (A2),D2
0000114C  6700 0B60                271              BEQ         printMNOP
00001150                           272              
00001150                           273              ;Move the RTS binary value for comparing
00001150  243C 00004E75            274              MOVE.L      #%0100111001110101,D2
00001156                           275              
00001156                           276              ;Check and see if the instruction is RTS
00001156  B452                     277              CMP.W       (A2),D2
00001158  6700 0B64                278              BEQ         printMRTS
0000115C                           279              
0000115C                           280              ;Clear the contents for reusing
0000115C  4282                     281              CLR.L       D2
0000115E                           282              
0000115E                           283              ;--------------------------------------------------------
0000115E                           284              ;Check for ADDI or SUBI, check for four 0's since it's the only
0000115E                           285              ;opcode with this pattern
0000115E                           286              ;--------------------------------------------------------  
0000115E                           287              ;Move the value in A2 to a temp register
0000115E  3412                     288              MOVE.W      (A2),D2
00001160                           289              
00001160                           290              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001160  163C 000C                291              MOVE.B      #12,D3
00001164  183C 0004                292              MOVE.B      #4,D4
00001168                           293              
00001168                           294              ;Jumps to getBits and returns with isolated bits in D2
00001168  6100 0078                295              BSR         getBits
0000116C                           296              
0000116C  B43C 0000                297              CMP.B       #%0000,D2
00001170  6700 0086                298              BEQ         M0000
00001174                           299              
00001174                           300              ;--------------------------------------------------------
00001174                           301              ;Check for MOVE, since it's the only word starting with 00
00001174                           302              ;--------------------------------------------------------            
00001174                           303              ;Move the value in A2 to a temp register
00001174  1412                     304              MOVE.B      (A2),D2
00001176                           305              
00001176                           306              ;Shift 6 bits to the right to isolate the left-most digits
00001176  EC8A                     307              LSR.L       #6,D2
00001178                           308              
00001178                           309              ;If the first two bits (left-most) are 00, then the instruction is MOVE
00001178  B43C 0000                310              CMP.B       #00,D2
0000117C  6F00 014E                311              BLE         M00
00001180                           312              
00001180                           313              ;Reuse the register
00001180  4282                     314              CLR.L       D2
00001182                           315              
00001182                           316              
00001182                           317              ;--------------------------------------------------------
00001182                           318              ;Check for other OpCodes
00001182                           319              ;--------------------------------------------------------
00001182                           320              ;Move the word into a temp register 
00001182  3412                     321              MOVE.W      (A2),D2
00001184                           322              
00001184                           323              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001184  163C 000C                324              MOVE.B        #12,D3            ;Start bit index = 12
00001188  183C 0004                325              MOVE.B        #4,D4             ;Number of bits needed = 4
0000118C                           326              
0000118C                           327              ;Jumps to getBits and returns with isolated bits in D2
0000118C  6100 0054                328              BSR           getBits            
00001190                           329  
00001190                           330              
00001190                           331              ;MOVEM,LEA,NOT,JSR
00001190  B43C 0004                332              CMP.B       #%0100,D2
00001194  6700 01B4                333              BEQ         M0100
00001198                           334              
00001198                           335              ;BRA,BLT,BGE,BEQ
00001198  B43C 0006                336              CMP.B       #%0110,D2
0000119C  6700 0478                337              BEQ         M0110
000011A0                           338              
000011A0                           339              ;DIVU
000011A0  B43C 0008                340              CMP.B       #%1000,D2
000011A4  6700 05EC                341              BEQ         M1000
000011A8                           342              
000011A8                           343              ;SUB
000011A8  B43C 0009                344              CMP.B       #%1001,D2
000011AC  6700 0610                345              BEQ         M1001
000011B0                           346              
000011B0                           347              ;MULS,AND
000011B0  B43C 000C                348              CMP.B       #%1100,D2
000011B4  6700 064C                349              BEQ         M1100
000011B8                           350              
000011B8                           351              ;LSL,LSR,ASL,ASR
000011B8  B43C 000E                352              CMP.B       #%1110,D2
000011BC  6700 06B8                353              BEQ         M1110
000011C0                           354              
000011C0                           355              ;ADD
000011C0  B43C 000D                356              CMP.B       #%1101,D2
000011C4  6700 086E                357              BEQ         M1101
000011C8                           358              
000011C8                           359              ;BSR         invalOpCode
000011C8                           360              
000011C8  6000 0DCA                361              BRA         ending
000011CC                           362              
000011CC                           363              
000011CC                           364              
000011CC                           365  
000011CC                           366             
000011CC                           367  update:
000011CC                           368              *=====Important if we've done any Immediate or Absolute addressing=====*
000011CC                           369              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
000011CC                           370              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
000011CC                           371              ;because A2 always points at the the first word in an instruction (opcode).
000011CC  B5CE                     372              CMP.L       A6,A2
000011CE  6C00 0004                373              BGE         skipA6
000011D2                           374              
000011D2                           375              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
000011D2  244E                     376              MOVEA.L     A6,A2
000011D4                           377              
000011D4                           378  skipA6:
000011D4                           379              ;Check and see if we are at the ending hex
000011D4  B5F8 1004                380              CMP.L      endHex,A2
000011D8  6E00 0DBA                381              BGT        ending
000011DC                           382  
000011DC                           383              ;Update address in A2
000011DC  544A                     384              ADDA.W      #2,A2
000011DE                           385              
000011DE                           386              
000011DE  6000 FF44                387              BRA        LOOP
000011E2                           388              
000011E2                           389              
000011E2                           390  getBits:
000011E2                           391              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
000011E2                           392              ;PARAMETERS:
000011E2                           393              ;D2 = the value the bits are extracted from & saved back in
000011E2                           394              ;D3 = the start bit index (starting from 0)
000011E2                           395              ;D4 = the number of bits we want to extract
000011E2                           396              
000011E2                           397              ;Calculate left shift
000011E2  3A3C 0010                398              MOVE.W      #16,D5
000011E6                           399              
000011E6  D843                     400              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
000011E8  9A44                     401              SUB.W       D4,D5             ; 16 - X = leftShift
000011EA                           402              
000011EA  EB6A                     403              LSL.W       D5,D2
000011EC                           404              
000011EC                           405              
000011EC                           406              ;Calculate right shift
000011EC  DA43                     407              ADD.W       D3,D5             ; start bit + leftShift = X
000011EE  EA6A                     408              LSR.W       D5,D2
000011F0                           409              
000011F0  4283                     410              CLR.L       D3
000011F2  4284                     411              CLR.L       D4
000011F4  4285                     412              CLR.L       D5   
000011F6  4E75                     413              RTS
000011F8                           414  
000011F8                           415  *-----------------------------------------------------------
000011F8                           416  * 
000011F8                           417  *
000011F8                           418  *
000011F8                           419  * OpCode Implementation
000011F8                           420  *
000011F8                           421  *
000011F8                           422  *
000011F8                           423  *-----------------------------------------------------------
000011F8                           424  
000011F8                           425  
000011F8                           426  *-----------------------------------------------------------
000011F8                           427  * ADDI/SUBI INSTRUCTION
000011F8                           428  *-----------------------------------------------------------
000011F8                           429  M0000:
000011F8  4282                     430              CLR.L       D2
000011FA  4283                     431              CLR.L       D3
000011FC                           432              
000011FC                           433              ;Copy the address values into a register to check for ADDI or SUBI
000011FC  3412                     434              MOVE.W      (A2),D2
000011FE                           435              
000011FE                           436              ;Passing in paramters for isolating bits
000011FE  163C 0008                437              MOVE.B      #8,D3
00001202  183C 0004                438              MOVE.B      #4,D4
00001206                           439              
00001206                           440              ;Jumps to getBits and returns with isolated bits in D2
00001206  61DA                     441              BSR         getBits
00001208                           442              
00001208                           443              ;--------------------------------------------------------
00001208                           444              ;Check for ADDI
00001208                           445              ;--------------------------------------------------------
00001208  B43C 0006                446              CMP.B       #%0110,D2
0000120C  6700 000A                447              BEQ         MADDI
00001210                           448             
00001210                           449              ;--------------------------------------------------------
00001210                           450              ;Check for SUBI
00001210                           451              ;--------------------------------------------------------
00001210  B43C 0004                452              CMP.B       #%0100,D2
00001214  6700 0036                453              BEQ         MSUBI
00001218                           454  
00001218                           455  MADDI:
00001218  43F9 00001DD3            456              LEA         printADDI,A1
0000121E  103C 000E                457              MOVE.B      #14,D0
00001222  4E4F                     458              TRAP        #15
00001224                           459              
00001224  4282                     460              CLR.L       D2
00001226  4283                     461              CLR.L       D3
00001228                           462              
00001228                           463              ;======Isolate Size (S) Bits======
00001228                           464              ;Copy the address values into a register
00001228  3412                     465              MOVE.W      (A2),D2
0000122A                           466              
0000122A                           467              ;Passing in parameters for isolating size bits
0000122A  163C 0006                468              MOVE.B      #6,D3
0000122E  183C 0002                469              MOVE.B      #2,D4
00001232                           470              
00001232                           471              ;Jumps to getBits and returns with isolated bits in D2
00001232  61AE                     472              BSR         getBits
00001234                           473              
00001234                           474              ;Jumps to printSizeSubroutine and returns after size has been printed
00001234  6100 08C8                475              BSR         printSizeSubroutine
00001238                           476              
00001238                           477              ;Let's store the size indicator since it will help us determine how many times
00001238                           478              ;we have to iterate through addresses to print out the whole instruction
00001238                           479              ;We will use A4 as the register to temporary store the size
00001238  3842                     480              MOVE.W      D2,A4
0000123A  11C2 2000                481              MOVE.B      D2,$2000
0000123E                           482              
0000123E                           483              ;Clear the register so we can reuse it
0000123E  4282                     484              CLR.L       D2
00001240                           485              
00001240  1412                     486              MOVE.B      (A2),D2
00001242                           487              
00001242                           488              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001242                           489              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001242  264A                     490              MOVE.L      A2,A3
00001244                           491              
00001244  6100 003E                492              BSR         mEffect
00001248                           493              
00001248  4283                     494              CLR.L       D3
0000124A                           495              
0000124A  6080                     496              BRA         update
0000124C                           497              
0000124C                           498              
0000124C                           499  MSUBI:
0000124C  43F9 00001DDC            500              LEA         printSUBI,A1
00001252  103C 000E                501              MOVE.B      #14,D0
00001256  4E4F                     502              TRAP        #15
00001258                           503              
00001258  4282                     504              CLR.L       D2
0000125A  4283                     505              CLR.L       D3
0000125C                           506              
0000125C                           507              ;======Isolate Size (S) Bits======
0000125C                           508              ;Copy the address values into a register
0000125C  3412                     509              MOVE.W      (A2),D2
0000125E                           510              
0000125E                           511              ;Passing in parameters for isolating size bits
0000125E  163C 0006                512              MOVE.B      #6,D3
00001262  183C 0002                513              MOVE.B      #2,D4
00001266                           514              
00001266                           515              ;Jumps to getBits and returns with isolated bits in D2
00001266  6100 FF7A                516              BSR         getBits
0000126A                           517              
0000126A                           518              ;Jumps to printSizeSubroutine and returns after size has been printed
0000126A  6100 0892                519              BSR         printSizeSubroutine
0000126E                           520              
0000126E                           521              ;Let's store the size indicator since it will help us determine how many times
0000126E                           522              ;we have to iterate through addresses to print out the whole instruction
0000126E                           523              ;We will use A4 as the register to temporary store the size
0000126E  3842                     524              MOVE.W      D2,A4
00001270  11C2 2000                525              MOVE.B      D2,$2000
00001274                           526              
00001274                           527              ;Clear the register so we can reuse it
00001274  4282                     528              CLR.L       D2
00001276                           529              
00001276  1412                     530              MOVE.B      (A2),D2
00001278                           531              
00001278                           532              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001278                           533              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001278  264A                     534              MOVE.L      A2,A3
0000127A                           535              
0000127A  6100 0008                536              BSR         mEffect
0000127E                           537              
0000127E  4283                     538              CLR.L       D3
00001280                           539              
00001280  6000 FF4A                540              BRA         update
00001284                           541  
00001284                           542              
00001284                           543  mEffect:
00001284                           544              ;Male D6 #%111 since the source will always be an immediate value 
00001284  1C3C 0007                545              MOVE.B      #7,D6
00001288                           546              ;Make D7 #%100 since the source will always be an immediate value
00001288  1E3C 0004                547              MOVE.B      #4,D7     
0000128C                           548  
0000128C                           549              ;Print source address
0000128C  6100 08E2                550              BSR         addressModeSR
00001290                           551              
00001290                           552              ;Print the comma after the source address
00001290  43F9 00001E61            553              LEA        printComma,A1
00001296  103C 000E                554              MOVE.B     #14,D0
0000129A  4E4F                     555              TRAP       #15
0000129C                           556              
0000129C                           557              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000129C  6100 0008                558              BSR        isoAddBit0to5
000012A0                           559              
000012A0                           560              ;Print source address
000012A0  6100 08CE                561              BSR        addressModeSR
000012A4                           562              
000012A4  4E75                     563              RTS            
000012A6                           564              
000012A6                           565              
000012A6                           566  isoAddBit0to5:
000012A6                           567              ;===Isolate the Destination Mode (M)Bits===
000012A6  4282                     568              CLR.L      D2
000012A8                           569              
000012A8                           570              ;Copy the address value into a register
000012A8  3413                     571              MOVE.W     (A3),D2
000012AA                           572              
000012AA                           573              ;Passing in parameters for isolating Mode bits
000012AA  163C 0003                574              MOVE.B     #3,D3
000012AE  183C 0003                575              MOVE.B     #3,D4
000012B2                           576              
000012B2                           577              ;Jumps to getBits and returns with isolated bits in D2
000012B2  4EB8 11E2                578              JSR        getBits
000012B6                           579              
000012B6                           580              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000012B6  1C02                     581              MOVE.B     D2,D6
000012B8                           582              
000012B8                           583              ;===Isolate the Destination Address Register (Xn)Bits===
000012B8  4282                     584              CLR.L      D2
000012BA                           585              
000012BA                           586              ;Copy the address values into a register
000012BA  3413                     587              MOVE.W     (A3),D2
000012BC                           588              
000012BC                           589              ;Passing in parameters for isolating Xn bits
000012BC  163C 0000                590              MOVE.B     #0,D3
000012C0  183C 0003                591              MOVE.B     #3,D4
000012C4                           592              
000012C4                           593              ;Jumps to getBits and returns with isolated bits in D2
000012C4  4EB8 11E2                594              JSR        getBits
000012C8                           595              
000012C8                           596              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000012C8  1E02                     597              MOVE.B      D2,D7
000012CA                           598  
000012CA  4E75                     599              RTS
000012CC                           600              
000012CC                           601  *-----------------------------------------------------------
000012CC                           602  * MOVE INSTRUCTION
000012CC                           603  *-----------------------------------------------------------
000012CC                           604  M00:
000012CC  43F9 00001DC4            605              LEA        printMOVE,A1
000012D2  103C 000E                606              MOVE.B     #14,D0
000012D6  4E4F                     607              TRAP       #15
000012D8                           608              
000012D8  4202                     609              CLR.B      D2
000012DA  4203                     610              CLR.B      D3
000012DC                           611              
000012DC                           612              ;======Isolate Size (S) Bits=======
000012DC                           613              ;Copy the address values into a register
000012DC  3412                     614              MOVE.W     (A2),D2
000012DE                           615              
000012DE                           616              ;Passing in parameters for isolating size bits 12,13
000012DE  163C 000C                617              MOVE.B      #12,D3             
000012E2  183C 0002                618              MOVE.B      #2,D4             
000012E6                           619              
000012E6                           620              ;Jumps to getBits and returns with isolated bits in D2
000012E6  6100 FEFA                621              BSR         getBits  
000012EA                           622              
000012EA                           623              ;Indicate to our print function we are doing this for the MOVE opcode
000012EA  163C 0001                624              MOVE.B      #1,D3
000012EE                           625              
000012EE                           626              ;Jumps to printSizeSubroutine and returns after size has been printed
000012EE  6100 080E                627              BSR         printSizeSubroutine
000012F2                           628              
000012F2                           629              ;Let's store the size indicator since it will help us determine how many times
000012F2                           630              ;we have to iterate through addresses to print out the whole instruction
000012F2                           631              ;We will use A4 as the register to temporary store the size
000012F2  3842                     632              MOVE.W      D2,A4
000012F4  11C2 2000                633              MOVE.B      D2,$2000
000012F8                           634  
000012F8                           635              ;Clear the register so we can reuse it
000012F8  4282                     636              CLR.L       D2
000012FA                           637              
000012FA  3412                     638              MOVE.W      (A2),D2
000012FC                           639              
000012FC                           640              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
000012FC                           641              ;This is meant so we can use the copy to figure out the destination addressing mode
000012FC  264A                     642              MOVE.L      A2,A3
000012FE                           643  
000012FE  6000 0002                644              BRA         mSourceDest
00001302                           645              
00001302                           646            
00001302                           647  ;======Helper function to find the destination for MOVE======
00001302                           648  mSourceDest:
00001302                           649              ;SOURCE
00001302                           650              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001302  6100 07BC                651              BSR        isolateAddressBit0to5
00001306                           652              
00001306                           653              ;Print source address
00001306  6100 0868                654              BSR        addressModeSR
0000130A                           655              
0000130A                           656              ;Print the comma after the source address
0000130A  43F9 00001E61            657              LEA        printComma,A1
00001310  103C 000E                658              MOVE.B     #14,D0
00001314  4E4F                     659              TRAP       #15
00001316                           660              
00001316                           661              ;DESTINATION
00001316                           662              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001316  6100 000C                663              BSR        isolateAddressBit6to11
0000131A                           664              
0000131A                           665              ;Print destination address
0000131A  6100 0854                666              BSR        addressModeSR
0000131E                           667              
0000131E  4283                     668              CLR.L      D3
00001320                           669              
00001320  6000 FEAA                670              BRA        update
00001324                           671              
00001324                           672  
00001324                           673  isolateAddressBit6to11:
00001324                           674              ;===Isolate the Destination Mode (M)Bits===
00001324  4282                     675              CLR.L      D2
00001326                           676              
00001326                           677              ;Copy the address value into a register
00001326  3413                     678              MOVE.W     (A3),D2
00001328                           679              
00001328                           680              ;Passing in parameters for isolating Mode bits
00001328  163C 0006                681              MOVE.B     #6,D3
0000132C  183C 0003                682              MOVE.B     #3,D4
00001330                           683              
00001330                           684              ;Jumps to getBits and returns with isolated bits in D2
00001330  4EB8 11E2                685              JSR        getBits
00001334                           686              
00001334                           687              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001334  1C02                     688              MOVE.B     D2,D6
00001336                           689              
00001336                           690              ;===Isolate the Destination Address Register (Xn)Bits===
00001336  4282                     691              CLR.L      D2
00001338                           692              
00001338                           693              ;Copy the address values into a register
00001338  3413                     694              MOVE.W     (A3),D2
0000133A                           695              
0000133A                           696              ;Passing in parameters for isolating Xn bits
0000133A  163C 0009                697              MOVE.B     #9,D3
0000133E  183C 0003                698              MOVE.B     #3,D4
00001342                           699              
00001342                           700              ;Jumps to getBits and returns with isolated bits in D2
00001342  4EB8 11E2                701              JSR        getBits
00001346                           702              
00001346                           703              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001346  1E02                     704              MOVE.B      D2,D7
00001348                           705  
00001348  4E75                     706              RTS
0000134A                           707              
0000134A                           708              
0000134A                           709  *-----------------------------------------------------------
0000134A                           710  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
0000134A                           711  *-----------------------------------------------------------
0000134A                           712  M0100:      
0000134A  4282                     713              CLR.L       D2
0000134C  4283                     714              CLR.L       D3
0000134E                           715              
0000134E                           716              ;--------------------------------------------------------
0000134E                           717              ;Check for LEA
0000134E                           718              ;--------------------------------------------------------
0000134E                           719              ;Copy the address values into a register to check for LEA
0000134E  3412                     720              MOVE.W     (A2),D2
00001350                           721              
00001350                           722              ;Passing in parameters for isolating bits 6,7,8
00001350  163C 0006                723              MOVE.B      #6,D3             ;Start bit index = 6
00001354  183C 0003                724              MOVE.B      #3,D4             ;Number of bits needed = 3
00001358                           725              
00001358                           726              ;Jumps to getBits and returns with isolated bits in D2
00001358  6100 FE88                727              BSR         getBits
0000135C                           728  
0000135C  B43C 0007                729              CMP.B       #%111,D2
00001360  6700 0240                730              BEQ         MLEA
00001364                           731  
00001364                           732              ;--------------------------------------------------------
00001364                           733              ;Check for NOT
00001364                           734              ;--------------------------------------------------------
00001364                           735              ;Clear D2 and recopy it to check for NOT
00001364  4282                     736              CLR.L       D2
00001366  3412                     737              MOVE.W      (A2),D2
00001368                           738              
00001368                           739              ;Pass in parameters for isolating bits 8,9,10,11
00001368  163C 0008                740              MOVE.B      #8,D3
0000136C  183C 0004                741              MOVE.B      #4,D4
00001370                           742              
00001370                           743              ;Jumps to getBits and returns with isolated bits in D2
00001370  6100 FE70                744              BSR         getBits
00001374                           745              
00001374  B43C 0006                746              CMP.B       #%0110,D2
00001378  6700 0258                747              BEQ         MNOT      
0000137C                           748              
0000137C                           749              ;--------------------------------------------------------
0000137C                           750              ;Check for JSR
0000137C                           751              ;--------------------------------------------------------
0000137C                           752              ;Clear D2 and recopy it to check for JSR
0000137C  4282                     753              CLR.L       D2
0000137E  3412                     754              MOVE.W     (A2),D2
00001380                           755              
00001380                           756              ;Pass in parameters for isolating bits 6-11
00001380  163C 0006                757              MOVE.B      #6,D3
00001384  183C 0006                758              MOVE.B      #6,D4
00001388                           759              
00001388                           760              ;Jumps to getBits and returns with isolated bits in D2
00001388  6100 FE58                761              BSR         getBits
0000138C                           762              
0000138C  B43C 003A                763              CMP.B       #%111010,D2
00001390  6700 026C                764              BEQ         MJSR
00001394                           765              
00001394                           766              ;--------------------------------------------------------
00001394                           767              ;Check for MOVEM
00001394                           768              ;--------------------------------------------------------
00001394                           769              ;Clear D2 and recopy it to check for MOVEM
00001394  4282                     770              CLR.L       D2
00001396  3412                     771              MOVE.W     (A2),D2
00001398                           772              
00001398                           773              ;Pass in parameters for isolating bit 9
00001398  163C 0009                774              MOVE.B      #9,D3
0000139C  183C 0001                775              MOVE.B      #1,D4
000013A0                           776              
000013A0                           777              ;Jumps to getBits and returns with isolated bits in D2
000013A0  6100 FE40                778              BSR         getBits
000013A4                           779              
000013A4  B43C 0000                780              CMP.B       #%0,D2
000013A8  6700 0002                781              BEQ         MOVEM
000013AC                           782              
000013AC                           783         
000013AC                           784  MOVEM:
000013AC  43F9 00001DC9            785              LEA         printMOVEM,A1
000013B2  103C 000E                786              MOVE.B      #14,D0
000013B6  4E4F                     787              TRAP        #15
000013B8                           788              
000013B8                           789              ***Isolate Size Bit***
000013B8                           790              ;Clear D2 and recopy it to check for Size bit
000013B8  4282                     791              CLR.L       D2
000013BA  3412                     792              MOVE.W      (A2),D2
000013BC                           793              
000013BC                           794              ;Pass in paramters for isolating bit 6
000013BC  163C 0006                795              MOVE.B      #6,D3
000013C0  183C 0001                796              MOVE.B      #1,D4
000013C4                           797              
000013C4                           798              ;Jumps to getBits and returns with isolated bits in D2
000013C4  6100 FE1C                799              BSR         getBits
000013C8                           800              
000013C8                           801              ;Print size
000013C8  4EB9 00001B36            802              JSR         printMOVEMSize
000013CE                           803              
000013CE                           804              ;Clear any value in our gloabal variable just in case
000013CE  11FC 0000 100E           805              MOVE.B      #0,movemAdd
000013D4                           806              
000013D4                           807              ;Next we are going to get the addressing mode to determine how we print the register list
000013D4                           808              ;Isolate bits 0 to 5
000013D4  4EB9 00001AC0            809              JSR         isolateAddressBit0to5
000013DA                           810              ;Let's store the addressing mode in our global variable
000013DA  11C6 100E                811              MOVE.B      D6,movemAdd
000013DE                           812              
000013DE  4283                     813              CLR.L       D3
000013E0  4284                     814              CLR.L       D4
000013E2  4286                     815              CLR.L       D6
000013E4                           816              
000013E4                           817              
000013E4                           818              ***Isolate Direction bit
000013E4                           819              ;Clear D2 and recopy it to check for D bit
000013E4  4282                     820              CLR.L       D2
000013E6  3412                     821              MOVE.W      (A2),D2
000013E8                           822              
000013E8                           823              ;Pass in parameters for isolating bit 10
000013E8  163C 000A                824              MOVE.B      #10,D3
000013EC  183C 0001                825              MOVE.B      #1,D4
000013F0                           826              
000013F0                           827              ;Jumps to getBits and returns with isolated bits in D2
000013F0  6100 FDF0                828              BSR         getBits
000013F4                           829  
000013F4                           830              ***Determine the direction of the instruction***
000013F4  B43C 0000                831              CMP.B       #0,D2
000013F8  6700 000A                832              BEQ         ListToMem
000013FC                           833  
000013FC                           834              ;Memory to Register List
000013FC  B43C 0001                835              CMP.B       #1,D2
00001400  6700 0048                836              BEQ         MemToList  
00001404                           837                         
00001404                           838  ListToMem:
00001404                           839              ***SOURCE(Register List)  
00001404  4282                     840              CLR.L       D2
00001406                           841  
00001406                           842              ;A3 will act as our temp variable 
00001406  2678 0000                843              MOVE.L      $00000000,A3
0000140A  364A                     844              MOVEA.W     A2,A3
0000140C                           845              
0000140C                           846              ;Reset 
0000140C  11FC 0000 1009           847              MOVE.B     #$00,totalCount
00001412                           848                          
00001412  11FC 0001 100C           849              MOVE.B      #1,curAdd
00001418                           850              
00001418                           851              ;Go find the register list
00001418  6100 0074                852              BSR         check
0000141C                           853              
0000141C                           854  ListToMem2:
0000141C                           855              ;Print the comma after the source address
0000141C  43F9 00001E61            856              LEA         printComma,A1
00001422  103C 000E                857              MOVE.B      #14,D0
00001426  4E4F                     858              TRAP        #15
00001428                           859              
00001428                           860              ***DESTINATION(Memory)
00001428                           861              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
00001428  4282                     862              CLR.L       D2
0000142A                           863              
0000142A  3412                     864              MOVE.W      (A2),D2
0000142C                           865              
0000142C                           866              ;Isolate bits 0 to 5
0000142C  4EB9 00001AC0            867              JSR         isolateAddressBit0to5
00001432                           868              
00001432  BC3C 0007                869              CMP.B       #%111,D6
00001436  6100 0052                870              BSR         absoluteAddressMOVEM
0000143A                           871              
0000143A                           872              ;Clear A6 since we will need this for later
0000143A  2C7C 00000000            873              MOVE.L      #00000000,A6
00001440                           874              
00001440                           875              ;Print memory address
00001440  6100 072E                876              BSR         addressModeSR
00001444                           877              
00001444  4283                     878              CLR.L      D3
00001446                           879              
00001446  6000 FD84                880              BRA        update
0000144A                           881  
0000144A                           882  
0000144A                           883  MemToList:
0000144A                           884              ***SOURCE(Memory)***
0000144A                           885              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
0000144A  4282                     886              CLR.L       D2            
0000144C                           887              
0000144C  3412                     888              MOVE.W      (A2),D2
0000144E                           889              
0000144E                           890              ;Use A3 as a temp address to be able to access the memory address
0000144E  267C 00000000            891              MOVE.L      #00000000,A3
00001454  364A                     892              MOVEA.W     A2,A3
00001456                           893  
00001456                           894              ;Isolate addressing bits 0 to 5
00001456  4EB9 00001AC0            895              JSR         isolateAddressBit0to5
0000145C                           896              
0000145C  BC3C 0007                897              CMP.B       #%111,D6
00001460  6100 0028                898              BSR         absoluteAddressMOVEM
00001464                           899             
00001464                           900              ;Clear A6 since we will need this for later
00001464  2C7C 00000000            901              MOVE.L      #00000000,A6
0000146A                           902              
0000146A                           903              ;Print memory address
0000146A  6100 0704                904              BSR         addressModeSR
0000146E                           905              
0000146E                           906              ;Print the comma after the source address
0000146E  43F9 00001E61            907              LEA         printComma,A1
00001474  103C 000E                908              MOVE.B      #14,D0
00001478  4E4F                     909              TRAP        #15
0000147A                           910                          
0000147A                           911              ;Reset 
0000147A  11FC 0000 1009           912              MOVE.B      #$00,totalCount
00001480                           913              
00001480  11FC 0000 100C           914              MOVE.B      #0,curAdd
00001486                           915              
00001486                           916              ;Go find the register list
00001486  6100 0006                917              BSR         check
0000148A                           918      
0000148A                           919              
0000148A                           920  absoluteAddressMOVEM:
0000148A  544A                     921              ADDA.W      #2,A2
0000148C                           922  
0000148C  4E75                     923              RTS                     
0000148E                           924                
0000148E                           925  check:
0000148E  0C38 0000 1009           926              CMP.B       #0,(totalCount)
00001494  6700 001C                927              BEQ         findList
00001498                           928  
00001498  0C38 0008 1009           929              CMP.B       #8,(totalCount)
0000149E  6700 0034                930              BEQ         findList2
000014A2                           931     
000014A2                           932              ;We go back to ListToMem which was our starting point
000014A2  0C38 0001 100C           933              CMP.B       #1,(curAdd)
000014A8  6700 FF72                934              BEQ         ListToMem2
000014AC                           935               
000014AC                           936              ;If we arrive here, we assume that we started in MemToList      
000014AC  4283                     937              CLR.L      D3
000014AE                           938              
000014AE  6000 FD1C                939              BRA        update
000014B2                           940  
000014B2                           941  
000014B2                           942  findList:
000014B2                           943              ;Set up the temp register to the register list
000014B2  544B                     944              ADDA.W      #2,A3
000014B4                           945  
000014B4  3413                     946              MOVE.W      (A3),D2
000014B6                           947  
000014B6                           948              ;Clear some registers so we can have a counter
000014B6                           949              ;and two registers to hold a beginning index and then ending index
000014B6  4284                     950              CLR.L       D4
000014B8  4285                     951              CLR.L       D5
000014BA  4286                     952              CLR.L       D6
000014BC  4287                     953              CLR.L       D7  ;Holds the actual value for manipulation
000014BE                           954              
000014BE                           955              ;Set D7 to indicate we are doing the first bit check
000014BE  3E13                     956              MOVE.W      (A3),D7
000014C0                           957              
000014C0                           958              
000014C0                           959              ;===Setting Up Variables===            
000014C0                           960              ;Indicate we are at the start of the word for our counter
000014C0  11FC 0000 1008           961              MOVE.B      #0,counter
000014C6                           962              ;==========================
000014C6                           963              
000014C6                           964              ;The (dORa) variable changes because it must be the opposite of findList 
000014C6  0C38 0003 100E           965              CMP.B       #3,movemAdd
000014CC  6700 0028                966              BEQ         setA
000014D0                           967              
000014D0  6000 001A                968              BRA         setD
000014D4                           969  
000014D4                           970           
000014D4                           971  findList2:           
000014D4  4287                     972              CLR.L       D7
000014D6  1E13                     973              MOVE.B      (A3),D7
000014D8                           974              
000014D8                           975              ;===Setting Up Variables===
000014D8                           976              ;Indicate we are at the start of the word for our counter
000014D8  11FC 0000 1008           977              MOVE.B      #0,counter
000014DE                           978              ;==========================
000014DE                           979              
000014DE                           980              ;The (dORa) variable changes because it must be the opposite of findList            
000014DE  0C38 0003 100E           981              CMP.B       #3,movemAdd
000014E4  6700 0006                982              BEQ         setD
000014E8                           983              
000014E8  6000 000C                984              BRA         setA
000014EC                           985             
000014EC                           986   
000014EC                           987  setD:
000014EC  11FC 0000 100A           988              MOVE.B      #0,dORa
000014F2                           989              
000014F2                           990              ;Go through a loop and rotate bits twice for the D registers
000014F2  6100 000C                991              BSR         bitLoop
000014F6                           992   
000014F6                           993  setA:
000014F6  11FC 0001 100A           994              MOVE.B      #1,dORa
000014FC                           995              
000014FC                           996              ;Go through a loop and rotate bits twice for the D registers
000014FC  6100 0002                997              BSR         bitLoop
00001500                           998  
00001500                           999  bitLoop:
00001500                          1000  
00001500                          1001              ;If our counter is 8, then we must finish printing the list
00001500  0C38 0008 1008          1002              CMP.B       #8,counter
00001506  6786                    1003              BEQ         check
00001508                          1004  
00001508  3407                    1005              MOVE.W      D7,D2
0000150A                          1006              
0000150A                          1007              ;We will use getBits to get the right-most bit (Stored in D2)
0000150A  163C 0000               1008              MOVE.B      #0,D3  ;The starting index of the word
0000150E  183C 0001               1009              MOVE.B      #1,D4  ;How many bits we want
00001512                          1010  
00001512  6100 FCCE               1011              BSR         getBits
00001516                          1012              
00001516                          1013              ;If the bit is 0, then that means we must print out some values
00001516  B43C 0000               1014              CMP.B       #0,D2
0000151A  6700 0006               1015              BEQ         skipBit
0000151E                          1016  
0000151E  6100 000E               1017              BSR         printSingle
00001522                          1018              
00001522                          1019  skipBit:
00001522                          1020              ;Increment the rest of our variables to set up the loop again
00001522  5238 1008               1021              ADD.B       #1,counter
00001526  5238 1009               1022              ADD.B       #1,totalCount
0000152A                          1023              
0000152A  E28F                    1024              LSR.L       #1,D7
0000152C                          1025              
0000152C  60D2                    1026              BRA         bitLoop
0000152E                          1027   
0000152E                          1028  
0000152E                          1029  printSingle:
0000152E                          1030              ;Check and see if we should print D or A
0000152E  0C38 0000 100A          1031              CMP.B       #0,(dORa)
00001534  6700 000C               1032              BEQ         singleDReg
00001538                          1033              
00001538  0C38 0001 100A          1034              CMP.B       #1,(dORa)
0000153E  6700 002A               1035              BEQ         singleAReg
00001542                          1036  
00001542                          1037  singleDReg:
00001542  43F9 00001E48           1038              LEA         printDRD,A1
00001548  103C 000E               1039              MOVE.B      #14,D0
0000154C  4E4F                    1040              TRAP        #15
0000154E                          1041  
0000154E                          1042              ;Print out the register number
0000154E  4281                    1043              CLR.L       D1
00001550  1238 1008               1044              MOVE.B      (counter),D1
00001554  103C 0003               1045              MOVE.B      #3,D0
00001558  4E4F                    1046              TRAP        #15
0000155A                          1047              
0000155A  6100 0038               1048              BSR         pSlash
0000155E                          1049             
0000155E                          1050              
0000155E  5238 1008               1051              ADD.B       #1,counter
00001562  5238 1009               1052              ADD.B       #1,totalCount
00001566                          1053              
00001566  E28F                    1054              LSR.L       #1,D7
00001568                          1055              
00001568  6096                    1056              BRA         bitLoop
0000156A                          1057   
0000156A                          1058  
0000156A                          1059  
0000156A                          1060  singleAReg:
0000156A  43F9 00001E4A           1061              LEA         printARD,A1
00001570  103C 000E               1062              MOVE.B      #14,D0
00001574  4E4F                    1063              TRAP        #15
00001576                          1064  
00001576                          1065              ;Print out the register number
00001576  4281                    1066              CLR.L       D1
00001578  1238 1008               1067              MOVE.B      (counter),D1
0000157C  103C 0003               1068              MOVE.B      #3,D0
00001580  4E4F                    1069              TRAP        #15
00001582                          1070              
00001582  6100 0010               1071              BSR         pSlash
00001586                          1072  
00001586                          1073  
00001586  5238 1008               1074              ADD.B       #1,counter
0000158A  5238 1009               1075              ADD.B       #1,totalCount
0000158E                          1076              
0000158E  E28F                    1077              LSR.L       #1,D7
00001590                          1078              
00001590  6000 FF6E               1079              BRA         bitLoop
00001594                          1080           
00001594                          1081  pSlash:
00001594  43F9 00001E65           1082              LEA         printSlash,A1
0000159A  103C 000E               1083              MOVE.B      #14,D0
0000159E  4E4F                    1084              TRAP        #15
000015A0                          1085              
000015A0  4E75                    1086              RTS       
000015A2                          1087          
000015A2                          1088         
000015A2                          1089  MLEA:
000015A2  43F9 00001DF1           1090              LEA         printLEA,A1
000015A8  103C 000E               1091              MOVE.B      #14,D0
000015AC  4E4F                    1092              TRAP        #15
000015AE                          1093              
000015AE                          1094              ;*SOURCE*
000015AE                          1095              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000015AE                          1096              ;D6 will contain mode & D7 will contain the register after this instruction
000015AE  6100 0510               1097              BSR         isolateAddressBit0to5
000015B2                          1098              
000015B2                          1099              ;*Print source address*
000015B2  6100 05BC               1100              BSR         addressModeSR
000015B6                          1101              
000015B6                          1102              ;Print comma after source address
000015B6  43F9 00001E61           1103              LEA         printComma,A1
000015BC  103C 000E               1104              MOVE.B      #14,D0
000015C0  4E4F                    1105              TRAP        #15
000015C2                          1106              
000015C2                          1107              ;*DESTINATION*
000015C2                          1108              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000015C2                          1109              ;D7 will contain the register after this instruction
000015C2  6100 0522               1110              BSR         isolateRegisterBit9to11
000015C6                          1111              
000015C6                          1112              ;Save #%001 into D6 to specify address register mode
000015C6  1C3C 0001               1113              MOVE.B      #1,D6
000015CA                          1114              
000015CA                          1115              
000015CA                          1116              ;*Print destination address*
000015CA  6100 05A4               1117              BSR         addressModeSR
000015CE                          1118  
000015CE  6000 FBFC               1119              BRA        update
000015D2                          1120  
000015D2                          1121  MNOT:
000015D2                          1122              ;Distinguish NOT from "MOVE to SSR"                 
000015D2                          1123              
000015D2  4282                    1124              CLR.L      D2
000015D4                          1125              ;Move the address into the register to check for size
000015D4  3412                    1126              MOVE.W     (A2),D2
000015D6                          1127              
000015D6                          1128              ;Pass in parameters for isolating bits 6,7
000015D6  163C 0006               1129              MOVE.B     #6,D3
000015DA  183C 0002               1130              MOVE.B     #2,D4
000015DE                          1131              
000015DE                          1132              ;Jump to getbits and return with isolated bits
000015DE  6100 FC02               1133              BSR        getbits
000015E2                          1134  
000015E2                          1135              ;This was meant for invalid opcode testing
000015E2                          1136              ;CMP.B      #%11,D2
000015E2                          1137              ;BRA        InOpCode     
000015E2                          1138  
000015E2  43F9 00001DFA           1139              LEA        printNOT,A1
000015E8  103C 000E               1140              MOVE.B     #14,D0
000015EC  4E4F                    1141              TRAP       #15    
000015EE                          1142              
000015EE                          1143              ;Jumps to printSizeSubroutine and returns after size has been printed
000015EE  6100 050E               1144              BSR        printSizeSubroutine
000015F2                          1145              
000015F2                          1146              ;*SOURCE*
000015F2                          1147              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000015F2                          1148              ;D6 will contain mode & D7 will contain the register after this instruction
000015F2  6100 04CC               1149              BSR        isolateAddressBit0to5
000015F6                          1150              
000015F6                          1151              ;*Print source address*
000015F6  6100 0578               1152              BSR        addressModeSR
000015FA                          1153              
000015FA  6000 FBD0               1154              BRA        update 
000015FE                          1155  
000015FE                          1156  MJSR:
000015FE  43F9 00001E1F           1157              LEA        printJSR,A1
00001604  103C 000E               1158              MOVE.B     #14,D0
00001608  4E4F                    1159              TRAP       #15
0000160A                          1160              
0000160A                          1161              ;*SOURCE*
0000160A                          1162              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000160A                          1163              ;D6 will contain mode & D7 will contain the register after this instruction
0000160A  6100 04B4               1164              BSR        isolateAddressBit0to5
0000160E                          1165              
0000160E                          1166              ;*Print source address*
0000160E  6100 0560               1167              BSR        addressModeSR
00001612                          1168              
00001612  6000 FBB8               1169              BRA        update 
00001616                          1170              
00001616                          1171  
00001616                          1172  *-----------------------------------------------------------
00001616                          1173  * BRA,BLT,BGE,BEQ INSTRUCTIONS
00001616                          1174  *-----------------------------------------------------------       
00001616                          1175  M0110:
00001616  4280                    1176              CLR.L       D0
00001618  4281                    1177              CLR.L       D1
0000161A  4282                    1178              CLR.L       D2
0000161C  4283                    1179              CLR.L       D3
0000161E  4284                    1180              CLR.L       D4
00001620                          1181        
00001620                          1182              ;Moves the instruction into D2
00001620  3412                    1183              MOVE.W     (A2),D2
00001622                          1184              
00001622                          1185              ;Setting up parameters for getBits - isolating bits 11-8
00001622  163C 0008               1186              MOVE.B      #8,D3             ;Start bit index = 8
00001626  183C 0004               1187              MOVE.B      #4,D4             ;Number of bits needed = 4
0000162A                          1188              
0000162A                          1189              ;calls getBits subroutine, D2 now has the four condition bits of the Bcc/BRA instruction. 
0000162A  6100 FBB6               1190              BSR         getBits
0000162E                          1191              
0000162E                          1192              ;If the condition bits are 0000, the instruction is a BRA instruction. 
0000162E  B4BC 00000000           1193              CMP.L       #%0000,D2
00001634  6700 002A               1194              BEQ         MBRA
00001638                          1195              
00001638                          1196              ;0100 = BCC
00001638  B4BC 00000004           1197              CMP.L       #%0100,D2
0000163E  6700 0030               1198              BEQ         MBCC
00001642                          1199              
00001642                          1200              ;1101 = BLT
00001642  B4BC 0000000D           1201              CMP.L       #%1101,D2
00001648  6700 0036               1202              BEQ         MBLT
0000164C                          1203              
0000164C                          1204              ;1100 = BGE
0000164C  B4BC 0000000C           1205              CMP.L       #%1100,D2
00001652  6700 003C               1206              BEQ         MBGE
00001656                          1207              
00001656                          1208              ;0111 = BEQ
00001656  B4BC 00000007           1209              CMP.L       #%0111,D2
0000165C  6700 0042               1210              BEQ         MBEQ
00001660                          1211  
00001660                          1212  MBRA:
00001660                          1213      ;condition bits (11-8) are 0000
00001660  43F9 00001E28           1214              LEA         printBRA,A1
00001666  103C 000E               1215              MOVE.B      #14,D0
0000166A  4E4F                    1216              TRAP        #15
0000166C                          1217              
0000166C  6000 0042               1218              BRA         bccOffset
00001670                          1219  
00001670                          1220  MBCC:
00001670                          1221      ;condition bits (11-8) are 0100     
00001670  43F9 00001E1A           1222              LEA         printBCC,A1
00001676  103C 000E               1223              MOVE.B      #14,D0
0000167A  4E4F                    1224              TRAP        #15
0000167C                          1225  
0000167C  6000 0032               1226              BRA         bccOffset
00001680                          1227  
00001680                          1228  MBLT:
00001680                          1229      ;condition bits (11-8) are 1101
00001680  43F9 00001E0E           1230              LEA         printBLT,A1
00001686  103C 000E               1231              MOVE.B      #14,D0
0000168A  4E4F                    1232              TRAP        #15
0000168C                          1233              
0000168C  6000 0022               1234              BRA         bccOffset
00001690                          1235  
00001690                          1236  MBGE:
00001690                          1237      ;condition bits (11-8) are 1100
00001690  43F9 00001E12           1238              LEA         printBGE,A1
00001696  103C 000E               1239              MOVE.B      #14,D0
0000169A  4E4F                    1240              TRAP        #15
0000169C                          1241              
0000169C  6000 0012               1242              BRA         bccOffset
000016A0                          1243  
000016A0                          1244  MBEQ:            
000016A0                          1245      ;condition bits (11-8) are 0111
000016A0  43F9 00001E16           1246              LEA         printBEQ,A1
000016A6  103C 000E               1247              MOVE.B      #14,D0
000016AA  4E4F                    1248              TRAP        #15
000016AC                          1249              
000016AC  6000 0002               1250              BRA         bccOffset         
000016B0                          1251  
000016B0                          1252  bccOffset:
000016B0                          1253      ;each variation of Bcc, BLT, BEQ, BRA, etc has the same format for the offset bits. Bits 0-7 are either the offset themself, or
000016B0                          1254      ;tell us where to look. If it contains $00, then 16-bit offset. If it contains $FF, 32-bit offset.
000016B0                          1255      
000016B0                          1256              ;Moves the branch family instruction into D2
000016B0  3412                    1257              MOVE.W     (A2),D2
000016B2                          1258              
000016B2                          1259              ;Setting up parameters for getBits - isolating bits 0-7
000016B2  163C 0000               1260              MOVE.B      #0,D3             ;Start bit index = 0
000016B6  183C 0008               1261              MOVE.B      #8,D4             ;Number of bits needed = 8
000016BA                          1262  
000016BA                          1263              ;calls getBits subroutine, D2 now has the offset bits
000016BA  6100 FB26               1264              BSR         getBits
000016BE                          1265              
000016BE                          1266              ;If the offset bits are $00, we need to look at the next 16 bits for the offset.
000016BE  B4BC 00000000           1267              CMP.L       #%00000000,D2
000016C4  6700 0048               1268              BEQ         bit16Displacement
000016C8                          1269              
000016C8                          1270              ;If the offset bits are $FF, we need to look at the next 32 bits for the offset.
000016C8  B4BC 000000FF           1271              CMP.L       #%11111111,D2
000016CE  6700 0080               1272              BEQ         bit32Displacement
000016D2                          1273              
000016D2                          1274              ;If neither of the above two cases are true, we continue to 8bitDisplacement. 
000016D2                          1275              
000016D2                          1276  bit8Displacement:
000016D2                          1277              ;We're here if the 8-bit displacement isn't $00 or $FF, and D2 already has the offset bits.
000016D2                          1278              ;D2 is a twos complement integer specifying the number of bytes between the branch instruction 
000016D2                          1279              ;and the next instruction to be executed (if the condition is met) 
000016D2                          1280              
000016D2                          1281              ;A2 is the address of the current instruction we're working with
000016D2  2C4A                    1282              MOVEA.L      A2,A6
000016D4                          1283            
000016D4  B43C 0080               1284              CMP.B       #$80,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000016D8  6C00 000C               1285              BGE         sub8Bits
000016DC                          1286              
000016DC  6000 0002               1287              BRA         add8Bits
000016E0                          1288  
000016E0                          1289  add8Bits:
000016E0  DCC2                    1290              ADD.W       D2,A6
000016E2  6000 000C               1291              BRA         continue8Bits
000016E6                          1292  sub8Bits:
000016E6                          1293              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
000016E6  4602                    1294              NOT.B       D2      ;inverts D2
000016E8  5302                    1295              SUB.B       #1, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
000016EA                          1296                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
000016EA  9CC2                    1297              SUB.W       D2,A6   
000016EC                          1298              
000016EC  6000 0002               1299              BRA         continue8Bits
000016F0                          1300  
000016F0                          1301  continue8Bits:
000016F0                          1302              
000016F0                          1303              ;Output $
000016F0  43F9 00001E53           1304              LEA         printA,A1
000016F6  103C 000E               1305              MOVE.B      #14,D0
000016FA  4E4F                    1306              TRAP        #15
000016FC                          1307              
000016FC                          1308              ;Output destination address
000016FC  7410                    1309              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
000016FE  700F                    1310              MOVE.L      #15,D0  ;task number
00001700  220E                    1311              MOVE.L      A6,D1
00001702  4E4F                    1312              TRAP        #15
00001704                          1313              
00001704  2C7C 00000000           1314              MOVE.L      #$0,A6
0000170A  6000 FAC0               1315              BRA         update
0000170E                          1316  bit16Displacement:
0000170E                          1317              ;Getting the next 16 bits
0000170E  341A                    1318              MOVE.W      (A2)+,D2
00001710  3412                    1319              MOVE.W      (A2),D2
00001712  2C4A                    1320              MOVEA.L      A2,A6
00001714                          1321            
00001714  B4BC 00008000           1322              CMP.L       #$8000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
0000171A  6C00 000C               1323              BGE         sub16Bits
0000171E                          1324              
0000171E  6000 0002               1325              BRA         add16Bits
00001722                          1326  
00001722                          1327              
00001722                          1328  add16Bits: 
00001722  DCC2                    1329              ADD.W       D2,A6
00001724  6000 000C               1330              BRA         continue16Bits
00001728                          1331  
00001728                          1332  sub16Bits:  
00001728                          1333              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
00001728  4642                    1334              NOT.W       D2      ;inverts D2
0000172A  5742                    1335              SUB.W       #3, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000172C                          1336                                  ;account for the length of the instruction's opperation, which is 4 bytes, so we subtract 3.
0000172C  9CC2                    1337              SUB.W       D2,A6   
0000172E  6000 0002               1338              BRA         continue16Bits
00001732                          1339              
00001732                          1340  continue16Bits:
00001732                          1341              ;Output $
00001732  43F9 00001E53           1342              LEA         printA,A1
00001738  103C 000E               1343              MOVE.B      #14,D0
0000173C  4E4F                    1344              TRAP        #15
0000173E                          1345              
0000173E                          1346              ;Output destination addres
0000173E  7410                    1347              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
00001740  700F                    1348              MOVE.L      #15,D0  ;task number
00001742  220E                    1349              MOVE.L      A6,D1
00001744  4E4F                    1350              TRAP        #15
00001746                          1351              
00001746  2C7C 00000000           1352              MOVE.L      #$0,A6
0000174C  6000 FA7E               1353              BRA         update
00001750                          1354              
00001750                          1355  bit32Displacement:      ;Getting the next 32 bits
00001750  241A                    1356              MOVE.L      (A2)+,D2
00001752  2412                    1357              MOVE.L      (A2),D2
00001754  2C4A                    1358              MOVEA.L     A2,A6
00001756                          1359            
00001756  B4BC 80000000           1360              CMP.L       #$80000000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
0000175C  6C00 000C               1361              BGE         sub32Bits
00001760                          1362              
00001760  6000 0002               1363              BRA         add32Bits
00001764                          1364  
00001764                          1365  add32Bits:
00001764  DDC2                    1366              ADD.L       D2,A6
00001766  6000 000C               1367              BRA         continue32Bits
0000176A                          1368  
0000176A                          1369  sub32Bits:              ;If the displacement is negative, convert it into a regular value and subtract it from the address. 
0000176A  4682                    1370              NOT.L       D2      ;inverts D2
0000176C  5B82                    1371              SUB.L       #5,D2   ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000176E                          1372                                  ;account for the length of the instruction's opperation, which is 6 bytes, so we subtract 5.
0000176E  9DC2                    1373              SUB.L       D2,A6   
00001770  6000 0002               1374              BRA         continue32Bits
00001774                          1375  
00001774                          1376  continue32Bits:      
00001774                          1377              ;Output $
00001774  43F9 00001E53           1378              LEA         printA,A1
0000177A  103C 000E               1379              MOVE.B      #14,D0
0000177E  4E4F                    1380              TRAP        #15
00001780                          1381              
00001780                          1382              ;Output destination addres
00001780  7410                    1383              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
00001782  700F                    1384              MOVE.L      #15,D0  ;task number
00001784  220E                    1385              MOVE.L      A6,D1
00001786  4E4F                    1386              TRAP        #15
00001788                          1387        
00001788  2C7C 00000000           1388              MOVE.L      #$0,A6      
0000178E  6000 FA3C               1389              BRA         update
00001792                          1390  
00001792                          1391  *-----------------------------------------------------------
00001792                          1392  * DIVU INSTRUCTION
00001792                          1393  *-----------------------------------------------------------           
00001792                          1394  M1000:
00001792                          1395              
00001792  4282                    1396              CLR.L       D2
00001794  4283                    1397              CLR.L       D3
00001796                          1398              
00001796                          1399              ;Copy the address values into a register
00001796  3412                    1400              MOVE.W     (A2),D2
00001798                          1401              
00001798                          1402              ;Passing in parameters for isolating bits 6,7,8
00001798  163C 0006               1403              MOVE.B      #6,D3             ;Start bit index = 6
0000179C  183C 0003               1404              MOVE.B      #3,D4             ;Number of bits needed = 3
000017A0                          1405              
000017A0                          1406              ;Jumps to getBits and returns with isolated bits in D2
000017A0  6100 FA40               1407              BSR         getBits
000017A4                          1408              
000017A4                          1409              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
000017A4  B4BC 00000003           1410              CMP.L       #%011,D2
000017AA  6700 0002               1411              BEQ         continueDIVU
000017AE                          1412              
000017AE                          1413              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
000017AE                          1414  
000017AE                          1415  continueDIVU:
000017AE                          1416  
000017AE  43F9 00001DE9           1417              LEA         printDIVU,A1
000017B4  103C 000E               1418              MOVE.B      #14,D0
000017B8  4E4F                    1419              TRAP        #15
000017BA                          1420              
000017BA  6000 02BC               1421              BRA         dnDest
000017BE                          1422              
000017BE                          1423              
000017BE                          1424  *-----------------------------------------------------------
000017BE                          1425  * SUB INSTRUCTION
000017BE                          1426  *-----------------------------------------------------------  
000017BE                          1427  M1001:
000017BE  43F9 00001DD8           1428              LEA        printSUB,A1
000017C4  103C 000E               1429              MOVE.B     #14,D0
000017C8  4E4F                    1430              TRAP       #15
000017CA                          1431              
000017CA  4202                    1432              CLR.B      D2
000017CC  4203                    1433              CLR.B      D3
000017CE                          1434              
000017CE                          1435              ;======Isolate Size (S) Bits=======
000017CE                          1436              ;Copy the address values into a register
000017CE  3412                    1437              MOVE.W     (A2),D2
000017D0                          1438              
000017D0                          1439              ;Passing in parameters for isolating size bits
000017D0  163C 0006               1440              MOVE.B      #6,D3             ;Start bit index = 6
000017D4  183C 0002               1441              MOVE.B      #2,D4             ;Number of bits needed = 2
000017D8                          1442              
000017D8                          1443              ;Jumps to getBits and returns with isolated bits in D2
000017D8  6100 FA08               1444              BSR         getBits  
000017DC                          1445              
000017DC                          1446              ;Jumps to printSizeSubroutine and returns after size has been printed
000017DC  6100 0320               1447              BSR         printSizeSubroutine
000017E0                          1448              
000017E0                          1449              ;Let's store the size indicator since it will help us determine how many times
000017E0                          1450              ;we have to iterate through addresses to print out the whole instruction
000017E0                          1451              ;We will use A4 as the register to temporary store the size
000017E0  3842                    1452              MOVE.W      D2,A4
000017E2  11C2 2000               1453              MOVE.B      D2,$2000
000017E6                          1454              
000017E6                          1455              ;======Isolate direction (D) Bit=======
000017E6                          1456              ; 0 = data register is destination | 1 = Dn is source
000017E6  4282                    1457              CLR.L       D2
000017E8                          1458              
000017E8                          1459              ;Copy the address values into a register
000017E8  3412                    1460              MOVE.W      (A2),D2
000017EA                          1461              
000017EA                          1462              ;Passing in parameters for isolating direction bit
000017EA  163C 0008               1463              MOVE.B      #8,D3             ;Start bit index = 8
000017EE  183C 0001               1464              MOVE.B      #1,D4             ;Number of bits needed = 1
000017F2                          1465              
000017F2                          1466              ;Jumps to getBits and returns with isolated bit in D2
000017F2  6100 F9EE               1467              BSR         getBits
000017F6                          1468              
000017F6                          1469              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000017F6  B43C 0000               1470              CMP.B       #0,D2
000017FA  6700 027C               1471              BEQ         dnDest
000017FE  6000 029C               1472              BRA         dnSource
00001802                          1473  
00001802                          1474  
00001802                          1475  *-----------------------------------------------------------
00001802                          1476  * MULS,AND INSTRUCTIONS
00001802                          1477  *-----------------------------------------------------------  
00001802                          1478  M1100:      
00001802  4282                    1479              CLR.L       D2
00001804  4283                    1480              CLR.L       D3
00001806                          1481              
00001806                          1482              ;Copy the address values into a register
00001806  3412                    1483              MOVE.W     (A2),D2
00001808                          1484              
00001808                          1485              ;Passing in parameters for isolating bits 6 and 7
00001808  163C 0006               1486              MOVE.B      #6,D3             ;Start bit index = 6
0000180C  183C 0002               1487              MOVE.B      #2,D4             ;Number of bits needed = 2
00001810                          1488              
00001810                          1489              ;Jumps to getBits and returns with isolated bits in D2
00001810  6100 F9D0               1490              BSR         getBits  
00001814                          1491              
00001814                          1492              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
00001814  B43C 0003               1493              CMP.B       #%11,D2
00001818  6700 0006               1494              BEQ         mulsCheck
0000181C  6000 0028               1495              BRA         MAND
00001820                          1496              
00001820                          1497  mulsCheck:
00001820                          1498              ;Copy the address values into a register
00001820  3412                    1499              MOVE.W     (A2),D2
00001822                          1500              
00001822                          1501              ;Passing in parameters for isolating bit 8
00001822  163C 0008               1502              MOVE.B      #8,D3             ;Start bit index = 8
00001826  183C 0001               1503              MOVE.B      #1,D4             ;Number of bits needed = 1
0000182A                          1504              
0000182A                          1505              ;Jumps to getBits and returns with isolated bits in D2
0000182A  6100 F9B6               1506              BSR         getBits 
0000182E                          1507              
0000182E                          1508              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
0000182E  B43C 0001               1509              CMP.B       #1,D2
00001832  6700 0002               1510              BEQ         MMULS
00001836                          1511              
00001836                          1512              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001836                          1513  
00001836                          1514              
00001836                          1515              
00001836                          1516              
00001836                          1517  MMULS:
00001836  43F9 00001DE1           1518              LEA         printMULS,A1
0000183C  103C 000E               1519              MOVE.B      #14,D0
00001840  4E4F                    1520              TRAP        #15
00001842                          1521              
00001842  6000 0234               1522              BRA         dnDest 
00001846                          1523  
00001846                          1524  
00001846                          1525  MAND:
00001846  43F9 00001DF6           1526              LEA        printAND,A1
0000184C  103C 000E               1527              MOVE.B     #14,D0
00001850  4E4F                    1528              TRAP       #15
00001852                          1529              
00001852                          1530              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
00001852                          1531              ;Jumps to printSizeSubroutine and returns after size has been printed
00001852  6100 02AA               1532              BSR         printSizeSubroutine
00001856                          1533              
00001856                          1534              ;======Isolate direction (D) Bit=======
00001856                          1535              ; 0 = data register is destination | 1 = Dn is source
00001856  4282                    1536              CLR.L       D2
00001858                          1537              
00001858                          1538              ;Copy the address values into a register
00001858  3412                    1539              MOVE.W      (A2),D2
0000185A                          1540              
0000185A                          1541              ;Passing in parameters for isolating direction bit
0000185A  163C 0008               1542              MOVE.B      #8,D3           ;Start bit index = 8
0000185E  183C 0001               1543              MOVE.B      #1,D4           ;Number of bits needed = 1
00001862                          1544  
00001862                          1545              ;Jumps to getBits and returns with isolated bit in D2
00001862  6100 F97E               1546              BSR         getBits
00001866                          1547              
00001866                          1548              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001866  B43C 0000               1549              CMP.B       #0,D2
0000186A  6700 020C               1550              BEQ         dnDest
0000186E  6000 022C               1551              BRA         dnSource
00001872                          1552              
00001872                          1553              
00001872  6000 F958               1554              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001876                          1555     
00001876                          1556     
00001876                          1557  *-----------------------------------------------------------
00001876                          1558  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001876                          1559  *-----------------------------------------------------------  
00001876                          1560  ; Subroutine to enter when the instruction begins with 1110
00001876                          1561  M1110:
00001876  4282                    1562              CLR.L       D2
00001878  4283                    1563              CLR.L       D3
0000187A                          1564              
0000187A                          1565              ;Copy the address values into a register
0000187A  3412                    1566              MOVE.W     (A2),D2
0000187C                          1567              
0000187C                          1568              ;Passing in parameters for isolating bits 6-7
0000187C  163C 0006               1569              MOVE.B      #6,D3             ;Start bit index = 6
00001880  183C 0002               1570              MOVE.B      #2,D4             ;Number of bits needed = 2
00001884                          1571              
00001884                          1572              ;Jumps to getBits and returns with isolated bits in D2
00001884  6100 F95C               1573              BSR         getBits  
00001888                          1574              
00001888                          1575              ;Check if Memory Shift
00001888  B43C 0003               1576              CMP.B       #%11,D2
0000188C  6700 00BA               1577              BEQ         MemShift
00001890                          1578              
00001890                          1579              ;If not Memory Shift, is a Register Shift
00001890                          1580              
00001890                          1581              ;Copy the address values into a register
00001890  3412                    1582              MOVE.W     (A2),D2
00001892                          1583              
00001892                          1584              ;Passing in parameters for isolating bit 3
00001892  163C 0003               1585              MOVE.B      #3,D3             ;Start bit index = 3
00001896  183C 0001               1586              MOVE.B      #1,D4             ;Number of bits needed = 1
0000189A                          1587              
0000189A                          1588              ;Jumps to getBits and returns with isolated bits in D2
0000189A  6100 F946               1589              BSR         getBits  
0000189E                          1590              
0000189E                          1591              ;Checks if ASd
0000189E  B43C 0000               1592              CMP.B       #%0,D2
000018A2  6700 00EA               1593              BEQ         RegAS
000018A6                          1594              
000018A6                          1595              ;Checks if LSd
000018A6  B43C 0001               1596              CMP.B       #%1,D2
000018AA  6700 00EA               1597              BEQ         RegLS
000018AE                          1598  
000018AE                          1599  ; Subroutine to enter if instruction is given data register to shift
000018AE                          1600  RegShift      
000018AE                          1601              ;Copy the address values into a register
000018AE  3412                    1602              MOVE.W     (A2),D2
000018B0                          1603              
000018B0                          1604              ;Passing in parameters for isolating bits 6-7
000018B0  163C 0006               1605              MOVE.B      #6,D3             ;Start bit index = 6
000018B4  183C 0002               1606              MOVE.B      #2,D4             ;Number of bits needed = 2
000018B8                          1607              
000018B8                          1608              ;Jumps to getBits and returns with isolated bits in D2
000018B8  6100 F928               1609              BSR         getBits  
000018BC                          1610              
000018BC                          1611              ;Print Size
000018BC  6100 0240               1612              BSR         printSizeSubroutine
000018C0                          1613              
000018C0                          1614              ;Copy the address values into a register
000018C0  3412                    1615              MOVE.W     (A2),D2
000018C2                          1616              
000018C2                          1617              ;Passing in parameters for isolating bit 5
000018C2  163C 0005               1618              MOVE.B      #5,D3             ;Start bit index = 5
000018C6  183C 0001               1619              MOVE.B      #1,D4             ;Number of bits needed = 1
000018CA                          1620              
000018CA                          1621              ;Jumps to getBits and returns with isolated bits in D2
000018CA  6100 F916               1622              BSR         getBits  
000018CE                          1623              
000018CE                          1624              ;Checks if shift count is immediate
000018CE  B43C 0000               1625              CMP.B       #%0,D2
000018D2  6700 003C               1626              BEQ         ImmediateCount
000018D6                          1627              
000018D6                          1628              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000018D6                          1629              ;D7 will contain the register after this instruction
000018D6  6100 020E               1630              BSR         isolateRegisterBit9to11
000018DA                          1631              
000018DA                          1632              ;Save #%000 into D6 to specify data register mode
000018DA  1C3C 0000               1633              MOVE.B      #0,D6
000018DE                          1634              
000018DE                          1635              ;*Print Shift Count address*
000018DE  6100 0290               1636              BSR         addressModeSR
000018E2                          1637  
000018E2  6100 0002               1638              BSR         RegShift2
000018E6                          1639  
000018E6                          1640  
000018E6                          1641  ; Resumes printing data register shift instruction after printing AS or LS
000018E6                          1642  RegShift2   ;Print comma after shift count
000018E6  43F9 00001E61           1643              LEA         printComma,A1
000018EC  103C 000E               1644              MOVE.B      #14,D0
000018F0  4E4F                    1645              TRAP        #15
000018F2                          1646              
000018F2                          1647              ;*Data Register to be Shifted*
000018F2  4282                    1648              CLR.L       D2
000018F4                          1649              
000018F4                          1650              ;Copy the address values into a register
000018F4  3412                    1651              MOVE.W      (A2),D2
000018F6                          1652              
000018F6                          1653              ;Passing in parameters for isolating bits 0-2
000018F6  163C 0000               1654              MOVE.B      #0,D3             ;Start bit index = 0
000018FA  183C 0003               1655              MOVE.B      #3,D4             ;Number of bits needed = 3
000018FE                          1656              
000018FE                          1657              ;Jumps to getBits and returns with isolated bits in D2
000018FE  6100 F8E2               1658              BSR         getBits
00001902                          1659              
00001902                          1660              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001902  1E02                    1661              MOVE.B      D2,D7
00001904                          1662              
00001904                          1663              ;Save #%000 into D6 to specify data register mode
00001904  1C3C 0000               1664              MOVE.B      #0,D6
00001908                          1665              
00001908                          1666              ;*Prints data register to be shifted*
00001908  6100 0266               1667              BSR         addressModeSR
0000190C                          1668  
0000190C  6000 F8BE               1669              BRA         update
00001910                          1670  
00001910                          1671  ;Subroutine to enter if amount to shift is an immediate address            
00001910                          1672  ImmediateCount
00001910                          1673              ;Print #$
00001910  43F9 00001E51           1674              LEA        printIA,A1
00001916  103C 000E               1675              MOVE.B     #14,D0
0000191A  4E4F                    1676              TRAP       #15
0000191C                          1677              
0000191C                          1678              ;*Data Register to be Shifted*
0000191C  4282                    1679              CLR.L       D2
0000191E                          1680              
0000191E                          1681              ;Copy the address values into a register
0000191E  3412                    1682              MOVE.W     (A2),D2
00001920                          1683              
00001920                          1684              ;Passing in parameters for isolating bits 9-11
00001920  163C 0009               1685              MOVE.B      #9,D3             ;Start bit index = 9
00001924  183C 0003               1686              MOVE.B      #3,D4             ;Number of bits needed = 3
00001928                          1687              
00001928                          1688              ;Jumps to getBits and returns with isolated bits in D2
00001928  6100 F8B8               1689              BSR         getBits  
0000192C                          1690              
0000192C                          1691              ;Check if shift count is 8
0000192C  B43C 0000               1692              CMP.B       #%000,D2
00001930  6700 0010               1693              BEQ         ShiftEight
00001934                          1694              
00001934  2202                    1695              MOVE.L      D2, D1
00001936  6100 0002               1696              BSR         ImmediateCount2
0000193A                          1697  ;Subroutine to print shift count           
0000193A                          1698  ImmediateCount2
0000193A                          1699              ;Print shift count
0000193A  103C 0003               1700              MOVE.B      #3,D0
0000193E  4E4F                    1701              TRAP        #15
00001940  61A4                    1702              BSR         RegShift2
00001942                          1703  ;Subroutine to enter if shift count is 8
00001942                          1704  ShiftEight  ;Move 8 into D1    
00001942  123C 0008               1705              MOVE.B      #8, D1
00001946  61F2                    1706              BSR         ImmediateCount2
00001948                          1707              
00001948                          1708  ; Subroutine to enter when the instruction is given a memory address to shift                         
00001948                          1709  MemShift
00001948                          1710              ;Copy the address values into a register
00001948  3412                    1711              MOVE.W     (A2),D2
0000194A                          1712              
0000194A                          1713              ;Passing in parameters for isolating bit 9
0000194A  163C 0009               1714              MOVE.B      #9,D3             ;Start bit index = 9
0000194E  183C 0001               1715              MOVE.B      #1,D4             ;Number of bits needed = 1
00001952                          1716              
00001952                          1717              ;Jumps to getBits and returns with isolated bits in D2
00001952  6100 F88E               1718              BSR         getBits  
00001956                          1719              
00001956                          1720              ;Checks if ASd
00001956  B43C 0000               1721              CMP.B       #%0,D2
0000195A  6700 0022               1722              BEQ         MemAS
0000195E                          1723              
0000195E                          1724              ;Checks if LSd
0000195E  B43C 0001               1725              CMP.B       #%1,D2
00001962  6700 0022               1726              BEQ         MemLS
00001966                          1727              
00001966                          1728  ; Continues memory address shift after printing AS or LS
00001966                          1729  MemShift2   
00001966                          1730              ;Print Space
00001966  43F9 00001E63           1731              LEA        printSpace,A1
0000196C  103C 000E               1732              MOVE.B     #14,D0
00001970  4E4F                    1733              TRAP       #15
00001972                          1734              
00001972                          1735              ;*Memory Address*
00001972                          1736              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001972                          1737              ;D6 will contain mode & D7 will contain the register after this instruction
00001972  6100 014C               1738              BSR         isolateAddressBit0to5
00001976                          1739              
00001976                          1740              ;*Print source address*
00001976  6100 01F8               1741              BSR         addressModeSR
0000197A                          1742              
0000197A  6000 F850               1743              BRA         update
0000197E                          1744  
0000197E                          1745  MemAS       ;Print AS
0000197E  6100 002C               1746              BSR         MAS      
00001982  6100 0036               1747              BSR         MemDirectionSubroutine                
00001986                          1748  
00001986                          1749              
00001986                          1750  MemLS       ;Print LS
00001986  6100 0016               1751              BSR         MLS      
0000198A  6100 002E               1752              BSR         MemDirectionSubroutine
0000198E                          1753              
0000198E                          1754  RegAS       ;Print AS
0000198E  6100 001C               1755              BSR         MAS      
00001992  6100 0062               1756              BSR         RegDirectionSubroutine                
00001996                          1757  
00001996                          1758  RegLS       ;Print LS
00001996  6100 0006               1759              BSR         MLS      
0000199A  6100 005A               1760              BSR         RegDirectionSubroutine
0000199E                          1761  
0000199E                          1762  ; Prints LS
0000199E                          1763  MLS:
0000199E  43F9 00001E2F           1764              LEA        printMLS,A1
000019A4  103C 000E               1765              MOVE.B     #14,D0
000019A8  4E4F                    1766              TRAP       #15
000019AA  4E75                    1767              RTS
000019AC                          1768  ; Prints AS
000019AC                          1769  MAS:
000019AC  43F9 00001E2C           1770              LEA        printMAS,A1
000019B2  103C 000E               1771              MOVE.B     #14,D0
000019B6  4E4F                    1772              TRAP       #15
000019B8  4E75                    1773              RTS
000019BA                          1774  
000019BA                          1775  ;Subroutine for the direction if shifting a memory address
000019BA                          1776  MemDirectionSubroutine
000019BA                          1777              ;Copy the address values into a register
000019BA  3412                    1778              MOVE.W     (A2),D2
000019BC                          1779              
000019BC                          1780              ;Passing in parameters for isolating bit 8
000019BC  163C 0008               1781              MOVE.B      #8,D3             ;Start bit index = 8
000019C0  183C 0001               1782              MOVE.B      #1,D4             ;Number of bits needed = 1
000019C4                          1783              
000019C4                          1784              ;Jumps to getBits and returns with isolated bits in D2
000019C4  6100 F81C               1785              BSR         getBits  
000019C8                          1786              
000019C8                          1787              ;Checks if Right
000019C8  B43C 0000               1788              CMP.B       #%0,D2
000019CC  6700 000A               1789              BEQ         MR
000019D0                          1790              
000019D0                          1791              ;Checks if Left
000019D0  B43C 0001               1792              CMP.B       #%1,D2
000019D4  6700 0010               1793              BEQ         ML
000019D8                          1794                          
000019D8  43F9 00001E34           1795  MR          LEA        printR,A1
000019DE  103C 000E               1796              MOVE.B     #14,D0
000019E2  4E4F                    1797              TRAP       #15
000019E4  6180                    1798              BSR        MemShift2
000019E6                          1799  
000019E6  43F9 00001E32           1800  ML          LEA        printL,A1
000019EC  103C 000E               1801              MOVE.B     #14,D0
000019F0  4E4F                    1802              TRAP       #15
000019F2  6100 FF72               1803              BSR        MemShift2
000019F6                          1804  
000019F6                          1805  ;Subroutine for the direction if shifting a data register        
000019F6                          1806  RegDirectionSubroutine
000019F6                          1807              ;Copy the address values into a register
000019F6  3412                    1808              MOVE.W     (A2),D2
000019F8                          1809              
000019F8                          1810              ;Passing in parameters for isolating bit 8
000019F8  163C 0008               1811              MOVE.B      #8,D3             ;Start bit index = 8
000019FC  183C 0001               1812              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A00                          1813              
00001A00                          1814              ;Jumps to getBits and returns with isolated bits in D2
00001A00  6100 F7E0               1815              BSR         getBits  
00001A04                          1816              
00001A04                          1817              ;Checks if Right
00001A04  B43C 0000               1818              CMP.B       #%0,D2
00001A08  6700 000A               1819              BEQ         RR
00001A0C                          1820              
00001A0C                          1821              ;Checks if Left
00001A0C  B43C 0001               1822              CMP.B       #%1,D2
00001A10  6700 0012               1823              BEQ         RL
00001A14                          1824                          
00001A14  43F9 00001E34           1825  RR          LEA        printR,A1
00001A1A  103C 000E               1826              MOVE.B     #14,D0
00001A1E  4E4F                    1827              TRAP       #15
00001A20  6100 FE8C               1828              BSR        RegShift
00001A24                          1829  
00001A24  43F9 00001E32           1830  RL          LEA        printL,A1
00001A2A  103C 000E               1831              MOVE.B     #14,D0
00001A2E  4E4F                    1832              TRAP       #15
00001A30  6100 FE7C               1833              BSR        RegShift
00001A34                          1834  
00001A34                          1835  
00001A34                          1836  *-----------------------------------------------------------------------
00001A34                          1837  *-----------------------------------------------------------------------
00001A34                          1838  *-----------------------------------------------------------------------
00001A34                          1839  
00001A34                          1840  
00001A34                          1841  ;ADD
00001A34                          1842  M1101:
00001A34  43F9 00001DCF           1843              LEA        printADD,A1
00001A3A  103C 000E               1844              MOVE.B     #14,D0
00001A3E  4E4F                    1845              TRAP       #15
00001A40                          1846              
00001A40  4202                    1847              CLR.B      D2
00001A42  4203                    1848              CLR.B      D3
00001A44                          1849              
00001A44                          1850              ;======Isolate Size (S) Bits=======
00001A44                          1851              ;Copy the address values into a register
00001A44  3412                    1852              MOVE.W     (A2),D2
00001A46                          1853              
00001A46                          1854              ;Passing in parameters for isolating size bits
00001A46  163C 0006               1855              MOVE.B      #6,D3             ;Start bit index = 6
00001A4A  183C 0002               1856              MOVE.B      #2,D4             ;Number of bits needed = 2
00001A4E                          1857              
00001A4E                          1858              ;Jumps to getBits and returns with isolated bits in D2
00001A4E  6100 F792               1859              BSR         getBits  
00001A52                          1860              
00001A52                          1861              ;Jumps to printSizeSubroutine and returns after size has been printed
00001A52  6100 00AA               1862              BSR         printSizeSubroutine
00001A56                          1863         
00001A56                          1864              ;Let's store the size indicator since it will help us determine how many times
00001A56                          1865              ;we have to iterate through addresses to print out the whole instruction
00001A56                          1866              ;We will use A4 as the register to temporary store the size
00001A56  3842                    1867              MOVE.W      D2,A4
00001A58  11C2 2000               1868              MOVE.B      D2,$2000
00001A5C                          1869              
00001A5C                          1870              ;======Isolate direction (D) Bit=======
00001A5C                          1871              ; 0 = data register is destination | 1 = Dn is source
00001A5C  4282                    1872              CLR.L       D2
00001A5E                          1873              
00001A5E                          1874              ;Copy the address values into a register
00001A5E  3412                    1875              MOVE.W      (A2),D2
00001A60                          1876              
00001A60                          1877              ;Passing in parameters for isolating direction bit
00001A60  163C 0008               1878              MOVE.B      #8,D3             ;Start bit index = 8
00001A64  183C 0001               1879              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A68                          1880              
00001A68                          1881              ;Jumps to getBits and returns with isolated bit in D2
00001A68  6100 F778               1882              BSR         getBits
00001A6C                          1883              
00001A6C                          1884              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001A6C  B43C 0000               1885              CMP.B       #0,D2
00001A70  6700 0006               1886              BEQ         dnDest
00001A74  6000 0026               1887              BRA         dnSource
00001A78                          1888              
00001A78                          1889  
00001A78                          1890  *-----------------------------------------------------------------
00001A78                          1891  * dnDest, dnSource, & other subroutines for isolating address bits
00001A78                          1892  *-----------------------------------------------------------------
00001A78                          1893  ;* dnDest,dnSource *
00001A78                          1894  ;For: MULS,AND,ADD,SUB,DIVU
00001A78                          1895  ;Used by instructions that require Dn as one of their addressing modes.
00001A78                          1896  ;dnDest isolates the addressing bits with Dn being the destination address
00001A78                          1897  ;dnSource isolates the addressing bits with Dn being the source address
00001A78                          1898  
00001A78                          1899  dnDest:
00001A78                          1900              ;**Used for isolating addressing bits when Dn is the destination**
00001A78                          1901              
00001A78                          1902              ;*SOURCE*
00001A78                          1903              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001A78                          1904              ;D6 will contain mode & D7 will contain the register after this instruction
00001A78  6100 0046               1905              BSR         isolateAddressBit0to5
00001A7C                          1906              
00001A7C                          1907              ;*Print source address*
00001A7C  6100 00F2               1908              BSR         addressModeSR
00001A80                          1909              
00001A80                          1910              ;Print comma after source address
00001A80  43F9 00001E61           1911              LEA         printComma,A1
00001A86  103C 000E               1912              MOVE.B      #14,D0
00001A8A  4E4F                    1913              TRAP        #15
00001A8C                          1914              
00001A8C                          1915              ;*DESTINATION*
00001A8C                          1916              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001A8C                          1917              ;D7 will contain the register after this instruction
00001A8C  6100 0058               1918              BSR         isolateRegisterBit9to11
00001A90                          1919              
00001A90                          1920              ;Save #%000 into D6 to specify data register mode
00001A90  1C3C 0000               1921              MOVE.B      #0,D6
00001A94                          1922              
00001A94                          1923              ;*Print destination address*
00001A94  6100 00DA               1924              BSR         addressModeSR
00001A98                          1925  
00001A98  6000 F732               1926              BRA         update
00001A9C                          1927              
00001A9C                          1928  dnSource:
00001A9C                          1929              ;**Used for isolating addressing bits when Dn is the destination**
00001A9C                          1930                          
00001A9C                          1931              ;*SOURCE*
00001A9C                          1932              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001A9C                          1933              ;D7 will contain the register after this instruction
00001A9C  6100 0048               1934              BSR         isolateRegisterBit9to11
00001AA0                          1935              
00001AA0                          1936              ;Save #%000 into D6 to specify data register mode
00001AA0  1C3C 0000               1937              MOVE.B      #0,D6
00001AA4                          1938              
00001AA4                          1939              ;*Print Source address*
00001AA4  6100 00CA               1940              BSR         addressModeSR
00001AA8                          1941              
00001AA8                          1942              ;Print comma after source address
00001AA8  43F9 00001E61           1943              LEA         printComma,A1
00001AAE  103C 000E               1944              MOVE.B      #14,D0
00001AB2  4E4F                    1945              TRAP        #15
00001AB4                          1946              
00001AB4                          1947              ;*DESTINATION*
00001AB4                          1948              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001AB4                          1949              ;D6 will contain mode & D7 will contain the register after this instruction
00001AB4  6100 000A               1950              BSR         isolateAddressBit0to5
00001AB8                          1951              
00001AB8                          1952              ;*Print destination address*
00001AB8  6100 00B6               1953              BSR         addressModeSR
00001ABC                          1954  
00001ABC  6000 F70E               1955              BRA         update
00001AC0                          1956                     
00001AC0                          1957  isolateAddressBit0to5:
00001AC0                          1958  ;Helper subroutine for isolating the address stored within bits 0-5
00001AC0                          1959  ;Stores address mode in D6
00001AC0                          1960  ;Stores address register in D7
00001AC0                          1961  
00001AC0                          1962              ;======Isolate Effective Address Mode (M) Bits=======
00001AC0  4282                    1963              CLR.L       D2
00001AC2                          1964              
00001AC2                          1965              ;Copy the address values into a register
00001AC2  3412                    1966              MOVE.W      (A2),D2
00001AC4                          1967              
00001AC4                          1968              ;Passing in parameters for isolating Mode bits
00001AC4  163C 0003               1969              MOVE.B      #3,D3             ;Start bit index = 3
00001AC8  183C 0003               1970              MOVE.B      #3,D4             ;Number of bits needed = 3
00001ACC                          1971              
00001ACC                          1972              ;Jumps to getBits and returns with isolated bits in D2
00001ACC  4EB8 11E2               1973              JSR         getBits
00001AD0                          1974              
00001AD0                          1975              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001AD0  1C02                    1976              MOVE.B      D2,D6
00001AD2                          1977              
00001AD2                          1978                       
00001AD2                          1979              ;======Isolate Effective Address Register (Xn) Bits=======
00001AD2  4282                    1980              CLR.L       D2
00001AD4                          1981              
00001AD4                          1982              ;Copy the address values into a register
00001AD4  3412                    1983              MOVE.W      (A2),D2
00001AD6                          1984              
00001AD6                          1985              ;Passing in parameters for isolating Xn bits
00001AD6  163C 0000               1986              MOVE.B      #0,D3             ;Start bit index = 0
00001ADA  183C 0003               1987              MOVE.B      #3,D4             ;Number of bits needed = 3
00001ADE                          1988              
00001ADE                          1989              ;Jumps to getBits and returns with isolated bits in D2
00001ADE  6100 F702               1990              BSR         getBits
00001AE2                          1991              
00001AE2                          1992              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001AE2  1E02                    1993              MOVE.B      D2,D7
00001AE4                          1994              
00001AE4  4E75                    1995              RTS
00001AE6                          1996  
00001AE6                          1997  isolateRegisterBit9to11:
00001AE6                          1998  ;Helper subroutine for isolating the register stored within bits 9-11
00001AE6                          1999  ;Stores the address register in D7
00001AE6                          2000  
00001AE6                          2001              ;======Isolate Register Bits=======
00001AE6  4282                    2002              CLR.L       D2
00001AE8  4286                    2003              CLR.L       D6
00001AEA  4287                    2004              CLR.L       D7
00001AEC                          2005              
00001AEC                          2006              ;Copy the address values into a register
00001AEC  3412                    2007              MOVE.W      (A2),D2
00001AEE                          2008              
00001AEE                          2009              ;Passing in parameters for isolating register bits
00001AEE  163C 0009               2010              MOVE.B      #9,D3             ;Start bit index = 9
00001AF2  183C 0003               2011              MOVE.B      #3,D4             ;Number of bits needed = 3
00001AF6                          2012              
00001AF6                          2013              ;Jumps to getBits and returns with isolated bit in D2
00001AF6  6100 F6EA               2014              BSR         getBits
00001AFA                          2015              
00001AFA                          2016              ;Save register bit into ***D7*** for later use in addressModeSR
00001AFA  1E02                    2017              MOVE.B      D2,D7
00001AFC                          2018  
00001AFC  4E75                    2019              RTS
00001AFE                          2020              
00001AFE                          2021  *-----------------------------------------------------------
00001AFE                          2022  * Print Sizes
00001AFE                          2023  *-----------------------------------------------------------
00001AFE                          2024  printSizeSubroutine:
00001AFE                          2025              ;Prints the apporpriate size
00001AFE                          2026              ;PARAMETER:
00001AFE                          2027              ;D2 = the size bits
00001AFE                          2028              
00001AFE                          2029              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
00001AFE  B63C 0001               2030              CMP.B      #1,D3
00001B02  6700 001A               2031              BEQ        printMOVESize
00001B06                          2032              
00001B06                          2033              ;Compare to which size is being moved for the opcode
00001B06  B43C 0000               2034              CMP.B      #%00,D2
00001B0A  6700 003A               2035              BEQ        PByte
00001B0E                          2036              
00001B0E  B43C 0001               2037              CMP.B      #%01,D2
00001B12  6700 0040               2038              BEQ        PWord
00001B16                          2039              
00001B16  B43C 0002               2040              CMP.B      #%10,D2
00001B1A  6700 0046               2041              BEQ        PLong
00001B1E                          2042           
00001B1E                          2043  printMOVESize:
00001B1E                          2044              ;Now that we know we have a MOVE opcode
00001B1E                          2045              ;Compare to which size is being moved for the opcode
00001B1E  B43C 0001               2046              CMP.B      #%01,D2
00001B22  6700 0022               2047              BEQ        PByte
00001B26                          2048  
00001B26  B43C 0003               2049              CMP.B      #%11,D2
00001B2A  6700 0028               2050              BEQ        PWord            
00001B2E                          2051    
00001B2E  B43C 0002               2052              CMP.B      #%10,D2
00001B32  6700 002E               2053              BEQ        PLong
00001B36                          2054              
00001B36                          2055  printMOVEMSize:
00001B36                          2056              ;Now that we know we have a MOVEM opcode
00001B36                          2057              ;Compare to which size is being moved for the opcode
00001B36  B43C 0000               2058              CMP.B      #%0,D2
00001B3A  6700 0018               2059              BEQ        PWord
00001B3E                          2060              
00001B3E  B43C 0001               2061              CMP.B      #%1,D2
00001B42  6700 001E               2062              BEQ        PLong
00001B46                          2063  
00001B46                          2064  PByte:
00001B46  43F9 00001E36           2065              LEA        printSIZEB,A1
00001B4C  103C 000E               2066              MOVE.B     #14,D0
00001B50  4E4F                    2067              TRAP       #15
00001B52                          2068              
00001B52  4E75                    2069              RTS
00001B54                          2070  PWord:
00001B54  43F9 00001E3A           2071              LEA        printSIZEW,A1
00001B5A  103C 000E               2072              MOVE.B     #14,D0
00001B5E  4E4F                    2073              TRAP       #15
00001B60                          2074              
00001B60  4E75                    2075              RTS
00001B62                          2076  PLong:            
00001B62  43F9 00001E40           2077              LEA        printSIZEL,A1
00001B68  103C 000E               2078              MOVE.B     #14,D0
00001B6C  4E4F                    2079              TRAP       #15
00001B6E                          2080              
00001B6E  4E75                    2081              RTS
00001B70                          2082              
00001B70                          2083  *-----------------------------------------------------------
00001B70                          2084  * Addressing Mode Implementation
00001B70                          2085  *-----------------------------------------------------------
00001B70                          2086  addressModeSR:
00001B70                          2087              ;Prints address according to the parameters passed in
00001B70                          2088              ;PARAMETERS:
00001B70                          2089              ;D6 = mode
00001B70                          2090              ;D7 = register
00001B70                          2091  
00001B70                          2092              ;Data register direct
00001B70  BC3C 0000               2093              CMP.B       #%000,D6
00001B74  6700 002A               2094              BEQ         DRD
00001B78                          2095              
00001B78                          2096              ;Address register direct
00001B78  BC3C 0001               2097              CMP.B       #%001,D6
00001B7C  6700 0036               2098              BEQ         ARD
00001B80                          2099              
00001B80                          2100              ;Address register indirect
00001B80  BC3C 0002               2101              CMP.B       #%010,D6
00001B84  6700 0042               2102              BEQ         ARI
00001B88                          2103              
00001B88                          2104              ;Post Increment
00001B88  BC3C 0003               2105              CMP.B       #%011,D6
00001B8C  6700 005A               2106              BEQ         PI
00001B90                          2107              
00001B90                          2108              ;Pre Decrement
00001B90  BC3C 0004               2109              CMP.B       #%100,D6
00001B94  6700 0072               2110              BEQ         PD
00001B98                          2111              
00001B98                          2112              ;Immediate/Absolute Addressing
00001B98  BC3C 0007               2113              CMP.B       #%111,D6
00001B9C  6700 008A               2114              BEQ         otherModes
00001BA0                          2115  DRD:
00001BA0                          2116              ;Print D __
00001BA0  43F9 00001E48           2117              LEA         printDRD,A1
00001BA6  103C 000E               2118              MOVE.B      #14,D0
00001BAA  4E4F                    2119              TRAP        #15
00001BAC                          2120              
00001BAC                          2121              ;Print register number
00001BAC  7003                    2122              MOVE.L      #3,D0
00001BAE  2207                    2123              MOVE.L      D7,D1
00001BB0  4E4F                    2124              TRAP        #15
00001BB2                          2125              
00001BB2  4E75                    2126              RTS
00001BB4                          2127  ARD:
00001BB4                          2128              ;Print A __
00001BB4  43F9 00001E4A           2129              LEA         printARD,A1
00001BBA  103C 000E               2130              MOVE.B      #14,D0
00001BBE  4E4F                    2131              TRAP        #15
00001BC0                          2132              
00001BC0                          2133              ;Print register number
00001BC0  7003                    2134              MOVE.L      #3,D0
00001BC2  2207                    2135              MOVE.L      D7,D1
00001BC4  4E4F                    2136              TRAP        #15
00001BC6                          2137              
00001BC6  4E75                    2138              RTS
00001BC8                          2139  ARI:
00001BC8                          2140              ;Print (A __ )
00001BC8  43F9 00001E4C           2141              LEA         printARI,A1
00001BCE  103C 000E               2142              MOVE.B      #14,D0
00001BD2  4E4F                    2143              TRAP        #15
00001BD4                          2144              
00001BD4                          2145              ;Print register number
00001BD4  7003                    2146              MOVE.L      #3,D0
00001BD6  2207                    2147              MOVE.L      D7,D1
00001BD8  4E4F                    2148              TRAP        #15
00001BDA                          2149              
00001BDA                          2150              ;Print closing ')'
00001BDA  43F9 00001E4F           2151              LEA         printARI2,A1
00001BE0  103C 000E               2152              MOVE.B      #14,D0
00001BE4  4E4F                    2153              TRAP        #15
00001BE6                          2154              
00001BE6  4E75                    2155              RTS
00001BE8                          2156  PI:
00001BE8                          2157              ;Print (A __)+
00001BE8  43F9 00001E55           2158              LEA         printPI,A1
00001BEE  103C 000E               2159              MOVE.B      #14,D0
00001BF2  4E4F                    2160              TRAP        #15
00001BF4                          2161              
00001BF4                          2162              ;Print register number
00001BF4  7003                    2163              MOVE.L      #3,D0
00001BF6  2207                    2164              MOVE.L      D7,D1
00001BF8  4E4F                    2165              TRAP        #15
00001BFA                          2166              
00001BFA                          2167              ;Print closing ')+'
00001BFA  43F9 00001E58           2168              LEA         printPI2,A1
00001C00  103C 000E               2169              MOVE.B      #14,D0
00001C04  4E4F                    2170              TRAP        #15
00001C06                          2171              
00001C06  4E75                    2172              RTS
00001C08                          2173  PD:
00001C08                          2174              ;Print -(A __)
00001C08  43F9 00001E5B           2175              LEA         printPD,A1
00001C0E  103C 000E               2176              MOVE.B      #14,D0
00001C12  4E4F                    2177              TRAP        #15
00001C14                          2178              
00001C14                          2179              ;Print register number
00001C14  7003                    2180              MOVE.L      #3,D0
00001C16  2207                    2181              MOVE.L      D7,D1
00001C18  4E4F                    2182              TRAP        #15
00001C1A                          2183              
00001C1A                          2184              ;Print closing ')'
00001C1A  43F9 00001E5F           2185              LEA         printPD2,A1
00001C20  103C 000E               2186              MOVE.B      #14,D0
00001C24  4E4F                    2187              TRAP        #15
00001C26                          2188              
00001C26  4E75                    2189              RTS
00001C28                          2190  
00001C28                          2191  otherModes:
00001C28  B4CE                    2192              CMP.W       A6,A2
00001C2A                          2193              
00001C2A  6D00 0004               2194              BLT         SKIPCOPY  
00001C2E                          2195  
00001C2E                          2196               *=====Important step for making sure we have access to where A2 orignally points=====*
00001C2E  2C4A                    2197              MOVEA.L     A2,A6 
00001C30                          2198  
00001C30                          2199  
00001C30                          2200  SKIPCOPY:            
00001C30                          2201              
00001C30                          2202              ;Branch to Immediate if register bits are %100       
00001C30  BE3C 0004               2203              CMP.B       #%100,D7
00001C34  6700 0006               2204              BEQ         Immediate
00001C38                          2205              
00001C38                          2206              ;Otherwise, branch to Absolute
00001C38  6000 0022               2207              BRA         Absolute
00001C3C                          2208              
00001C3C                          2209          
00001C3C                          2210                     
00001C3C                          2211  Immediate:
00001C3C                          2212              ;Print #
00001C3C  43F9 00001E51           2213              LEA         printIA,A1
00001C42  103C 000E               2214              MOVE.B      #14,D0
00001C46  4E4F                    2215              TRAP        #15
00001C48                          2216              
00001C48                          2217              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001C48                          2218              ;We will be able to access the contents of either size B or W
00001C48  544A                    2219              ADDA.W      #2,A2         
00001C4A                          2220  
00001C4A                          2221              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
00001C4A  0C38 0002 2000          2222              CMP.B       #%10,$2000
00001C50  6700 0048               2223              BEQ         IMDLong
00001C54                          2224              
00001C54                          2225              ;If we don't branch, then we assume we're printing out a byte or word      
00001C54  7003                    2226              MOVE.L      #3,D0
00001C56  3212                    2227              MOVE.W      (A2),D1
00001C58  4E4F                    2228              TRAP        #15
00001C5A                          2229              
00001C5A  4E75                    2230              RTS
00001C5C                          2231              
00001C5C                          2232              
00001C5C                          2233              
00001C5C                          2234  Absolute:
00001C5C                          2235              ;Print $
00001C5C  43F9 00001E53           2236              LEA         printA,A1
00001C62  103C 000E               2237              MOVE.B      #14,D0
00001C66  4E4F                    2238              TRAP        #15
00001C68                          2239              
00001C68                          2240              ;Point to the next word (contains memory address)
00001C68  544E                    2241              ADDA.W      #2,A6
00001C6A                          2242              
00001C6A                          2243              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
00001C6A  BE3C 0001               2244              CMP.B       #%001,D7
00001C6E  6700 0012               2245              BEQ         AbsLong
00001C72                          2246              
00001C72                          2247              ;Print out the value in the address if it's a word
00001C72  4281                    2248              CLR.L       D1
00001C74                          2249              
00001C74  303C 000F               2250              MOVE.W      #15,D0
00001C78  343C 0010               2251              MOVE.W      #16,D2
00001C7C  3216                    2252              MOVE.W      (A6),D1
00001C7E  4E4F                    2253              TRAP        #15
00001C80                          2254              
00001C80  4E75                    2255              RTS
00001C82                          2256              
00001C82                          2257  AbsLong:            
00001C82                          2258              ;Place the current value into a temp register
00001C82  3816                    2259              MOVE.W      (A6),D4
00001C84                          2260              
00001C84                          2261              ;Shift the bits so we can enter the rest of the values
00001C84  1E3C 0010               2262              MOVE.B      #16,D7
00001C88  EFAC                    2263              LSL.L       D7,D4
00001C8A                          2264              
00001C8A                          2265              ;Increment A6 to account for the next values in the instruction
00001C8A  544E                    2266              ADDA.W      #2,A6
00001C8C                          2267              
00001C8C                          2268              ;Move the rest of the machine code into our register
00001C8C                          2269              ;This register should have the whole long values
00001C8C  3816                    2270              MOVE.W      (A6),D4
00001C8E                          2271              
00001C8E                          2272              ;Print the Long address
00001C8E  4281                    2273              CLR.L       D1
00001C90                          2274              
00001C90  700F                    2275              MOVE.L      #15,D0
00001C92  7410                    2276              MOVE.L      #16,D2
00001C94  2204                    2277              MOVE.L      D4,D1
00001C96  4E4F                    2278              TRAP        #15
00001C98                          2279              
00001C98  4E75                    2280              RTS    
00001C9A                          2281          
00001C9A                          2282  IMDLong:
00001C9A                          2283              *********USED FOR IMMEDIATE LONGS ONLY***************
00001C9A                          2284              
00001C9A                          2285              ;Place the current value into a temp register
00001C9A  3812                    2286              MOVE.W      (A2),D4
00001C9C                          2287              
00001C9C                          2288              ;Shift the bits so we can enter the rest of the values
00001C9C  1E3C 0010               2289              MOVE.B      #16,D7
00001CA0  EFAC                    2290              LSL.L       D7,D4
00001CA2                          2291              
00001CA2                          2292              ;Increment A2 to account for the next values in the machine code
00001CA2  544A                    2293              ADDA.W      #2,A2
00001CA4                          2294              
00001CA4                          2295              ;Move the rest of the machine code into our register
00001CA4                          2296              ;This register should have the whole long values
00001CA4  3812                    2297              MOVE.W      (A2),D4
00001CA6                          2298              
00001CA6                          2299              ;Print out the value in the address
00001CA6  7003                    2300              MOVE.L      #3,D0
00001CA8  2204                    2301              MOVE.L      D4,D1
00001CAA  4E4F                    2302              TRAP        #15
00001CAC                          2303              
00001CAC  4E75                    2304              RTS
00001CAE                          2305  
00001CAE                          2306  
00001CAE                          2307  *-----------------------------------------------------------
00001CAE                          2308  * Print Instructions for NOP and RTS
00001CAE                          2309  *-----------------------------------------------------------
00001CAE                          2310  printMNOP:
00001CAE  43F9 00001DC0           2311              LEA        printNOP,A1
00001CB4  103C 000E               2312              MOVE.B     #14,D0
00001CB8  4E4F                    2313              TRAP       #15
00001CBA                          2314              
00001CBA  6000 F510               2315              BRA        update
00001CBE                          2316  
00001CBE                          2317  printMRTS:
00001CBE  43F9 00001E24           2318              LEA        printRTS,A1
00001CC4  103C 000E               2319              MOVE.B     #14,D0
00001CC8  4E4F                    2320              TRAP       #15
00001CCA                          2321              
00001CCA  6000 F500               2322              BRA        update
00001CCE                          2323  ;-----------------------------------------------------------
00001CCE                          2324  ;ERROR MESSAGES FOR I/O portion
00001CCE                          2325  ;-----------------------------------------------------------
00001CCE                          2326  charError:
00001CCE                          2327              
00001CCE  43F9 00001E8A           2328              LEA         invalCh,A1
00001CD4  103C 000E               2329              MOVE.B      #14,D0
00001CD8  4E4F                    2330              TRAP        #15
00001CDA                          2331              
00001CDA  6000 F340               2332              BRA         startingPrompt
00001CDE                          2333            
00001CDE                          2334  oddError:
00001CDE  43F9 00001EAB           2335              LEA         odd,A1
00001CE4  103C 000E               2336              MOVE.B      #14,D0
00001CE8  4E4F                    2337              TRAP        #15
00001CEA                          2338              
00001CEA  6000 F330               2339              BRA         startingPrompt
00001CEE                          2340              
00001CEE                          2341  manyCharError:  
00001CEE  43F9 00001ED8           2342              LEA         manyChar, A1
00001CF4  103C 000E               2343              MOVE.B      #14,D0
00001CF8  4E4F                    2344              TRAP        #15
00001CFA                          2345              
00001CFA  6000 F320               2346              BRA         startingPrompt
00001CFE                          2347           
00001CFE                          2348  endGreater:
00001CFE  43F9 00001F13           2349              LEA         endG,A1
00001D04  103C 000E               2350              MOVE.B      #14,D0
00001D08  4E4F                    2351              TRAP        #15
00001D0A                          2352              
00001D0A  6000 F310               2353              BRA         startingPrompt
00001D0E                          2354         
00001D0E                          2355  ;-----------------------------------------------------------
00001D0E                          2356  ;MESSAGES
00001D0E                          2357  ;-----------------------------------------------------------
00001D0E= 57 65 6C 63 6F 6D ...   2358  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001D32= 50 6C 65 61 73 65 ...   2359  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001D74= 50 6C 65 61 73 65 ...   2360  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001DB4= 0D 0A 41 64 64 72 ...   2361  AddressNum  DC.B        CR,LF,'Address: ',0
00001DC0                          2362  
00001DC0                          2363  ;-----------------------------------------------------------
00001DC0                          2364  ;OPCODE Messages
00001DC0                          2365  ;-----------------------------------------------------------
00001DC0= 4E 4F 50 00             2366  printNOP    DC.B        'NOP',0
00001DC4= 4D 4F 56 45 00          2367  printMOVE   DC.B        'MOVE',0
00001DC9= 4D 4F 56 45 4D 00       2368  printMOVEM  DC.B        'MOVEM',0
00001DCF= 41 44 44 00             2369  printADD    DC.B        'ADD',0
00001DD3= 41 44 44 49 00          2370  printADDI   DC.B        'ADDI',0
00001DD8= 53 55 42 00             2371  printSUB    DC.B        'SUB',0
00001DDC= 53 55 42 49 00          2372  printSUBI   DC.B        'SUBI',0
00001DE1= 4D 55 4C 53 2E 57 ...   2373  printMULS   DC.B        'MULS.W ',0
00001DE9= 44 49 56 55 2E 57 ...   2374  printDIVU   DC.B        'DIVU.W ',0
00001DF1= 4C 45 41 20 00          2375  printLEA    DC.B        'LEA ',0
00001DF6= 41 4E 44 00             2376  printAND    DC.B        'AND',0
00001DFA= 4E 4F 54 00             2377  printNOT    DC.B        'NOT',0
00001DFE= 4C 53 4C 00             2378  printLSL    DC.B        'LSL',0
00001E02= 4C 53 52 00             2379  printLSR    DC.B        'LSR',0
00001E06= 41 53 4C 00             2380  printASL    DC.B        'ASL',0
00001E0A= 41 53 52 00             2381  printASR    DC.B        'ASR',0
00001E0E= 42 4C 54 00             2382  printBLT    DC.B        'BLT',0
00001E12= 42 47 45 00             2383  printBGE    DC.B        'BGE',0
00001E16= 42 45 51 00             2384  printBEQ    DC.B        'BEQ',0
00001E1A= 42 43 43 20 00          2385  printBCC    DC.B        'BCC ',0
00001E1F= 4A 53 52 20 00          2386  printJSR    DC.B        'JSR ',0
00001E24= 52 54 53 00             2387  printRTS    DC.B        'RTS',0
00001E28= 42 52 41 00             2388  printBRA    DC.B        'BRA',0
00001E2C= 41 53 00                2389  printMAS    DC.B        'AS',0
00001E2F= 4C 53 00                2390  printMLS    DC.B        'LS',0
00001E32= 4C 00                   2391  printL      DC.B        'L',0    
00001E34= 52 00                   2392  printR      DC.B        'R',0
00001E36                          2393  ;-----------------------------------------------------------
00001E36                          2394  ;Size Messages
00001E36                          2395  ;-----------------------------------------------------------
00001E36= 2E 42 20 00             2396  printSIZEB  DC.B        '.B ',0
00001E3A= 2E57 2000 0000          2397  printSIZEW  DC.W        '.W ',0
00001E40= 2E4C2000 00000000       2398  printSIZEL  DC.L        '.L ',0
00001E48                          2399  
00001E48                          2400  ;-----------------------------------------------------------
00001E48                          2401  ;Addressing Mode Messages
00001E48                          2402  ;-----------------------------------------------------------
00001E48= 44 00                   2403  printDRD      DC.B        'D',0
00001E4A= 41 00                   2404  printARD      DC.B        'A',0
00001E4C= 28 41 00                2405  printARI      DC.B        '(A',0
00001E4F= 29 00                   2406  printARI2     DC.B        ')',0
00001E51= 23 00                   2407  printIA       DC.B        '#',0
00001E53= 24 00                   2408  printA        DC.B        '$',0
00001E55= 28 41 00                2409  printPI       DC.B        '(A',0
00001E58= 29 2B 00                2410  printPI2      DC.B        ')+',0
00001E5B= 2D 28 41 00             2411  printPD       DC.B        '-(A',0
00001E5F= 29 00                   2412  printPD2      DC.B        ')',0
00001E61                          2413  
00001E61= 2C 00                   2414  printComma    DC.B        ',',0
00001E63= 20 00                   2415  printSpace    DC.B        ' ',0
00001E65= 2F 00                   2416  printSlash    DC.B        '/',0
00001E67= 2D 00                   2417  printDash     DC.B        '-',0
00001E69                          2418  
00001E69= 0D 0A 59 6F 75 20 ...   2419  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001E8A                          2420  
00001E8A                          2421  ;-----------------------------------------------------------
00001E8A                          2422  ;ERRORS
00001E8A                          2423  ;-----------------------------------------------------------
00001E8A= 45 52 52 4F 52 3A ...   2424  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001EAB= 45 52 52 4F 52 3A ...   2425  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001ED8= 45 52 52 4F 52 3A ...   2426  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001F13= 45 52 52 4F 52 3A ...   2427  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00001F58= 45 52 52 4F 52 3A ...   2428  sizeError   DC.B        'ERROR: Invalid size instruction',0
00001F78= 45 52 52 4F 52 3A ...   2429  invalOpcode DC.B        'ERROR: INVALID OPCODE = ',0
00001F91                          2430  
00001F92  4283                    2431              CLR.L       D3     
00001F94                          2432  
00001F94                          2433  ;-----------------------------------------------------------
00001F94                          2434  ;Ending function that ends our program 
00001F94                          2435  ;-----------------------------------------------------------
00001F94                          2436  ending:
00001F94  43F8 1E69               2437              LEA         theEnd,A1
00001F98  303C 000E               2438              MOVE        #14,D0
00001F9C  4E4F                    2439              TRAP        #15
00001F9E                          2440              
00001F9E                          2441              END         MAIN  

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1C82
ABSOLUTE            1C5C
ABSOLUTEADDRESSMOVEM  148A
ADD16BITS           1722
ADD32BITS           1764
ADD8BITS            16E0
ADDRESSMODESR       1B70
ADDRESSNUM          1DB4
ARD                 1BB4
ARI                 1BC8
BCCOFFSET           16B0
BIT16DISPLACEMENT   170E
BIT32DISPLACEMENT   1750
BIT8DISPLACEMENT    16D2
BITLOOP             1500
CHARERROR           1CCE
CHECK               148E
CONTINUE16BITS      1732
CONTINUE32BITS      1774
CONTINUE8BITS       16F0
CONTINUEDIVU        17AE
CONVERT             1070
COUNTER             1008
CR                  D
CURADD              100C
DNDEST              1A78
DNSOURCE            1A9C
DORA                100A
DRD                 1BA0
ENDG                1F13
ENDGREATER          1CFE
ENDHEX              1004
ENDING              1F94
ENDINGPROMPT        1048
FINDLIST            14B2
FINDLIST2           14D4
GETBITS             11E2
IMDLONG             1C9A
IMMEDIATE           1C3C
IMMEDIATECOUNT      1910
IMMEDIATECOUNT2     193A
INVALCH             1E8A
INVALOPCODE         1F78
ISOADDBIT0TO5       12A6
ISOLATEADDRESSBIT0TO5  1AC0
ISOLATEADDRESSBIT6TO11  1324
ISOLATEREGISTERBIT9TO11  1AE6
LETTER              1094
LF                  A
LISTTOMEM           1404
LISTTOMEM2          141C
LOOP                1124
M00                 12CC
M0000               11F8
M0100               134A
M0110               1616
M1000               1792
M1001               17BE
M1100               1802
M1101               1A34
M1110               1876
MADDI               1218
MAIN                1000
MAND                1846
MANYCHAR            1ED8
MANYCHARERROR       1CEE
MAS                 19AC
MBCC                1670
MBEQ                16A0
MBGE                1690
MBLT                1680
MBRA                1660
MEFFECT             1284
MEMAS               197E
MEMDIRECTIONSUBROUTINE  19BA
MEMLS               1986
MEMSHIFT            1948
MEMSHIFT2           1966
MEMTOLIST           144A
MJSR                15FE
ML                  19E6
MLEA                15A2
MLS                 199E
MMULS               1836
MNOT                15D2
MORECHECKS          10C4
MORECHECKS1         10D0
MORECHECKS2         10F2
MOVEM               13AC
MOVEMADD            100E
MR                  19D8
MSOURCEDEST         1302
MSUBI               124C
MULSCHECK           1820
NUMBER              10A8
ODD                 1EAB
ODDERROR            1CDE
OTHERMODES          1C28
PBYTE               1B46
PD                  1C08
PI                  1BE8
PLONG               1B62
PRINTA              1E53
PRINTADD            1DCF
PRINTADDI           1DD3
PRINTAND            1DF6
PRINTARD            1E4A
PRINTARI            1E4C
PRINTARI2           1E4F
PRINTASL            1E06
PRINTASR            1E0A
PRINTBCC            1E1A
PRINTBEQ            1E16
PRINTBGE            1E12
PRINTBLT            1E0E
PRINTBRA            1E28
PRINTCOMMA          1E61
PRINTDASH           1E67
PRINTDIVU           1DE9
PRINTDRD            1E48
PRINTIA             1E51
PRINTJSR            1E1F
PRINTL              1E32
PRINTLEA            1DF1
PRINTLSL            1DFE
PRINTLSR            1E02
PRINTMAS            1E2C
PRINTMLS            1E2F
PRINTMNOP           1CAE
PRINTMOVE           1DC4
PRINTMOVEM          1DC9
PRINTMOVEMSIZE      1B36
PRINTMOVESIZE       1B1E
PRINTMRTS           1CBE
PRINTMULS           1DE1
PRINTNOP            1DC0
PRINTNOT            1DFA
PRINTPD             1E5B
PRINTPD2            1E5F
PRINTPI             1E55
PRINTPI2            1E58
PRINTR              1E34
PRINTRTS            1E24
PRINTSINGLE         152E
PRINTSIZEB          1E36
PRINTSIZEL          1E40
PRINTSIZESUBROUTINE  1AFE
PRINTSIZEW          1E3A
PRINTSLASH          1E65
PRINTSPACE          1E63
PRINTSUB            1DD8
PRINTSUBI           1DDC
PSLASH              1594
PWORD               1B54
REGAS               198E
REGDIRECTIONSUBROUTINE  19F6
REGLS               1996
REGSHIFT            18AE
REGSHIFT2           18E6
RL                  1A24
RR                  1A14
SETA                14F6
SETD                14EC
SHIFTEIGHT          1942
SINGLEAREG          156A
SINGLEDREG          1542
SIZEERROR           1F58
SKIPA6              11D4
SKIPBIT             1522
SKIPCOPY            1C30
STAHEX              1000
STARTINGPROMPT      101C
SUB16BITS           1728
SUB32BITS           176A
SUB8BITS            16E6
THEEND              1E69
TOTALCOUNT          1009
UPDATE              11CC
USEREA              1D74
USERSA              1D32
WELCOME             1D0E
