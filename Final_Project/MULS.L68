00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/4/2021 9:00:05 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  
00001008                            15  ;Used for MOVEM
00001008= 00                        16  counter:    DC.B        $0
00001009= 00                        17  totalCount: DC.B        $0
0000100A= 00                        18  dORa:       DC.B        $0
0000100C= 0000                      19  curAdd:     DC.W        $0
0000100E= 00                        20  movemAdd:   DC.B        $0
0000100F= 00                        21  listSize:   DC.B        $0
00001010                            22  *-----------------------------------------------------------
00001010                            23  * I/O Implementation
00001010                            24  ;1. Prompt user for start and ending addresses (In hex)
00001010                            25  ;2. User inputs their values
00001010                            26  ;3. Check for errors
00001010                            27  ;        Check to see if hex is too big
00001010                            28  ;        Check to see value doesn't contain G-Z
00001010                            29  ;        Check to see if there are no commas/special chars
00001010                            30  ;        Check to see that starting loc, is before ending loc
00001010                            31  ;        Check to see if value starts at odd mem location
00001010                            32  *-----------------------------------------------------------
00001010                            33  
00001010                            34             ;Show welcome to user
00001010  43F9 00001DD6             35              LEA         Welcome,A1
00001016  103C 000E                 36              MOVE.B      #14,D0
0000101A  4E4F                      37              TRAP        #15
0000101C                            38                       
0000101C  803C 000C                 39              OR.B        #12,D0
00001020  B6BC 45123456             40              CMP.L       #$45123456,D3
00001026                            41              
00001026  EB5A                      42              ROL.W       #5,D2
00001028                            43              
00001028  4CDD 4FE7                 44              MOVEM.L     (A5)+,D0-D2/D5-D7/A0-A3/A6
0000102C  4CD5 4FE7                 45              MOVEM.L     (A5),D0-D2/D5-D7/A0-A3/A6
00001030  48E5 E7F2                 46              MOVEM.L     D0-D2/D5-D7/A0-A3/A6,-(A5)
00001034  4CF8 7FBF 1234            47              MOVEM.L     $1234,D0-D5/D7/A0-A6
0000103A  4CF8 7F00 3000            48              MOVEM.L     $3000,A0-A6
00001040  48F8 FC3A 3004            49              MOVEM.L     D1/D3-D5/A2-A7,$3004
00001046  48F8 FC3F 3030            50              MOVEM.L     D0-D5/A2-A7,$3030
0000104C  48E7 FC3F                 51              MOVEM.L     D0-D5/A2-A7,-(A7)
00001050                            52              ;MOVEM.L     $3212,D0/D2/A5/A7
00001050                            53              ;MOVEM.L     D0-D5/D7/A0-A6,-(A7)     
00001050                            54              
00001050                            55  ;==========================            
00001050                            56              
00001050                            57  startingPrompt:
00001050                            58              ;Ask the user for the starting hex3
00001050  43F9 00001DFA             59              LEA         userSA,A1
00001056  103C 000E                 60              MOVE.B      #14,D0
0000105A  4E4F                      61              TRAP        #15        
0000105C                            62              
0000105C                            63              ;Clear the registers in case we had an error
0000105C  227C 00000000             64              MOVE.L      #0,A1
00001062  247C 00000000             65              MOVE.L      #0,A2
00001068  4283                      66              CLR.L       D3
0000106A  4284                      67              CLR.L       D4
0000106C  4285                      68              CLR.L       D5
0000106E  4286                      69              CLR.L       D6
00001070                            70             
00001070                            71              
00001070                            72              ;Input for the hex (D1 equals number of chars)
00001070  303C 0002                 73              MOVE.W      #2,D0
00001074  4E4F                      74              TRAP        #15
00001076                            75              
00001076                            76              ;Moves A1 into A2      
00001076                            77              ;MOVEA.L     A1,A2
00001076                            78              
00001076                            79              ;Makes sure D7 is clear incase we're looping back after an error.
00001076  4207                      80              CLR.B       D7
00001078                            81              
00001078  6000 002A                 82              BRA         convert  
0000107C                            83              
0000107C                            84  endingPrompt:
0000107C                            85              ;D7 is if we're working with the first or second prompt, used in the more checks section. 
0000107C  1E3C 0001                 86              MOVE.B       #1,D7
00001080                            87              
00001080                            88              ;Ask the user for the ending hex
00001080  43F9 00001E3C             89              LEA         userEA,A1
00001086  103C 000E                 90              MOVE.B      #14,D0
0000108A  4E4F                      91              TRAP        #15
0000108C                            92              
0000108C                            93              ;Clearing the registers so we can reuse them for the ending address
0000108C  227C 00000000             94              MOVE.L      #0,A1
00001092  247C 00000000             95              MOVE.L      #0,A2
00001098  4286                      96              CLR.L       D6
0000109A                            97  
0000109A                            98              ;Input for the hex (D1 equals number of chars)
0000109A  303C 0002                 99              MOVE.W      #2,D0
0000109E  4E4F                     100              TRAP        #15
000010A0                           101              
000010A0                           102              ;Moves A1 into A2      
000010A0                           103              ;MOVEA.L     A1,A2
000010A0                           104              
000010A0  6000 0002                105              BRA         convert
000010A4                           106  
000010A4                           107  convert:    
000010A4                           108              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
000010A4  B23C 0008                109              CMP.B       #8, D1
000010A8  6E00 0D0C                110              BGT         manyCharError  
000010AC                           111              
000010AC                           112              ;See if our counter variable is 0
000010AC  B23C 0000                113              CMP.B       #0,D1
000010B0                           114              
000010B0                           115              ;This means that we have gone through all the characters
000010B0  6700 0046                116              BEQ         moreChecks
000010B4                           117              
000010B4                           118              ;Decrement the counter, this means we're about to go through another char
000010B4  5301                     119              SUB.B       #1,D1
000010B6                           120  
000010B6                           121              ;Let's move the byte stored at A1
000010B6  1612                     122              MOVE.B      (A2),D3
000010B8                           123              
000010B8                           124              ;If the byte is greater than or equal to hex $40, then it's a letter
000010B8  B63C 0041                125              CMP.B       #$41,D3
000010BC  6C00 000A                126              BGE         letter
000010C0                           127              
000010C0                           128              ;If the byte is less than or equal to hex $39, then it's a number
000010C0  B63C 0040                129              CMP.B       #$40,D3
000010C4  6F00 0016                130              BLE         number
000010C8                           131              
000010C8                           132  letter:
000010C8                           133              ;We do this check to see if the character is greater than or equal 'G'
000010C8  B63C 0047                134              CMP.B       #$47,D3
000010CC                           135              ;If so, then display an error and ask the user to enter startingAdd again
000010CC  6C00 0CC8                136              BGE         charError
000010D0                           137              
000010D0                           138              ;Subtract the Ascii value to convert to hex
000010D0  0403 0037                139              SUB.B       #$37,D3
000010D4                           140              ;Move the value back to our register
000010D4  14C3                     141              MOVE.B      D3,(A2)+
000010D6                           142              
000010D6                           143              ;Shift D5 left to make room for next hex value
000010D6  E986                     144              ASL.L       #4, D6
000010D8                           145              ;Move value to D5
000010D8  DC03                     146              ADD.B      D3, D6
000010DA                           147              
000010DA  60C8                     148              BRA         convert
000010DC                           149             
000010DC                           150  
000010DC                           151  number:          
000010DC                           152             ;We do this check to see if the character is less than or equal to '/'  
000010DC  B63C 002F                153             CMP.B        #$2F,D3
000010E0                           154             ;If so, then display an error and ask the user to enter startingAdd again
000010E0  6F00 0CB4                155             BLE          charError     
000010E4                           156   
000010E4                           157             ;Check to see if the character is greater than or equal to ':'
000010E4  B63C 003A                158             CMP.B        #$3A,D3
000010E8                           159             ;If so, then display an error and ask the user to enter startingAdd again
000010E8  6C00 0CAC                160             BGE          charError
000010EC                           161            
000010EC                           162             ;Subtract the Ascii value to convert to hex
000010EC  0403 0030                163             SUB.B        #$30,D3
000010F0                           164             ;Move the value back to our register
000010F0  14C3                     165             MOVE.B       D3,(A2)+
000010F2                           166   
000010F2                           167             ;Shift D5 left to make room for next hex value
000010F2  E986                     168             ASL.L        #4, D6
000010F4                           169             ;Move value to D5
000010F4  DC03                     170             ADD.B        D3, D6
000010F6                           171              
000010F6  60AC                     172             BRA          convert
000010F8                           173   
000010F8                           174            
000010F8                           175  moreChecks:
000010F8                           176              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010F8  BE3C 0001                177              CMP.B      #1,D7
000010FC  6700 0028                178              BEQ        moreChecks2
00001100                           179              
00001100  6000 0002                180              BRA        moreChecks1
00001104                           181   
00001104                           182  moreChecks1:
00001104                           183              
00001104                           184              ;Copy the hex value into a temp register
00001104  2806                     185              MOVE.L      D6,D4
00001106                           186              
00001106                           187              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001106  1A3C 001F                188              MOVE.B      #31,D5
0000110A                           189              
0000110A                           190              ;Shifts 31 bits, isolates last bit. 
0000110A  EBAC                     191              LSL.L       D5,D4
0000110C                           192  
0000110C                           193              ;Shifts it back 31 bit, isolating the last bit. 
0000110C  EAAC                     194              LSR.L       D5,D4
0000110E                           195  
0000110E                           196              ;If the last bit is 1, address was odd, and throw an error. 
0000110E  B83C 0001                197              CMP.B       #1,D4
00001112  6700 0C92                198              BEQ         oddError   
00001116                           199                          
00001116                           200              ;Reset address registers.
00001116  247C 00000000            201              MOVE.L      #0,A2
0000111C                           202              
0000111C                           203              ;Copy the value to our staHex variable
0000111C  21C6 1000                204              MOVE.L      D6,staHex 
00001120                           205              
00001120  4286                     206              CLR.L       D6
00001122  6000 FF58                207              BRA         endingPrompt     
00001126                           208              
00001126                           209  moreChecks2:       
00001126                           210              
00001126                           211              ;Copy the hex value into a temp register
00001126  2806                     212              MOVE.L      D6,D4
00001128                           213              
00001128                           214              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001128  1A3C 001F                215              MOVE.B      #31,D5
0000112C                           216              
0000112C                           217              ;Shifts 31 bits, isolates last bit. 
0000112C  EBAC                     218              LSL.L       D5,D4
0000112E                           219  
0000112E                           220              ;Shifts it back 31 bit, isolating the last bit. 
0000112E  EAAC                     221              LSR.L       D5,D4
00001130                           222  
00001130                           223              ;If the last bit is 1, address was odd, and throw an error. 
00001130  B83C 0001                224              CMP.B       #1,D4
00001134  6700 0C70                225              BEQ         oddError   
00001138                           226                          
00001138                           227              ;Reset address registers.
00001138  247C 00000000            228              MOVE.L      #0,A2
0000113E                           229              
0000113E                           230              ;Place the value in our ending hex variable
0000113E  21C6 1004                231              MOVE.L      D6,endHex 
00001142                           232              
00001142                           233              ;Make D7 a temp location to compare our starting hex
00001142  2E38 1000                234              MOVE.L      staHex,D7
00001146                           235           
00001146                           236              
00001146                           237              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001146  BC87                     238              CMP.L       D7,D6
00001148  6B00 0C7C                239              BMI         endGreater
0000114C                           240              
0000114C                           241              ;done, start reading memory. 
0000114C                           242              
0000114C                           243              ;Clear all the registers since we have the addresses stored in our variables
0000114C  4283                     244              CLR.L       D3
0000114E  4285                     245              CLR.L       D5
00001150  4286                     246              CLR.L       D6
00001152  4287                     247              CLR.L       D7  
00001154                           248              
00001154                           249              ;Copy the value of our starting hex to A2 (temp register)
00001154  2478 1000                250              MOVEA.L     staHex,A2
00001158                           251                          
00001158                           252              
00001158                           253  LOOP:   
00001158                           254              ;We will be printing out the address, regardless if the opcode is valid or not
00001158  43F9 00001E7C            255              LEA         AddressNum,A1
0000115E  103C 000E                256              MOVE.B      #14,D0
00001162  4E4F                     257              TRAP        #15
00001164                           258              
00001164                           259              ;Print out the address
00001164  700F                     260              MOVE.L      #15,D0
00001166  7410                     261              MOVE.L      #16,D2
00001168  220A                     262              MOVE.L      A2,D1
0000116A  4E4F                     263              TRAP        #15
0000116C                           264              
0000116C  43F9 00001F31            265              LEA         printSpace,A1
00001172  103C 000E                266              MOVE.B      #14,D0
00001176  4E4F                     267              TRAP        #15
00001178                           268  
00001178                           269              ;--------------------------------------------------------
00001178                           270              ;Check for NOP or RTS
00001178                           271              ;--------------------------------------------------------
00001178                           272              
00001178                           273              ;Move the NOP binary value for comparing
00001178  243C 00004E71            274              MOVE.L      #%0100111001110001,D2
0000117E                           275              
0000117E                           276              ;Check and see i the instruction is NOP
0000117E  B452                     277              CMP.W       (A2),D2
00001180  6700 0BF4                278              BEQ         printMNOP
00001184                           279              
00001184                           280              ;Move the RTS binary value for comparing
00001184  243C 00004E75            281              MOVE.L      #%0100111001110101,D2
0000118A                           282              
0000118A                           283              ;Check and see if the instruction is RTS
0000118A  B452                     284              CMP.W       (A2),D2
0000118C  6700 0BF8                285              BEQ         printMRTS
00001190                           286              
00001190                           287              ;Clear the contents for reusing
00001190  4282                     288              CLR.L       D2
00001192                           289              
00001192                           290              ;--------------------------------------------------------
00001192                           291              ;Check for ADDI or SUBI, check for four 0's since it's the only
00001192                           292              ;opcode with this pattern
00001192                           293              ;--------------------------------------------------------  
00001192                           294              ;Move the value in A2 to a temp register
00001192  3412                     295              MOVE.W      (A2),D2
00001194                           296              
00001194                           297              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001194  163C 000C                298              MOVE.B      #12,D3
00001198  183C 0004                299              MOVE.B      #4,D4
0000119C                           300              
0000119C                           301              ;Jumps to getBits and returns with isolated bits in D2
0000119C  6100 009E                302              BSR         getBits
000011A0                           303              
000011A0  B43C 0000                304              CMP.B       #%0000,D2
000011A4  6700 00AC                305              BEQ         M0000
000011A8                           306              
000011A8                           307              ;--------------------------------------------------------
000011A8                           308              ;Check for MOVE, since it's the only word starting with 00
000011A8                           309              ;--------------------------------------------------------            
000011A8                           310              ;Move the value in A2 to a temp register
000011A8  1412                     311              MOVE.B      (A2),D2
000011AA                           312              
000011AA                           313              ;Shift 6 bits to the right to isolate the left-most digits
000011AA  EC8A                     314              LSR.L       #6,D2
000011AC                           315              
000011AC                           316              ;If the first two bits (left-most) are 00, then the instruction is MOVE
000011AC  B43C 0000                317              CMP.B       #00,D2
000011B0  6F00 018E                318              BLE         M00
000011B4                           319              
000011B4                           320              ;Reuse the register
000011B4  4282                     321              CLR.L       D2
000011B6                           322              
000011B6                           323              
000011B6                           324              ;--------------------------------------------------------
000011B6                           325              ;Check for other OpCodes
000011B6                           326              ;--------------------------------------------------------
000011B6                           327              ;Move the word into a temp register 
000011B6  3412                     328              MOVE.W      (A2),D2
000011B8                           329              
000011B8                           330              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
000011B8  163C 000C                331              MOVE.B        #12,D3            ;Start bit index = 12
000011BC  183C 0004                332              MOVE.B        #4,D4             ;Number of bits needed = 4
000011C0                           333              
000011C0                           334              ;Jumps to getBits and returns with isolated bits in D2
000011C0  6100 007A                335              BSR           getBits            
000011C4                           336  
000011C4                           337              
000011C4                           338              ;MOVEM,LEA,NOT,JSR
000011C4  B43C 0004                339              CMP.B       #%0100,D2
000011C8  6700 01FE                340              BEQ         M0100
000011CC                           341              
000011CC                           342              ;BRA,BLT,BGE,BEQ
000011CC  B43C 0006                343              CMP.B       #%0110,D2
000011D0  6700 04E6                344              BEQ         M0110
000011D4                           345              
000011D4                           346              ;DIVU
000011D4  B43C 0008                347              CMP.B       #%1000,D2
000011D8  6700 065A                348              BEQ         M1000
000011DC                           349              
000011DC                           350              ;SUB
000011DC  B43C 0009                351              CMP.B       #%1001,D2
000011E0  6700 067E                352              BEQ         M1001
000011E4                           353              
000011E4                           354              ;MULS,AND
000011E4  B43C 000C                355              CMP.B       #%1100,D2
000011E8  6700 06BA                356              BEQ         M1100
000011EC                           357              
000011EC                           358              ;LSL,LSR,ASL,ASR
000011EC  B43C 000E                359              CMP.B       #%1110,D2
000011F0  6700 072A                360              BEQ         M1110
000011F4                           361              
000011F4                           362              ;ADD
000011F4  B43C 000D                363              CMP.B       #%1101,D2
000011F8  6700 0902                364              BEQ         M1101
000011FC                           365              
000011FC                           366              ;If the first 4 bits do not match any of the opcodes listed
000011FC                           367              ;then we must have an invalid opcode
000011FC  6100 0006                368              BSR         invalid
00001200                           369              
00001200  6000 0E60                370              BRA         ending                    
00001204                           371              
00001204                           372  invalid:
00001204  43F9 00002046            373              LEA         invalOpcode,A1
0000120A  103C 000E                374              MOVE.B      #14,D0
0000120E  4E4F                     375              TRAP        #15
00001210                           376  
00001210                           377              ;Clear any previous data that might have been there
00001210  4281                     378              CLR.L      D1
00001212                           379  
00001212                           380              ;Print out the hex value from the address
00001212  700F                     381              MOVE.L      #15,D0
00001214  7410                     382              MOVE.L      #16,D2
00001216  3212                     383              MOVE.W      (A2),D1
00001218  4E4F                     384              TRAP        #15
0000121A                           385  
0000121A  6000 0002                386              BRA         update
0000121E                           387             
0000121E                           388  update:
0000121E                           389              *=====Important if we've done any Immediate or Absolute addressing=====*
0000121E                           390              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
0000121E                           391              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
0000121E                           392              ;because A2 always points at the the first word in an instruction (opcode).
0000121E  B5CE                     393              CMP.L       A6,A2
00001220  6C00 0004                394              BGE         skipA6
00001224                           395              
00001224                           396              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
00001224  244E                     397              MOVEA.L     A6,A2
00001226                           398              
00001226                           399  skipA6:
00001226                           400              ;Check and see if we are at the ending hex
00001226  B5F8 1004                401              CMP.L      endHex,A2
0000122A  6E00 0E36                402              BGT        ending
0000122E                           403  
0000122E                           404              ;Update address in A2
0000122E  544A                     405              ADD.W      #2,A2
00001230                           406              
00001230                           407              ;Clear size storage 
00001230  21FC 00000000 2000       408              MOVE.L     #$00000000,$2000
00001238                           409              
00001238  6000 FF1E                410              BRA        LOOP
0000123C                           411              
0000123C                           412              
0000123C                           413  getBits:
0000123C                           414              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
0000123C                           415              ;PARAMETERS:
0000123C                           416              ;D2 = the value the bits are extracted from & saved back in
0000123C                           417              ;D3 = the start bit index (starting from 0)
0000123C                           418              ;D4 = the number of bits we want to extract
0000123C                           419              
0000123C                           420              ;Calculate left shift
0000123C  3A3C 0010                421              MOVE.W      #16,D5
00001240                           422              
00001240  D843                     423              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
00001242  9A44                     424              SUB.W       D4,D5             ; 16 - X = leftShift
00001244                           425              
00001244  EB6A                     426              LSL.W       D5,D2
00001246                           427              
00001246                           428              
00001246                           429              ;Calculate right shift
00001246  DA43                     430              ADD.W       D3,D5             ; start bit + leftShift = X
00001248  EA6A                     431              LSR.W       D5,D2
0000124A                           432              
0000124A  4283                     433              CLR.L       D3
0000124C  4284                     434              CLR.L       D4
0000124E  4285                     435              CLR.L       D5   
00001250  4E75                     436              RTS
00001252                           437  
00001252                           438  *-----------------------------------------------------------
00001252                           439  * 
00001252                           440  *
00001252                           441  *
00001252                           442  * OpCode Implementation
00001252                           443  *
00001252                           444  *
00001252                           445  *
00001252                           446  *-----------------------------------------------------------
00001252                           447  
00001252                           448  
00001252                           449  *-----------------------------------------------------------
00001252                           450  * ADDI/SUBI INSTRUCTION
00001252                           451  *-----------------------------------------------------------
00001252                           452  M0000:
00001252  4282                     453              CLR.L       D2
00001254  4283                     454              CLR.L       D3
00001256                           455              
00001256                           456              ;Copy the address values into a register to check for ADDI or SUBI
00001256  3412                     457              MOVE.W      (A2),D2
00001258                           458              
00001258                           459              ;Passing in paramters for isolating bits
00001258  163C 0008                460              MOVE.B      #8,D3
0000125C  183C 0004                461              MOVE.B      #4,D4
00001260                           462              
00001260                           463              ;Jumps to getBits and returns with isolated bits in D2
00001260  61DA                     464              BSR         getBits
00001262                           465              
00001262                           466              ;--------------------------------------------------------
00001262                           467              ;Check for ADDI
00001262                           468              ;--------------------------------------------------------
00001262  B43C 0006                469              CMP.B       #%0110,D2
00001266  6700 0022                470              BEQ         MADDI
0000126A                           471             
0000126A                           472              ;--------------------------------------------------------
0000126A                           473              ;Check for SUBI
0000126A                           474              ;--------------------------------------------------------
0000126A  B43C 0004                475              CMP.B       #%0100,D2
0000126E  6700 0050                476              BEQ         MSUBI
00001272                           477              
00001272                           478              ;--------------------------------------------------------
00001272                           479              ;Check for ANDI
00001272                           480              ;--------------------------------------------------------
00001272  B43C 0002                481              CMP.B       #%0010,D2
00001276  6700 0002                482              BEQ         MANDI
0000127A                           483              
0000127A                           484              MANDI:
0000127A  43F9 00001EC2            485              LEA         printANDI,A1
00001280  103C 000E                486              MOVE.B      #14,D0
00001284  4E4F                     487              TRAP        #15
00001286                           488              
00001286  6000 000E                489              BRA         continueI
0000128A                           490  
0000128A                           491  
0000128A                           492  MADDI:
0000128A  43F9 00001E9B            493              LEA         printADDI,A1
00001290  103C 000E                494              MOVE.B      #14,D0
00001294  4E4F                     495              TRAP        #15
00001296                           496  
00001296                           497  continueI:            
00001296  4282                     498              CLR.L       D2
00001298  4283                     499              CLR.L       D3
0000129A                           500              
0000129A                           501              ;======Isolate Size (S) Bits======
0000129A                           502              ;Copy the address values into a register
0000129A  3412                     503              MOVE.W      (A2),D2
0000129C                           504              
0000129C                           505              ;Passing in parameters for isolating size bits
0000129C  163C 0006                506              MOVE.B      #6,D3
000012A0  183C 0002                507              MOVE.B      #2,D4
000012A4                           508              
000012A4                           509              ;Jumps to getBits and returns with isolated bits in D2
000012A4  6196                     510              BSR         getBits
000012A6                           511              
000012A6                           512              ;Jumps to printSizeSubroutine and returns after size has been printed
000012A6  6100 091E                513              BSR         printSizeSubroutine
000012AA                           514              
000012AA                           515              ;Let's store the size indicator since it will help us determine how many times
000012AA                           516              ;we have to iterate through addresses to print out the whole instruction
000012AA                           517              ;We will use A4 as the register to temporary store the size
000012AA  3842                     518              MOVE.W      D2,A4
000012AC  11C2 2000                519              MOVE.B      D2,$2000
000012B0                           520              
000012B0                           521              ;Clear the register so we can reuse it
000012B0  4282                     522              CLR.L       D2
000012B2                           523              
000012B2  1412                     524              MOVE.B      (A2),D2
000012B4                           525              
000012B4                           526              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012B4                           527              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012B4  264A                     528              MOVE.L      A2,A3
000012B6                           529              
000012B6  6100 0040                530              BSR         mEffect
000012BA                           531              
000012BA  4283                     532              CLR.L       D3
000012BC                           533              
000012BC  6000 FF60                534              BRA         update
000012C0                           535              
000012C0                           536              
000012C0                           537  MSUBI:
000012C0  43F9 00001EA4            538              LEA         printSUBI,A1
000012C6  103C 000E                539              MOVE.B      #14,D0
000012CA  4E4F                     540              TRAP        #15
000012CC                           541              
000012CC  4282                     542              CLR.L       D2
000012CE  4283                     543              CLR.L       D3
000012D0                           544              
000012D0                           545              ;======Isolate Size (S) Bits======
000012D0                           546              ;Copy the address values into a register
000012D0  3412                     547              MOVE.W      (A2),D2
000012D2                           548              
000012D2                           549              ;Passing in parameters for isolating size bits
000012D2  163C 0006                550              MOVE.B      #6,D3
000012D6  183C 0002                551              MOVE.B      #2,D4
000012DA                           552              
000012DA                           553              ;Jumps to getBits and returns with isolated bits in D2
000012DA  6100 FF60                554              BSR         getBits
000012DE                           555              
000012DE                           556              ;Jumps to printSizeSubroutine and returns after size has been printed
000012DE  6100 08E6                557              BSR         printSizeSubroutine
000012E2                           558              
000012E2                           559              ;Let's store the size indicator since it will help us determine how many times
000012E2                           560              ;we have to iterate through addresses to print out the whole instruction
000012E2                           561              ;We will use A4 as the register to temporary store the size
000012E2  3842                     562              MOVE.W      D2,A4
000012E4  11C2 2000                563              MOVE.B      D2,$2000
000012E8                           564              
000012E8                           565              ;Clear the register so we can reuse it
000012E8  4282                     566              CLR.L       D2
000012EA                           567              
000012EA  1412                     568              MOVE.B      (A2),D2
000012EC                           569              
000012EC                           570              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
000012EC                           571              ;This is meant so we can use the copy to figure out the destination addrresing mode
000012EC  264A                     572              MOVE.L      A2,A3
000012EE                           573              
000012EE  6100 0008                574              BSR         mEffect
000012F2                           575              
000012F2  4283                     576              CLR.L       D3
000012F4                           577              
000012F4  6000 FF28                578              BRA         update
000012F8                           579  
000012F8                           580              
000012F8                           581  mEffect:
000012F8                           582              ;Male D6 #%111 since the source will always be an immediate value 
000012F8  1C3C 0007                583              MOVE.B      #7,D6
000012FC                           584              ;Make D7 #%100 since the source will always be an immediate value
000012FC  1E3C 0004                585              MOVE.B      #4,D7     
00001300                           586  
00001300                           587              ;Print source address
00001300  6100 0936                588              BSR         addressModeSR
00001304                           589              
00001304                           590              ;Print the comma after the source address
00001304  43F9 00001F2F            591              LEA        printComma,A1
0000130A  103C 000E                592              MOVE.B     #14,D0
0000130E  4E4F                     593              TRAP       #15
00001310                           594              
00001310                           595              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001310  6100 0008                596              BSR        isoAddBit0to5
00001314                           597              
00001314                           598              ;Print source address
00001314  6100 0922                599              BSR        addressModeSR
00001318                           600              
00001318  4E75                     601              RTS            
0000131A                           602              
0000131A                           603              
0000131A                           604  isoAddBit0to5:
0000131A                           605              ;===Isolate the Destination Mode (M)Bits===
0000131A  4282                     606              CLR.L      D2
0000131C                           607              
0000131C                           608              ;Copy the address value into a register
0000131C  3413                     609              MOVE.W     (A3),D2
0000131E                           610              
0000131E                           611              ;Passing in parameters for isolating Mode bits
0000131E  163C 0003                612              MOVE.B     #3,D3
00001322  183C 0003                613              MOVE.B     #3,D4
00001326                           614              
00001326                           615              ;Jumps to getBits and returns with isolated bits in D2
00001326  4EB8 123C                616              JSR        getBits
0000132A                           617              
0000132A                           618              ;Save M bit into ***D6*** for later use in addressModeSubroutine
0000132A  1C02                     619              MOVE.B     D2,D6
0000132C                           620              
0000132C                           621              ;===Isolate the Destination Address Register (Xn)Bits===
0000132C  4282                     622              CLR.L      D2
0000132E                           623              
0000132E                           624              ;Copy the address values into a register
0000132E  3413                     625              MOVE.W     (A3),D2
00001330                           626              
00001330                           627              ;Passing in parameters for isolating Xn bits
00001330  163C 0000                628              MOVE.B     #0,D3
00001334  183C 0003                629              MOVE.B     #3,D4
00001338                           630              
00001338                           631              ;Jumps to getBits and returns with isolated bits in D2
00001338  4EB8 123C                632              JSR        getBits
0000133C                           633              
0000133C                           634              ;Save Xn register bit into ***D7*** for later use in addressModeSR
0000133C  1E02                     635              MOVE.B      D2,D7
0000133E                           636  
0000133E  4E75                     637              RTS
00001340                           638              
00001340                           639  *-----------------------------------------------------------
00001340                           640  * MOVE INSTRUCTION
00001340                           641  *-----------------------------------------------------------
00001340                           642  M00:
00001340  43F9 00001E8C            643              LEA        printMOVE,A1
00001346  103C 000E                644              MOVE.B     #14,D0
0000134A  4E4F                     645              TRAP       #15
0000134C                           646              
0000134C  4202                     647              CLR.B      D2
0000134E  4203                     648              CLR.B      D3
00001350                           649              
00001350                           650              ;======Isolate Size (S) Bits=======
00001350                           651              ;Copy the address values into a register
00001350  3412                     652              MOVE.W     (A2),D2
00001352                           653              
00001352                           654              ;Passing in parameters for isolating size bits 12,13
00001352  163C 000C                655              MOVE.B      #12,D3             
00001356  183C 0002                656              MOVE.B      #2,D4             
0000135A                           657              
0000135A                           658              ;Jumps to getBits and returns with isolated bits in D2
0000135A  6100 FEE0                659              BSR         getBits  
0000135E                           660              
0000135E                           661              ;Check and see if we have the MOVE opcode since it shares with others
0000135E  B43C 0000                662              CMP.B       #0,D2
00001362  6700 FEA0                663              BEQ         invalid
00001366                           664              
00001366  4283                     665              CLR.L       D3
00001368                           666              
00001368                           667              ;Indicate to our print function we are doing this for the MOVE opcode
00001368  163C 0001                668              MOVE.B      #1,D3
0000136C                           669              
0000136C                           670              ;Jumps to printSizeSubroutine and returns after size has been printed
0000136C  6100 0858                671              BSR         printSizeSubroutine
00001370                           672              
00001370                           673              ;Let's store the size indicator since it will help us determine how many times
00001370                           674              ;we have to iterate through addresses to print out the whole instruction
00001370                           675              ;We will use A4 as the register to temporary store the size
00001370  3842                     676              MOVE.W      D2,A4
00001372  11C2 2000                677              MOVE.B      D2,$2000
00001376                           678  
00001376                           679              ;Clear the register so we can reuse it
00001376  4282                     680              CLR.L       D2
00001378                           681              
00001378  3412                     682              MOVE.W      (A2),D2
0000137A                           683              
0000137A                           684              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
0000137A                           685              ;This is meant so we can use the copy to figure out the destination addressing mode
0000137A  264A                     686              MOVE.L      A2,A3
0000137C                           687  
0000137C  6000 0002                688              BRA         mSourceDest
00001380                           689              
00001380                           690            
00001380                           691  ;======Helper function to find the destination for MOVE======
00001380                           692  mSourceDest:
00001380                           693              ;SOURCE
00001380                           694              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001380  6100 0806                695              BSR        isolateAddressBit0to5
00001384                           696              
00001384                           697              ;Print source address
00001384  6100 08B2                698              BSR        addressModeSR
00001388                           699              
00001388                           700              ;Print the comma after the source address
00001388  43F9 00001F2F            701              LEA        printComma,A1
0000138E  103C 000E                702              MOVE.B     #14,D0
00001392  4E4F                     703              TRAP       #15
00001394                           704              
00001394                           705              ;DESTINATION
00001394                           706              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001394  6100 000C                707              BSR        isolateAddressBit6to11
00001398                           708              
00001398                           709              ;Print destination address
00001398  6100 089E                710              BSR        addressModeSR
0000139C                           711              
0000139C  4283                     712              CLR.L      D3
0000139E                           713              
0000139E  6000 FE7E                714              BRA        update
000013A2                           715              
000013A2                           716  
000013A2                           717  isolateAddressBit6to11:
000013A2                           718              ;===Isolate the Destination Mode (M)Bits===
000013A2  4282                     719              CLR.L      D2
000013A4                           720              
000013A4                           721              ;Copy the address value into a register
000013A4  3413                     722              MOVE.W     (A3),D2
000013A6                           723              
000013A6                           724              ;Passing in parameters for isolating Mode bits
000013A6  163C 0006                725              MOVE.B     #6,D3
000013AA  183C 0003                726              MOVE.B     #3,D4
000013AE                           727              
000013AE                           728              ;Jumps to getBits and returns with isolated bits in D2
000013AE  4EB8 123C                729              JSR        getBits
000013B2                           730              
000013B2                           731              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000013B2  1C02                     732              MOVE.B     D2,D6
000013B4                           733              
000013B4                           734              ;===Isolate the Destination Address Register (Xn)Bits===
000013B4  4282                     735              CLR.L      D2
000013B6                           736              
000013B6                           737              ;Copy the address values into a register
000013B6  3413                     738              MOVE.W     (A3),D2
000013B8                           739              
000013B8                           740              ;Passing in parameters for isolating Xn bits
000013B8  163C 0009                741              MOVE.B     #9,D3
000013BC  183C 0003                742              MOVE.B     #3,D4
000013C0                           743              
000013C0                           744              ;Jumps to getBits and returns with isolated bits in D2
000013C0  4EB8 123C                745              JSR        getBits
000013C4                           746              
000013C4                           747              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000013C4  1E02                     748              MOVE.B      D2,D7
000013C6                           749  
000013C6  4E75                     750              RTS
000013C8                           751              
000013C8                           752              
000013C8                           753  *-----------------------------------------------------------
000013C8                           754  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
000013C8                           755  *-----------------------------------------------------------
000013C8                           756  M0100:      
000013C8  4282                     757              CLR.L       D2
000013CA  4283                     758              CLR.L       D3
000013CC                           759              
000013CC                           760              ;--------------------------------------------------------
000013CC                           761              ;Check for LEA
000013CC                           762              ;--------------------------------------------------------
000013CC                           763              ;Copy the address values into a register to check for LEA
000013CC  3412                     764              MOVE.W     (A2),D2
000013CE                           765              
000013CE                           766              ;Passing in parameters for isolating bits 6,7,8
000013CE  163C 0006                767              MOVE.B      #6,D3             ;Start bit index = 6
000013D2  183C 0003                768              MOVE.B      #3,D4             ;Number of bits needed = 3
000013D6                           769              
000013D6                           770              ;Jumps to getBits and returns with isolated bits in D2
000013D6  6100 FE64                771              BSR         getBits
000013DA                           772  
000013DA  B43C 0007                773              CMP.B       #%111,D2
000013DE  6700 0264                774              BEQ         MLEA
000013E2                           775  
000013E2                           776              ;--------------------------------------------------------
000013E2                           777              ;Check for NOT
000013E2                           778              ;--------------------------------------------------------
000013E2                           779              ;Clear D2 and recopy it to check for NOT
000013E2  4282                     780              CLR.L       D2
000013E4  3412                     781              MOVE.W      (A2),D2
000013E6                           782              
000013E6                           783              ;Pass in parameters for isolating bits 8,9,10,11
000013E6  163C 0008                784              MOVE.B      #8,D3
000013EA  183C 0004                785              MOVE.B      #4,D4
000013EE                           786              
000013EE                           787              ;Jumps to getBits and returns with isolated bits in D2
000013EE  6100 FE4C                788              BSR         getBits
000013F2                           789              
000013F2  B43C 0006                790              CMP.B       #%0110,D2
000013F6  6700 027C                791              BEQ         MNOT      
000013FA                           792              
000013FA                           793              ;--------------------------------------------------------
000013FA                           794              ;Check for JSR
000013FA                           795              ;--------------------------------------------------------
000013FA                           796              ;Clear D2 and recopy it to check for JSR
000013FA  4282                     797              CLR.L       D2
000013FC  3412                     798              MOVE.W     (A2),D2
000013FE                           799              
000013FE                           800              ;Pass in parameters for isolating bits 6-11
000013FE  163C 0006                801              MOVE.B      #6,D3
00001402  183C 0006                802              MOVE.B      #6,D4
00001406                           803              
00001406                           804              ;Jumps to getBits and returns with isolated bits in D2
00001406  6100 FE34                805              BSR         getBits
0000140A                           806              
0000140A  B43C 003A                807              CMP.B       #%111010,D2
0000140E  6700 0290                808              BEQ         MJSR
00001412                           809              
00001412                           810              ;--------------------------------------------------------
00001412                           811              ;Check for MOVEM
00001412                           812              ;--------------------------------------------------------
00001412                           813              ;Clear D2 and recopy it to check for MOVEM
00001412  4282                     814              CLR.L       D2
00001414  3412                     815              MOVE.W     (A2),D2
00001416                           816              
00001416                           817              ;Pass in parameters for isolating bit 9
00001416  163C 0009                818              MOVE.B      #9,D3
0000141A  183C 0001                819              MOVE.B      #1,D4
0000141E                           820              
0000141E                           821              ;Jumps to getBits and returns with isolated bits in D2
0000141E  6100 FE1C                822              BSR         getBits
00001422                           823              
00001422  B43C 0000                824              CMP.B       #%0,D2
00001426  6700 0002                825              BEQ         MOVEM
0000142A                           826              
0000142A                           827         
0000142A                           828  MOVEM:
0000142A  43F9 00001E91            829              LEA         printMOVEM,A1
00001430  103C 000E                830              MOVE.B      #14,D0
00001434  4E4F                     831              TRAP        #15
00001436                           832              
00001436                           833              ***Isolate Size Bit***
00001436                           834              ;Clear D2 and recopy it to check for Size bit
00001436  4282                     835              CLR.L       D2
00001438  3412                     836              MOVE.W      (A2),D2
0000143A                           837              
0000143A                           838              ;Pass in paramters for isolating bit 6
0000143A  163C 0006                839              MOVE.B      #6,D3
0000143E  183C 0001                840              MOVE.B      #1,D4
00001442                           841              
00001442                           842              ;Jumps to getBits and returns with isolated bits in D2
00001442  6100 FDF8                843              BSR         getBits
00001446                           844              
00001446                           845              ;Print size
00001446  4EB9 00001BFE            846              JSR         printMOVEMSize
0000144C                           847              
0000144C                           848              ;Clear any value in our gloabal variable just in case
0000144C  11FC 0000 100E           849              MOVE.B      #0,movemAdd
00001452                           850              
00001452                           851              ;Next we are going to get the addressing mode to determine how we print the register list
00001452                           852              ;Isolate bits 0 to 5
00001452  4EB9 00001B88            853              JSR         isolateAddressBit0to5
00001458                           854              ;Let's store the addressing mode in our global variable
00001458  11C6 100E                855              MOVE.B      D6,movemAdd
0000145C                           856              
0000145C  4283                     857              CLR.L       D3
0000145E  4284                     858              CLR.L       D4
00001460  4286                     859              CLR.L       D6
00001462                           860              
00001462                           861              
00001462                           862              ***Isolate Direction bit
00001462                           863              ;Clear D2 and recopy it to check for D bit
00001462  4282                     864              CLR.L       D2
00001464  3412                     865              MOVE.W      (A2),D2
00001466                           866              
00001466                           867              ;Pass in parameters for isolating bit 10
00001466  163C 000A                868              MOVE.B      #10,D3
0000146A  183C 0001                869              MOVE.B      #1,D4
0000146E                           870              
0000146E                           871              ;Jumps to getBits and returns with isolated bits in D2
0000146E  6100 FDCC                872              BSR         getBits
00001472                           873  
00001472                           874              ***Determine the direction of the instruction***
00001472  B43C 0000                875              CMP.B       #0,D2
00001476  6700 000A                876              BEQ         ListToMem
0000147A                           877  
0000147A                           878              ;Memory to Register List
0000147A  B43C 0001                879              CMP.B       #1,D2
0000147E  6700 004E                880              BEQ         MemToList  
00001482                           881                         
00001482                           882  ListToMem:
00001482                           883              ***SOURCE(Register List)  
00001482  4282                     884              CLR.L       D2
00001484                           885  
00001484                           886              ;A3 will act as our temp variable 
00001484  2678 0000                887              MOVE.L      $00000000,A3
00001488  364A                     888              MOVEA.W     A2,A3
0000148A                           889              
0000148A                           890              ;Reset 
0000148A  11FC 0000 1009           891              MOVE.B     #$00,totalCount
00001490  11FC 0000 100F           892              MOVE.B     #$00,listSize
00001496                           893           
00001496  11FC 0001 100C           894              MOVE.B      #1,curAdd
0000149C                           895              
0000149C                           896              ;Go find the register list
0000149C  6100 007A                897              BSR         check
000014A0                           898              
000014A0                           899  ListToMem2:
000014A0                           900              ;Print the comma after the source address
000014A0  43F9 00001F2F            901              LEA         printComma,A1
000014A6  103C 000E                902              MOVE.B      #14,D0
000014AA  4E4F                     903              TRAP        #15
000014AC                           904              
000014AC                           905              ***DESTINATION(Memory)
000014AC                           906              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
000014AC  4282                     907              CLR.L       D2
000014AE                           908              
000014AE  3412                     909              MOVE.W      (A2),D2
000014B0                           910              
000014B0                           911              ;Isolate bits 0 to 5
000014B0  4EB9 00001B88            912              JSR         isolateAddressBit0to5
000014B6                           913              
000014B6  BC3C 0007                914              CMP.B       #%111,D6
000014BA  6100 0058                915              BSR         absoluteAddressMOVEM
000014BE                           916              
000014BE                           917              ;Clear A6 since we will need this for later
000014BE  2C7C 00000000            918              MOVE.L      #00000000,A6
000014C4                           919              
000014C4                           920              ;Print memory address
000014C4  6100 0772                921              BSR         addressModeSR
000014C8                           922              
000014C8  4283                     923              CLR.L      D3
000014CA                           924              
000014CA  6000 FD52                925              BRA        update
000014CE                           926  
000014CE                           927  
000014CE                           928  MemToList:
000014CE                           929              ***SOURCE(Memory)***
000014CE                           930              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
000014CE  4282                     931              CLR.L       D2            
000014D0                           932              
000014D0  3412                     933              MOVE.W      (A2),D2
000014D2                           934              
000014D2                           935              ;Use A3 as a temp address to be able to access the memory address
000014D2  267C 00000000            936              MOVE.L      #00000000,A3
000014D8  364A                     937              MOVEA.W     A2,A3
000014DA                           938  
000014DA                           939              ;Isolate addressing bits 0 to 5
000014DA  4EB9 00001B88            940              JSR         isolateAddressBit0to5
000014E0                           941              
000014E0  BC3C 0007                942              CMP.B       #%111,D6
000014E4  6100 002E                943              BSR         absoluteAddressMOVEM
000014E8                           944             
000014E8                           945              ;Clear A6 since we will need this for later
000014E8  2C7C 00000000            946              MOVE.L      #00000000,A6
000014EE                           947              
000014EE                           948              ;Print memory address
000014EE  6100 0748                949              BSR         addressModeSR
000014F2                           950              
000014F2                           951              ;Print the comma after the source address
000014F2  43F9 00001F2F            952              LEA         printComma,A1
000014F8  103C 000E                953              MOVE.B      #14,D0
000014FC  4E4F                     954              TRAP        #15
000014FE                           955                          
000014FE                           956              ;Reset 
000014FE  11FC 0000 1009           957              MOVE.B      #$00,totalCount
00001504  11FC 0000 100F           958              MOVE.B      #$00,listSize
0000150A                           959              
0000150A  11FC 0000 100C           960              MOVE.B      #0,curAdd
00001510                           961              
00001510                           962              ;Go find the register list
00001510  6100 0006                963              BSR         check
00001514                           964      
00001514                           965              
00001514                           966  absoluteAddressMOVEM:
00001514  544A                     967              ADDA.W      #2,A2
00001516                           968  
00001516  4E75                     969              RTS                     
00001518                           970                
00001518                           971  check:
00001518  0C38 0000 1009           972              CMP.B       #0,(totalCount)
0000151E  6700 001C                973              BEQ         findList
00001522                           974  
00001522  0C38 0008 1009           975              CMP.B       #8,(totalCount)
00001528  6700 0034                976              BEQ         findList2
0000152C                           977     
0000152C                           978              ;We go back to ListToMem which was our starting point
0000152C  0C38 0001 100C           979              CMP.B       #1,(curAdd)
00001532  6700 FF6C                980              BEQ         ListToMem2
00001536                           981               
00001536                           982              ;If we arrive here, we assume that we started in MemToList      
00001536  4283                     983              CLR.L      D3
00001538                           984              
00001538  6000 FCE4                985              BRA        update
0000153C                           986  
0000153C                           987  
0000153C                           988  findList:
0000153C                           989              ;Set up the temp register to the register list
0000153C  544B                     990              ADDA.W      #2,A3
0000153E                           991  
0000153E  3413                     992              MOVE.W      (A3),D2
00001540                           993  
00001540                           994              ;Clear some registers so we can have a counter
00001540                           995              ;and two registers to hold a beginning index and then ending index
00001540  4284                     996              CLR.L       D4
00001542  4285                     997              CLR.L       D5
00001544  4286                     998              CLR.L       D6
00001546  4287                     999              CLR.L       D7  ;Holds the actual value for manipulation
00001548                          1000              
00001548                          1001              ;Set D7 to indicate we are doing the first bit check
00001548  3E13                    1002              MOVE.W      (A3),D7
0000154A                          1003              
0000154A                          1004              
0000154A                          1005              ;===Setting Up Variables===            
0000154A                          1006              ;Indicate we are at the start of the word for our counter
0000154A  11FC 0000 1008          1007              MOVE.B      #0,counter
00001550                          1008              ;==========================
00001550                          1009              
00001550                          1010              ;The (dORa) variable changes because it must be the opposite of findList 
00001550  0C38 0004 100E          1011              CMP.B       #4,movemAdd
00001556  6700 0028               1012              BEQ         setA
0000155A                          1013              
0000155A  6000 001A               1014              BRA         setD
0000155E                          1015  
0000155E                          1016           
0000155E                          1017  findList2:           
0000155E  4287                    1018              CLR.L       D7
00001560  1E13                    1019              MOVE.B      (A3),D7
00001562                          1020              
00001562                          1021              ;===Setting Up Variables===
00001562                          1022              ;Indicate we are at the start of the word for our counter
00001562  11FC 0000 1008          1023              MOVE.B      #0,counter
00001568                          1024              ;==========================
00001568                          1025              
00001568                          1026              ;The (dORa) variable changes because it must be the opposite of findList            
00001568  0C38 0004 100E          1027              CMP.B       #4,movemAdd
0000156E  6700 0006               1028              BEQ         setD
00001572                          1029              
00001572  6000 000C               1030              BRA         setA
00001576                          1031             
00001576                          1032   
00001576                          1033  setD:
00001576  11FC 0000 100A          1034              MOVE.B      #0,dORa
0000157C                          1035              
0000157C                          1036              ;Go through a loop and rotate bits twice for the D registers
0000157C  6100 000C               1037              BSR         bitLoop
00001580                          1038   
00001580                          1039  setA:
00001580  11FC 0001 100A          1040              MOVE.B      #1,dORa
00001586                          1041              
00001586                          1042              ;Go through a loop and rotate bits twice for the D registers
00001586  6100 0002               1043              BSR         bitLoop
0000158A                          1044  
0000158A                          1045  bitLoop:
0000158A                          1046  
0000158A                          1047              ;If our counter is 8, then we must finish printing the list
0000158A  0C38 0008 1008          1048              CMP.B       #8,counter
00001590  6786                    1049              BEQ         check
00001592                          1050  
00001592  3407                    1051              MOVE.W      D7,D2
00001594                          1052              
00001594                          1053              ;We will use getBits to get the right-most bit (Stored in D2)
00001594  163C 0000               1054              MOVE.B      #0,D3  ;The starting index of the word
00001598  183C 0001               1055              MOVE.B      #1,D4  ;How many bits we want
0000159C                          1056  
0000159C  6100 FC9E               1057              BSR         getBits
000015A0                          1058              
000015A0                          1059              ;If the bit is 0, then that means we must print out some values
000015A0  B43C 0000               1060              CMP.B       #0,D2
000015A4  6700 0006               1061              BEQ         skipBit
000015A8                          1062  
000015A8  6100 000E               1063              BSR         printSingle
000015AC                          1064              
000015AC                          1065  skipBit:
000015AC                          1066              ;Increment the rest of our variables to set up the loop again
000015AC  5238 1008               1067              ADD.B       #1,counter
000015B0  5238 1009               1068              ADD.B       #1,totalCount
000015B4                          1069              
000015B4  E28F                    1070              LSR.L       #1,D7
000015B6                          1071              
000015B6  60D2                    1072              BRA         bitLoop
000015B8                          1073   
000015B8                          1074  
000015B8                          1075  printSingle:
000015B8                          1076              ;update number of registers included in the list
000015B8  5238 100F               1077              ADD.B       #1,listSize
000015BC                          1078              ;Check and see if we should print D or A
000015BC  0C38 0000 100A          1079              CMP.B       #0,(dORa)
000015C2  6700 000C               1080              BEQ         singleDReg
000015C6                          1081              
000015C6  0C38 0001 100A          1082              CMP.B       #1,(dORa)
000015CC  6700 0034               1083              BEQ         singleAReg
000015D0                          1084  
000015D0                          1085  singleDReg:
000015D0  0C38 0001 100F          1086              CMP.B       #1,listSize
000015D6  6700 0006               1087              BEQ         skipSlashD
000015DA                          1088         
000015DA  6100 005A               1089              BSR         pSlash
000015DE                          1090              
000015DE                          1091  skipSlashD:
000015DE  43F9 00001F16           1092              LEA         printDRD,A1
000015E4  103C 000E               1093              MOVE.B      #14,D0
000015E8  4E4F                    1094              TRAP        #15
000015EA                          1095  
000015EA                          1096              ;Print out the register number
000015EA  4281                    1097              CLR.L       D1
000015EC  1238 1008               1098              MOVE.B      (counter),D1
000015F0  103C 0003               1099              MOVE.B      #3,D0
000015F4  4E4F                    1100              TRAP        #15           
000015F6                          1101              
000015F6  5238 1008               1102              ADD.B       #1,counter
000015FA  5238 1009               1103              ADD.B       #1,totalCount
000015FE                          1104              
000015FE  E28F                    1105              LSR.L       #1,D7
00001600                          1106              
00001600  6088                    1107              BRA         bitLoop
00001602                          1108   
00001602                          1109  
00001602                          1110  
00001602                          1111  singleAReg:
00001602  0C38 0001 100F          1112              CMP.B       #1,listSize
00001608  6700 0006               1113              BEQ         skipSlashA
0000160C                          1114         
0000160C  6100 0028               1115              BSR         pSlash
00001610                          1116              
00001610                          1117  skipSlashA:
00001610  43F9 00001F18           1118              LEA         printARD,A1
00001616  103C 000E               1119              MOVE.B      #14,D0
0000161A  4E4F                    1120              TRAP        #15
0000161C                          1121  
0000161C                          1122              ;Print out the register number
0000161C  4281                    1123              CLR.L       D1
0000161E  1238 1008               1124              MOVE.B      (counter),D1
00001622  103C 0003               1125              MOVE.B      #3,D0
00001626  4E4F                    1126              TRAP        #15
00001628                          1127  
00001628  5238 1008               1128              ADD.B       #1,counter
0000162C  5238 1009               1129              ADD.B       #1,totalCount
00001630                          1130              
00001630  E28F                    1131              LSR.L       #1,D7
00001632                          1132              
00001632  6000 FF56               1133              BRA         bitLoop
00001636                          1134           
00001636                          1135  pSlash:
00001636  43F9 00001F33           1136              LEA         printSlash,A1
0000163C  103C 000E               1137              MOVE.B      #14,D0
00001640  4E4F                    1138              TRAP        #15
00001642                          1139              
00001642  4E75                    1140              RTS       
00001644                          1141          
00001644                          1142         
00001644                          1143  MLEA:
00001644  43F9 00001EB9           1144              LEA         printLEA,A1
0000164A  103C 000E               1145              MOVE.B      #14,D0
0000164E  4E4F                    1146              TRAP        #15
00001650                          1147              
00001650                          1148              ;*SOURCE*
00001650                          1149              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001650                          1150              ;D6 will contain mode & D7 will contain the register after this instruction
00001650  6100 0536               1151              BSR         isolateAddressBit0to5
00001654                          1152              
00001654                          1153              ;*Print source address*
00001654  6100 05E2               1154              BSR         addressModeSR
00001658                          1155              
00001658                          1156              ;Print comma after source address
00001658  43F9 00001F2F           1157              LEA         printComma,A1
0000165E  103C 000E               1158              MOVE.B      #14,D0
00001662  4E4F                    1159              TRAP        #15
00001664                          1160              
00001664                          1161              ;*DESTINATION*
00001664                          1162              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001664                          1163              ;D7 will contain the register after this instruction
00001664  6100 0548               1164              BSR         isolateRegisterBit9to11
00001668                          1165              
00001668                          1166              ;Save #%001 into D6 to specify address register mode
00001668  1C3C 0001               1167              MOVE.B      #1,D6
0000166C                          1168              
0000166C                          1169              
0000166C                          1170              ;*Print destination address*
0000166C  6100 05CA               1171              BSR         addressModeSR
00001670                          1172  
00001670  6000 FBAC               1173              BRA        update
00001674                          1174  
00001674                          1175  MNOT:
00001674                          1176              ;Distinguish NOT from "MOVE to SSR"                 
00001674                          1177              
00001674  4282                    1178              CLR.L      D2
00001676                          1179              ;Move the address into the register to check for size
00001676  3412                    1180              MOVE.W     (A2),D2
00001678                          1181              
00001678                          1182              ;Pass in parameters for isolating bits 6,7
00001678  163C 0006               1183              MOVE.B     #6,D3
0000167C  183C 0002               1184              MOVE.B     #2,D4
00001680                          1185              
00001680                          1186              ;Jump to getbits and return with isolated bits
00001680  6100 FBBA               1187              BSR        getbits
00001684                          1188  
00001684                          1189              ;This was meant for invalid opcode testing
00001684                          1190              ;CMP.B      #%11,D2
00001684                          1191              ;BRA        InOpCode     
00001684                          1192  
00001684  43F9 00001EC7           1193              LEA        printNOT,A1
0000168A  103C 000E               1194              MOVE.B     #14,D0
0000168E  4E4F                    1195              TRAP       #15    
00001690                          1196              
00001690                          1197              ;Jumps to printSizeSubroutine and returns after size has been printed
00001690  6100 0534               1198              BSR        printSizeSubroutine
00001694                          1199              
00001694                          1200              ;*SOURCE*
00001694                          1201              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001694                          1202              ;D6 will contain mode & D7 will contain the register after this instruction
00001694  6100 04F2               1203              BSR        isolateAddressBit0to5
00001698                          1204              
00001698                          1205              ;*Print source address*
00001698  6100 059E               1206              BSR        addressModeSR
0000169C                          1207              
0000169C  6000 FB80               1208              BRA        update 
000016A0                          1209  
000016A0                          1210  MJSR:
000016A0  43F9 00001EEC           1211              LEA        printJSR,A1
000016A6  103C 000E               1212              MOVE.B     #14,D0
000016AA  4E4F                    1213              TRAP       #15
000016AC                          1214              
000016AC                          1215              ;*SOURCE*
000016AC                          1216              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000016AC                          1217              ;D6 will contain mode & D7 will contain the register after this instruction
000016AC  6100 04DA               1218              BSR        isolateAddressBit0to5
000016B0                          1219              
000016B0                          1220              ;*Print source address*
000016B0  6100 0586               1221              BSR        addressModeSR
000016B4                          1222              
000016B4  6000 FB68               1223              BRA        update 
000016B8                          1224              
000016B8                          1225  
000016B8                          1226  *-----------------------------------------------------------
000016B8                          1227  * BRA,BLT,BGE,BEQ INSTRUCTIONS
000016B8                          1228  *-----------------------------------------------------------       
000016B8                          1229  M0110:
000016B8  4280                    1230              CLR.L       D0
000016BA  4281                    1231              CLR.L       D1
000016BC  4282                    1232              CLR.L       D2
000016BE  4283                    1233              CLR.L       D3
000016C0  4284                    1234              CLR.L       D4
000016C2                          1235        
000016C2                          1236              ;Moves the instruction into D2
000016C2  3412                    1237              MOVE.W     (A2),D2
000016C4                          1238              
000016C4                          1239              ;Setting up parameters for getBits - isolating bits 11-8
000016C4  163C 0008               1240              MOVE.B      #8,D3             ;Start bit index = 8
000016C8  183C 0004               1241              MOVE.B      #4,D4             ;Number of bits needed = 4
000016CC                          1242              
000016CC                          1243              ;calls getBits subroutine, D2 now has the four condition bits of the Bcc/BRA instruction. 
000016CC  6100 FB6E               1244              BSR         getBits
000016D0                          1245              
000016D0                          1246              ;If the condition bits are 0000, the instruction is a BRA instruction. 
000016D0  B4BC 00000000           1247              CMP.L       #%0000,D2
000016D6  6700 002A               1248              BEQ         MBRA
000016DA                          1249              
000016DA                          1250              ;0100 = BCC
000016DA  B4BC 00000004           1251              CMP.L       #%0100,D2
000016E0  6700 0030               1252              BEQ         MBCC
000016E4                          1253              
000016E4                          1254              ;1101 = BLT
000016E4  B4BC 0000000D           1255              CMP.L       #%1101,D2
000016EA  6700 0036               1256              BEQ         MBLT
000016EE                          1257              
000016EE                          1258              ;1100 = BGE
000016EE  B4BC 0000000C           1259              CMP.L       #%1100,D2
000016F4  6700 003C               1260              BEQ         MBGE
000016F8                          1261              
000016F8                          1262              ;0111 = BEQ
000016F8  B4BC 00000007           1263              CMP.L       #%0111,D2
000016FE  6700 0042               1264              BEQ         MBEQ
00001702                          1265  
00001702                          1266  MBRA:
00001702                          1267      ;condition bits (11-8) are 0000
00001702  43F9 00001EF5           1268              LEA         printBRA,A1
00001708  103C 000E               1269              MOVE.B      #14,D0
0000170C  4E4F                    1270              TRAP        #15
0000170E                          1271              
0000170E  6000 0042               1272              BRA         bccOffset
00001712                          1273  
00001712                          1274  MBCC:
00001712                          1275      ;condition bits (11-8) are 0100     
00001712  43F9 00001EE7           1276              LEA         printBCC,A1
00001718  103C 000E               1277              MOVE.B      #14,D0
0000171C  4E4F                    1278              TRAP        #15
0000171E                          1279  
0000171E  6000 0032               1280              BRA         bccOffset
00001722                          1281  
00001722                          1282  MBLT:
00001722                          1283      ;condition bits (11-8) are 1101
00001722  43F9 00001EDB           1284              LEA         printBLT,A1
00001728  103C 000E               1285              MOVE.B      #14,D0
0000172C  4E4F                    1286              TRAP        #15
0000172E                          1287              
0000172E  6000 0022               1288              BRA         bccOffset
00001732                          1289  
00001732                          1290  MBGE:
00001732                          1291      ;condition bits (11-8) are 1100
00001732  43F9 00001EDF           1292              LEA         printBGE,A1
00001738  103C 000E               1293              MOVE.B      #14,D0
0000173C  4E4F                    1294              TRAP        #15
0000173E                          1295              
0000173E  6000 0012               1296              BRA         bccOffset
00001742                          1297  
00001742                          1298  MBEQ:            
00001742                          1299      ;condition bits (11-8) are 0111
00001742  43F9 00001EE3           1300              LEA         printBEQ,A1
00001748  103C 000E               1301              MOVE.B      #14,D0
0000174C  4E4F                    1302              TRAP        #15
0000174E                          1303              
0000174E  6000 0002               1304              BRA         bccOffset         
00001752                          1305  
00001752                          1306  bccOffset:
00001752                          1307      ;each variation of Bcc, BLT, BEQ, BRA, etc has the same format for the offset bits. Bits 0-7 are either the offset themself, or
00001752                          1308      ;tell us where to look. If it contains $00, then 16-bit offset. If it contains $FF, 32-bit offset.
00001752                          1309      
00001752                          1310              ;Moves the branch family instruction into D2
00001752  3412                    1311              MOVE.W     (A2),D2
00001754                          1312              
00001754                          1313              ;Setting up parameters for getBits - isolating bits 0-7
00001754  163C 0000               1314              MOVE.B      #0,D3             ;Start bit index = 0
00001758  183C 0008               1315              MOVE.B      #8,D4             ;Number of bits needed = 8
0000175C                          1316  
0000175C                          1317              ;calls getBits subroutine, D2 now has the offset bits
0000175C  6100 FADE               1318              BSR         getBits
00001760                          1319              
00001760                          1320              ;If the offset bits are $00, we need to look at the next 16 bits for the offset.
00001760  B4BC 00000000           1321              CMP.L       #%00000000,D2
00001766  6700 0048               1322              BEQ         bit16Displacement
0000176A                          1323              
0000176A                          1324              ;If the offset bits are $FF, we need to look at the next 32 bits for the offset.
0000176A  B4BC 000000FF           1325              CMP.L       #%11111111,D2
00001770  6700 0080               1326              BEQ         bit32Displacement
00001774                          1327              
00001774                          1328              ;If neither of the above two cases are true, we continue to 8bitDisplacement. 
00001774                          1329              
00001774                          1330  bit8Displacement:
00001774                          1331              ;We're here if the 8-bit displacement isn't $00 or $FF, and D2 already has the offset bits.
00001774                          1332              ;D2 is a twos complement integer specifying the number of bytes between the branch instruction 
00001774                          1333              ;and the next instruction to be executed (if the condition is met) 
00001774                          1334              
00001774                          1335              ;A2 is the address of the current instruction we're working with
00001774  2C4A                    1336              MOVEA.L      A2,A6
00001776                          1337            
00001776  B43C 0080               1338              CMP.B       #$80,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
0000177A  6C00 000C               1339              BGE         sub8Bits
0000177E                          1340              
0000177E  6000 0002               1341              BRA         add8Bits
00001782                          1342  
00001782                          1343  add8Bits:
00001782  DCC2                    1344              ADD.W       D2,A6
00001784  6000 000C               1345              BRA         continue8Bits
00001788                          1346  sub8Bits:
00001788                          1347              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
00001788  4602                    1348              NOT.B       D2      ;inverts D2
0000178A  5302                    1349              SUB.B       #1, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000178C                          1350                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
0000178C  9CC2                    1351              SUB.W       D2,A6   
0000178E                          1352              
0000178E  6000 0002               1353              BRA         continue8Bits
00001792                          1354  
00001792                          1355  continue8Bits:
00001792                          1356              
00001792                          1357              ;Output $
00001792  43F9 00001F21           1358              LEA         printA,A1
00001798  103C 000E               1359              MOVE.B      #14,D0
0000179C  4E4F                    1360              TRAP        #15
0000179E                          1361              
0000179E                          1362              ;Output destination address
0000179E  7410                    1363              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
000017A0  700F                    1364              MOVE.L      #15,D0  ;task number
000017A2  220E                    1365              MOVE.L      A6,D1
000017A4  4E4F                    1366              TRAP        #15
000017A6                          1367              
000017A6  2C7C 00000000           1368              MOVE.L      #$0,A6
000017AC  6000 FA70               1369              BRA         update
000017B0                          1370  bit16Displacement:
000017B0                          1371              ;Getting the next 16 bits
000017B0  341A                    1372              MOVE.W      (A2)+,D2
000017B2  3412                    1373              MOVE.W      (A2),D2
000017B4  2C4A                    1374              MOVEA.L      A2,A6
000017B6                          1375            
000017B6  B4BC 00008000           1376              CMP.L       #$8000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000017BC  6C00 000C               1377              BGE         sub16Bits
000017C0                          1378              
000017C0  6000 0002               1379              BRA         add16Bits
000017C4                          1380  
000017C4                          1381              
000017C4                          1382  add16Bits: 
000017C4  DCC2                    1383              ADD.W       D2,A6
000017C6  6000 000C               1384              BRA         continue16Bits
000017CA                          1385  
000017CA                          1386  sub16Bits:  
000017CA                          1387              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
000017CA  4642                    1388              NOT.W       D2      ;inverts D2
000017CC  5742                    1389              SUB.W       #3, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
000017CE                          1390                                  ;account for the length of the instruction's opperation, which is 4 bytes, so we subtract 3.
000017CE  9CC2                    1391              SUB.W       D2,A6   
000017D0  6000 0002               1392              BRA         continue16Bits
000017D4                          1393              
000017D4                          1394  continue16Bits:
000017D4                          1395              ;Output $
000017D4  43F9 00001F21           1396              LEA         printA,A1
000017DA  103C 000E               1397              MOVE.B      #14,D0
000017DE  4E4F                    1398              TRAP        #15
000017E0                          1399              
000017E0                          1400              ;Output destination addres
000017E0  7410                    1401              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
000017E2  700F                    1402              MOVE.L      #15,D0  ;task number
000017E4  220E                    1403              MOVE.L      A6,D1
000017E6  4E4F                    1404              TRAP        #15
000017E8                          1405              
000017E8  2C7C 00000000           1406              MOVE.L      #$0,A6
000017EE  6000 FA2E               1407              BRA         update
000017F2                          1408              
000017F2                          1409  bit32Displacement:      ;Getting the next 32 bits
000017F2  241A                    1410              MOVE.L      (A2)+,D2
000017F4  2412                    1411              MOVE.L      (A2),D2
000017F6  2C4A                    1412              MOVEA.L     A2,A6
000017F8                          1413            
000017F8  B4BC 80000000           1414              CMP.L       #$80000000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000017FE  6C00 000C               1415              BGE         sub32Bits
00001802                          1416              
00001802  6000 0002               1417              BRA         add32Bits
00001806                          1418  
00001806                          1419  add32Bits:
00001806  DDC2                    1420              ADD.L       D2,A6
00001808  6000 000C               1421              BRA         continue32Bits
0000180C                          1422  
0000180C                          1423  sub32Bits:              ;If the displacement is negative, convert it into a regular value and subtract it from the address. 
0000180C  4682                    1424              NOT.L       D2      ;inverts D2
0000180E  5B82                    1425              SUB.L       #5,D2   ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
00001810                          1426                                  ;account for the length of the instruction's opperation, which is 6 bytes, so we subtract 5.
00001810  9DC2                    1427              SUB.L       D2,A6   
00001812  6000 0002               1428              BRA         continue32Bits
00001816                          1429  
00001816                          1430  continue32Bits:      
00001816                          1431              ;Output $
00001816  43F9 00001F21           1432              LEA         printA,A1
0000181C  103C 000E               1433              MOVE.B      #14,D0
00001820  4E4F                    1434              TRAP        #15
00001822                          1435              
00001822                          1436              ;Output destination addres
00001822  7410                    1437              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
00001824  700F                    1438              MOVE.L      #15,D0  ;task number
00001826  220E                    1439              MOVE.L      A6,D1
00001828  4E4F                    1440              TRAP        #15
0000182A                          1441        
0000182A  2C7C 00000000           1442              MOVE.L      #$0,A6      
00001830  6000 F9EC               1443              BRA         update
00001834                          1444  
00001834                          1445  *-----------------------------------------------------------
00001834                          1446  * DIVU INSTRUCTION
00001834                          1447  *-----------------------------------------------------------           
00001834                          1448  M1000:
00001834                          1449              
00001834  4282                    1450              CLR.L       D2
00001836  4283                    1451              CLR.L       D3
00001838                          1452              
00001838                          1453              ;Copy the address values into a register
00001838  3412                    1454              MOVE.W     (A2),D2
0000183A                          1455              
0000183A                          1456              ;Passing in parameters for isolating bits 6,7,8
0000183A  163C 0006               1457              MOVE.B      #6,D3             ;Start bit index = 6
0000183E  183C 0003               1458              MOVE.B      #3,D4             ;Number of bits needed = 3
00001842                          1459              
00001842                          1460              ;Jumps to getBits and returns with isolated bits in D2
00001842  6100 F9F8               1461              BSR         getBits
00001846                          1462              
00001846                          1463              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
00001846  B4BC 00000003           1464              CMP.L       #%011,D2
0000184C  6700 0002               1465              BEQ         continueDIVU
00001850                          1466              
00001850                          1467              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
00001850                          1468  
00001850                          1469  continueDIVU:
00001850                          1470  
00001850  43F9 00001EB1           1471              LEA         printDIVU,A1
00001856  103C 000E               1472              MOVE.B      #14,D0
0000185A  4E4F                    1473              TRAP        #15
0000185C                          1474              
0000185C  6000 02E2               1475              BRA         dnDest
00001860                          1476              
00001860                          1477              
00001860                          1478  *-----------------------------------------------------------
00001860                          1479  * SUB INSTRUCTION
00001860                          1480  *-----------------------------------------------------------  
00001860                          1481  M1001:
00001860  43F9 00001EA0           1482              LEA        printSUB,A1
00001866  103C 000E               1483              MOVE.B     #14,D0
0000186A  4E4F                    1484              TRAP       #15
0000186C                          1485              
0000186C  4202                    1486              CLR.B      D2
0000186E  4203                    1487              CLR.B      D3
00001870                          1488              
00001870                          1489              ;======Isolate Size (S) Bits=======
00001870                          1490              ;Copy the address values into a register
00001870  3412                    1491              MOVE.W     (A2),D2
00001872                          1492              
00001872                          1493              ;Passing in parameters for isolating size bits
00001872  163C 0006               1494              MOVE.B      #6,D3             ;Start bit index = 6
00001876  183C 0002               1495              MOVE.B      #2,D4             ;Number of bits needed = 2
0000187A                          1496              
0000187A                          1497              ;Jumps to getBits and returns with isolated bits in D2
0000187A  6100 F9C0               1498              BSR         getBits  
0000187E                          1499              
0000187E                          1500              ;Jumps to printSizeSubroutine and returns after size has been printed
0000187E  6100 0346               1501              BSR         printSizeSubroutine
00001882                          1502              
00001882                          1503              ;Let's store the size indicator since it will help us determine how many times
00001882                          1504              ;we have to iterate through addresses to print out the whole instruction
00001882                          1505              ;We will use A4 as the register to temporary store the size
00001882  3842                    1506              MOVE.W      D2,A4
00001884  11C2 2000               1507              MOVE.B      D2,$2000
00001888                          1508              
00001888                          1509              ;======Isolate direction (D) Bit=======
00001888                          1510              ; 0 = data register is destination | 1 = Dn is source
00001888  4282                    1511              CLR.L       D2
0000188A                          1512              
0000188A                          1513              ;Copy the address values into a register
0000188A  3412                    1514              MOVE.W      (A2),D2
0000188C                          1515              
0000188C                          1516              ;Passing in parameters for isolating direction bit
0000188C  163C 0008               1517              MOVE.B      #8,D3             ;Start bit index = 8
00001890  183C 0001               1518              MOVE.B      #1,D4             ;Number of bits needed = 1
00001894                          1519              
00001894                          1520              ;Jumps to getBits and returns with isolated bit in D2
00001894  6100 F9A6               1521              BSR         getBits
00001898                          1522              
00001898                          1523              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001898  B43C 0000               1524              CMP.B       #0,D2
0000189C  6700 02A2               1525              BEQ         dnDest
000018A0  6000 02C2               1526              BRA         dnSource
000018A4                          1527  
000018A4                          1528  
000018A4                          1529  *-----------------------------------------------------------
000018A4                          1530  * MULS,AND INSTRUCTIONS
000018A4                          1531  *-----------------------------------------------------------  
000018A4                          1532  M1100:      
000018A4  4282                    1533              CLR.L       D2
000018A6  4283                    1534              CLR.L       D3
000018A8                          1535              
000018A8                          1536              ;Copy the address values into a register
000018A8  3412                    1537              MOVE.W     (A2),D2
000018AA                          1538              
000018AA                          1539              ;Passing in parameters for isolating bits 6 and 7
000018AA  163C 0006               1540              MOVE.B      #6,D3             ;Start bit index = 6
000018AE  183C 0002               1541              MOVE.B      #2,D4             ;Number of bits needed = 2
000018B2                          1542              
000018B2                          1543              ;Jumps to getBits and returns with isolated bits in D2
000018B2  6100 F988               1544              BSR         getBits  
000018B6                          1545              
000018B6                          1546              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
000018B6  B43C 0003               1547              CMP.B       #%11,D2
000018BA  6700 0006               1548              BEQ         mulsCheck
000018BE  6000 0028               1549              BRA         MAND
000018C2                          1550              
000018C2                          1551  mulsCheck:
000018C2                          1552              ;Copy the address values into a register
000018C2  3412                    1553              MOVE.W     (A2),D2
000018C4                          1554              
000018C4                          1555              ;Passing in parameters for isolating bit 8
000018C4  163C 0008               1556              MOVE.B      #8,D3             ;Start bit index = 8
000018C8  183C 0001               1557              MOVE.B      #1,D4             ;Number of bits needed = 1
000018CC                          1558              
000018CC                          1559              ;Jumps to getBits and returns with isolated bits in D2
000018CC  6100 F96E               1560              BSR         getBits 
000018D0                          1561              
000018D0                          1562              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
000018D0  B43C 0001               1563              CMP.B       #1,D2
000018D4  6700 0002               1564              BEQ         MMULS
000018D8                          1565              
000018D8                          1566              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
000018D8                          1567  
000018D8                          1568              
000018D8                          1569              
000018D8                          1570              
000018D8                          1571  MMULS:
000018D8  43F9 00001EA9           1572              LEA         printMULS,A1
000018DE  103C 000E               1573              MOVE.B      #14,D0
000018E2  4E4F                    1574              TRAP        #15
000018E4                          1575              
000018E4  6000 025A               1576              BRA         dnDest 
000018E8                          1577  
000018E8                          1578  
000018E8                          1579  MAND:
000018E8  43F9 00001EBE           1580              LEA        printAND,A1
000018EE  103C 000E               1581              MOVE.B     #14,D0
000018F2  4E4F                    1582              TRAP       #15
000018F4                          1583              
000018F4                          1584              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
000018F4                          1585              ;Jumps to printSizeSubroutine and returns after size has been printed
000018F4  6100 02D0               1586              BSR         printSizeSubroutine
000018F8                          1587              
000018F8                          1588              ;save size bit in $2000 incase needed for immediate addressing
000018F8  11C2 2000               1589              MOVE.B      D2,$2000
000018FC                          1590              
000018FC                          1591              ;======Isolate direction (D) Bit=======
000018FC                          1592              ; 0 = data register is destination | 1 = Dn is source
000018FC  4282                    1593              CLR.L       D2
000018FE                          1594              
000018FE                          1595              ;Copy the address values into a register
000018FE  3412                    1596              MOVE.W      (A2),D2
00001900                          1597              
00001900                          1598              ;Passing in parameters for isolating direction bit
00001900  163C 0008               1599              MOVE.B      #8,D3           ;Start bit index = 8
00001904  183C 0001               1600              MOVE.B      #1,D4           ;Number of bits needed = 1
00001908                          1601  
00001908                          1602              ;Jumps to getBits and returns with isolated bit in D2
00001908  6100 F932               1603              BSR         getBits
0000190C                          1604              
0000190C                          1605              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
0000190C  B43C 0000               1606              CMP.B       #0,D2
00001910  6700 022E               1607              BEQ         dnDest
00001914  6000 024E               1608              BRA         dnSource
00001918                          1609              
00001918                          1610              
00001918  6000 F904               1611              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
0000191C                          1612     
0000191C                          1613     
0000191C                          1614  *-----------------------------------------------------------
0000191C                          1615  * LSL,LSR,ASL,ASR INSTRUCTIONS
0000191C                          1616  *-----------------------------------------------------------  
0000191C                          1617  ; Subroutine to enter when the instruction begins with 1110
0000191C                          1618  M1110:
0000191C  4282                    1619              CLR.L       D2
0000191E  4283                    1620              CLR.L       D3
00001920                          1621              
00001920                          1622              ;Let's first check and see if the opcode might be ROXd or ROd
00001920                          1623              ;since they share the same first 4 bits
00001920  3412                    1624              MOVE.W      (A2),D2
00001922                          1625              
00001922                          1626              ;Passing in parameters for isolating bits 9-11
00001922  163C 0009               1627              MOVE.B      #9,D3
00001926  183C 0003               1628              MOVE.B      #3,D4
0000192A                          1629              
0000192A                          1630              ;These next two checks help us know if we have the right opcode
0000192A  B43C 0002               1631              CMP.B       #%010,D2
0000192E  6700 F8D4               1632              BEQ         invalid
00001932                          1633              
00001932  B43C 0007               1634              CMP.B       #%111,D2
00001936  6700 F8CC               1635              BEQ         invalid
0000193A                          1636              
0000193A                          1637              ;Now that we know we have the right opcode, we can continue as normal
0000193A  4282                    1638              CLR.L       D2
0000193C  4283                    1639              CLR.L       D3
0000193E  4284                    1640              CLR.L       D4            
00001940                          1641              
00001940                          1642              ;Copy the address values into a register
00001940  3412                    1643              MOVE.W     (A2),D2
00001942                          1644              
00001942                          1645              ;Passing in parameters for isolating bits 6-7
00001942  163C 0006               1646              MOVE.B      #6,D3             ;Start bit index = 6
00001946  183C 0002               1647              MOVE.B      #2,D4             ;Number of bits needed = 2
0000194A                          1648              
0000194A                          1649              ;Jumps to getBits and returns with isolated bits in D2
0000194A  6100 F8F0               1650              BSR         getBits  
0000194E                          1651              
0000194E                          1652              ;Check if Memory Shift
0000194E  B43C 0003               1653              CMP.B       #%11,D2
00001952  6700 00BC               1654              BEQ         MemShift
00001956                          1655              
00001956                          1656              ;If not Memory Shift, is a Register Shift
00001956                          1657              
00001956                          1658              ;Copy the address values into a register
00001956  3412                    1659              MOVE.W     (A2),D2
00001958                          1660              
00001958                          1661              ;Passing in parameters for isolating bit 3
00001958  163C 0003               1662              MOVE.B      #3,D3             ;Start bit index = 3
0000195C  183C 0001               1663              MOVE.B      #1,D4             ;Number of bits needed = 1
00001960                          1664              
00001960                          1665              ;Jumps to getBits and returns with isolated bits in D2
00001960  6100 F8DA               1666              BSR         getBits  
00001964                          1667              
00001964                          1668              ;Checks if ASd
00001964  B43C 0000               1669              CMP.B       #%0,D2
00001968  6700 00EC               1670              BEQ         RegAS
0000196C                          1671              
0000196C                          1672              ;Checks if LSd
0000196C  B43C 0001               1673              CMP.B       #%1,D2
00001970  6700 00EC               1674              BEQ         RegLS
00001974                          1675  
00001974                          1676  ; Subroutine to enter if instruction is given data register to shift
00001974                          1677  RegShift      
00001974                          1678              ;Copy the address values into a register
00001974  3412                    1679              MOVE.W     (A2),D2
00001976                          1680              
00001976                          1681              ;Passing in parameters for isolating bits 6-7
00001976  163C 0006               1682              MOVE.B      #6,D3             ;Start bit index = 6
0000197A  183C 0002               1683              MOVE.B      #2,D4             ;Number of bits needed = 2
0000197E                          1684              
0000197E                          1685              ;Jumps to getBits and returns with isolated bits in D2
0000197E  6100 F8BC               1686              BSR         getBits  
00001982                          1687              
00001982                          1688              ;Print Size
00001982  6100 0242               1689              BSR         printSizeSubroutine
00001986                          1690              
00001986                          1691              ;Copy the address values into a register
00001986  3412                    1692              MOVE.W     (A2),D2
00001988                          1693              
00001988                          1694              ;Passing in parameters for isolating bit 5
00001988  163C 0005               1695              MOVE.B      #5,D3             ;Start bit index = 5
0000198C  183C 0001               1696              MOVE.B      #1,D4             ;Number of bits needed = 1
00001990                          1697              
00001990                          1698              ;Jumps to getBits and returns with isolated bits in D2
00001990  6100 F8AA               1699              BSR         getBits  
00001994                          1700              
00001994                          1701              ;Checks if shift count is immediate
00001994  B43C 0000               1702              CMP.B       #%0,D2
00001998  6700 003C               1703              BEQ         ImmediateCount
0000199C                          1704              
0000199C                          1705              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
0000199C                          1706              ;D7 will contain the register after this instruction
0000199C  6100 0210               1707              BSR         isolateRegisterBit9to11
000019A0                          1708              
000019A0                          1709              ;Save #%000 into D6 to specify data register mode
000019A0  1C3C 0000               1710              MOVE.B      #0,D6
000019A4                          1711              
000019A4                          1712              ;*Print Shift Count address*
000019A4  6100 0292               1713              BSR         addressModeSR
000019A8                          1714  
000019A8  6100 0002               1715              BSR         RegShift2
000019AC                          1716  
000019AC                          1717  
000019AC                          1718  ; Resumes printing data register shift instruction after printing AS or LS
000019AC                          1719  RegShift2   ;Print comma after shift count
000019AC  43F9 00001F2F           1720              LEA         printComma,A1
000019B2  103C 000E               1721              MOVE.B      #14,D0
000019B6  4E4F                    1722              TRAP        #15
000019B8                          1723              
000019B8                          1724              ;*Data Register to be Shifted*
000019B8  4282                    1725              CLR.L       D2
000019BA                          1726              
000019BA                          1727              ;Copy the address values into a register
000019BA  3412                    1728              MOVE.W      (A2),D2
000019BC                          1729              
000019BC                          1730              ;Passing in parameters for isolating bits 0-2
000019BC  163C 0000               1731              MOVE.B      #0,D3             ;Start bit index = 0
000019C0  183C 0003               1732              MOVE.B      #3,D4             ;Number of bits needed = 3
000019C4                          1733              
000019C4                          1734              ;Jumps to getBits and returns with isolated bits in D2
000019C4  6100 F876               1735              BSR         getBits
000019C8                          1736              
000019C8                          1737              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000019C8  1E02                    1738              MOVE.B      D2,D7
000019CA                          1739              
000019CA                          1740              ;Save #%000 into D6 to specify data register mode
000019CA  1C3C 0000               1741              MOVE.B      #0,D6
000019CE                          1742              
000019CE                          1743              ;*Prints data register to be shifted*
000019CE  6100 0268               1744              BSR         addressModeSR
000019D2                          1745  
000019D2  6000 F84A               1746              BRA         update
000019D6                          1747  
000019D6                          1748  ;Subroutine to enter if amount to shift is an immediate address            
000019D6                          1749  ImmediateCount
000019D6                          1750              ;Print #$
000019D6  43F9 00001F1F           1751              LEA        printIA,A1
000019DC  103C 000E               1752              MOVE.B     #14,D0
000019E0  4E4F                    1753              TRAP       #15
000019E2                          1754              
000019E2                          1755              ;*Data Register to be Shifted*
000019E2  4282                    1756              CLR.L       D2
000019E4                          1757              
000019E4                          1758              ;Copy the address values into a register
000019E4  3412                    1759              MOVE.W     (A2),D2
000019E6                          1760              
000019E6                          1761              ;Passing in parameters for isolating bits 9-11
000019E6  163C 0009               1762              MOVE.B      #9,D3             ;Start bit index = 9
000019EA  183C 0003               1763              MOVE.B      #3,D4             ;Number of bits needed = 3
000019EE                          1764              
000019EE                          1765              ;Jumps to getBits and returns with isolated bits in D2
000019EE  6100 F84C               1766              BSR         getBits  
000019F2                          1767              
000019F2                          1768              ;Check if shift count is 8
000019F2  B43C 0000               1769              CMP.B       #%000,D2
000019F6  6700 0010               1770              BEQ         ShiftEight
000019FA                          1771              
000019FA  2202                    1772              MOVE.L      D2, D1
000019FC  6100 0002               1773              BSR         ImmediateCount2
00001A00                          1774  ;Subroutine to print shift count           
00001A00                          1775  ImmediateCount2
00001A00                          1776              ;Print shift count
00001A00  103C 0003               1777              MOVE.B      #3,D0
00001A04  4E4F                    1778              TRAP        #15
00001A06  61A4                    1779              BSR         RegShift2
00001A08                          1780  ;Subroutine to enter if shift count is 8
00001A08                          1781  ShiftEight  
00001A08  4281                    1782              CLR.L       D1
00001A0A                          1783              
00001A0A                          1784              ;Move 8 into D1    
00001A0A  123C 0008               1785              MOVE.B      #8, D1
00001A0E  61F0                    1786              BSR         ImmediateCount2
00001A10                          1787              
00001A10                          1788  ; Subroutine to enter when the instruction is given a memory address to shift                         
00001A10                          1789  MemShift
00001A10                          1790              ;Copy the address values into a register
00001A10  3412                    1791              MOVE.W     (A2),D2
00001A12                          1792              
00001A12                          1793              ;Passing in parameters for isolating bit 9
00001A12  163C 0009               1794              MOVE.B      #9,D3             ;Start bit index = 9
00001A16  183C 0001               1795              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A1A                          1796              
00001A1A                          1797              ;Jumps to getBits and returns with isolated bits in D2
00001A1A  6100 F820               1798              BSR         getBits  
00001A1E                          1799              
00001A1E                          1800              ;Checks if ASd
00001A1E  B43C 0000               1801              CMP.B       #%0,D2
00001A22  6700 0022               1802              BEQ         MemAS
00001A26                          1803              
00001A26                          1804              ;Checks if LSd
00001A26  B43C 0001               1805              CMP.B       #%1,D2
00001A2A  6700 0022               1806              BEQ         MemLS
00001A2E                          1807              
00001A2E                          1808  ; Continues memory address shift after printing AS or LS
00001A2E                          1809  MemShift2   
00001A2E                          1810              ;Print Space
00001A2E  43F9 00001F31           1811              LEA        printSpace,A1
00001A34  103C 000E               1812              MOVE.B     #14,D0
00001A38  4E4F                    1813              TRAP       #15
00001A3A                          1814              
00001A3A                          1815              ;*Memory Address*
00001A3A                          1816              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001A3A                          1817              ;D6 will contain mode & D7 will contain the register after this instruction
00001A3A  6100 014C               1818              BSR         isolateAddressBit0to5
00001A3E                          1819              
00001A3E                          1820              ;*Print source address*
00001A3E  6100 01F8               1821              BSR         addressModeSR
00001A42                          1822              
00001A42  6000 F7DA               1823              BRA         update
00001A46                          1824  
00001A46                          1825  MemAS       ;Print AS
00001A46  6100 002C               1826              BSR         MAS      
00001A4A  6100 0036               1827              BSR         MemDirectionSubroutine                
00001A4E                          1828  
00001A4E                          1829              
00001A4E                          1830  MemLS       ;Print LS
00001A4E  6100 0016               1831              BSR         MLS      
00001A52  6100 002E               1832              BSR         MemDirectionSubroutine
00001A56                          1833              
00001A56                          1834  RegAS       ;Print AS
00001A56  6100 001C               1835              BSR         MAS      
00001A5A  6100 0062               1836              BSR         RegDirectionSubroutine                
00001A5E                          1837  
00001A5E                          1838  RegLS       ;Print LS
00001A5E  6100 0006               1839              BSR         MLS      
00001A62  6100 005A               1840              BSR         RegDirectionSubroutine
00001A66                          1841  
00001A66                          1842  ; Prints LS
00001A66                          1843  MLS:
00001A66  43F9 00001EFC           1844              LEA        printMLS,A1
00001A6C  103C 000E               1845              MOVE.B     #14,D0
00001A70  4E4F                    1846              TRAP       #15
00001A72  4E75                    1847              RTS
00001A74                          1848  ; Prints AS
00001A74                          1849  MAS:
00001A74  43F9 00001EF9           1850              LEA        printMAS,A1
00001A7A  103C 000E               1851              MOVE.B     #14,D0
00001A7E  4E4F                    1852              TRAP       #15
00001A80  4E75                    1853              RTS
00001A82                          1854  
00001A82                          1855  ;Subroutine for the direction if shifting a memory address
00001A82                          1856  MemDirectionSubroutine
00001A82                          1857              ;Copy the address values into a register
00001A82  3412                    1858              MOVE.W     (A2),D2
00001A84                          1859              
00001A84                          1860              ;Passing in parameters for isolating bit 8
00001A84  163C 0008               1861              MOVE.B      #8,D3             ;Start bit index = 8
00001A88  183C 0001               1862              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A8C                          1863              
00001A8C                          1864              ;Jumps to getBits and returns with isolated bits in D2
00001A8C  6100 F7AE               1865              BSR         getBits  
00001A90                          1866              
00001A90                          1867              ;Checks if Right
00001A90  B43C 0000               1868              CMP.B       #%0,D2
00001A94  6700 000A               1869              BEQ         MR
00001A98                          1870              
00001A98                          1871              ;Checks if Left
00001A98  B43C 0001               1872              CMP.B       #%1,D2
00001A9C  6700 0010               1873              BEQ         ML
00001AA0                          1874                          
00001AA0  43F9 00001F01           1875  MR          LEA        printR,A1
00001AA6  103C 000E               1876              MOVE.B     #14,D0
00001AAA  4E4F                    1877              TRAP       #15
00001AAC  6180                    1878              BSR        MemShift2
00001AAE                          1879  
00001AAE  43F9 00001EFF           1880  ML          LEA        printL,A1
00001AB4  103C 000E               1881              MOVE.B     #14,D0
00001AB8  4E4F                    1882              TRAP       #15
00001ABA  6100 FF72               1883              BSR        MemShift2
00001ABE                          1884  
00001ABE                          1885  ;Subroutine for the direction if shifting a data register        
00001ABE                          1886  RegDirectionSubroutine
00001ABE                          1887              ;Copy the address values into a register
00001ABE  3412                    1888              MOVE.W     (A2),D2
00001AC0                          1889              
00001AC0                          1890              ;Passing in parameters for isolating bit 8
00001AC0  163C 0008               1891              MOVE.B      #8,D3             ;Start bit index = 8
00001AC4  183C 0001               1892              MOVE.B      #1,D4             ;Number of bits needed = 1
00001AC8                          1893              
00001AC8                          1894              ;Jumps to getBits and returns with isolated bits in D2
00001AC8  6100 F772               1895              BSR         getBits  
00001ACC                          1896              
00001ACC                          1897              ;Checks if Right
00001ACC  B43C 0000               1898              CMP.B       #%0,D2
00001AD0  6700 000A               1899              BEQ         RR
00001AD4                          1900              
00001AD4                          1901              ;Checks if Left
00001AD4  B43C 0001               1902              CMP.B       #%1,D2
00001AD8  6700 0012               1903              BEQ         RL
00001ADC                          1904                          
00001ADC  43F9 00001F01           1905  RR          LEA        printR,A1
00001AE2  103C 000E               1906              MOVE.B     #14,D0
00001AE6  4E4F                    1907              TRAP       #15
00001AE8  6100 FE8A               1908              BSR        RegShift
00001AEC                          1909  
00001AEC  43F9 00001EFF           1910  RL          LEA        printL,A1
00001AF2  103C 000E               1911              MOVE.B     #14,D0
00001AF6  4E4F                    1912              TRAP       #15
00001AF8  6100 FE7A               1913              BSR        RegShift
00001AFC                          1914  
00001AFC                          1915  
00001AFC                          1916  *-----------------------------------------------------------------------
00001AFC                          1917  *-----------------------------------------------------------------------
00001AFC                          1918  *-----------------------------------------------------------------------
00001AFC                          1919  
00001AFC                          1920  
00001AFC                          1921  ;ADD
00001AFC                          1922  M1101:
00001AFC  43F9 00001E97           1923              LEA        printADD,A1
00001B02  103C 000E               1924              MOVE.B     #14,D0
00001B06  4E4F                    1925              TRAP       #15
00001B08                          1926              
00001B08  4202                    1927              CLR.B      D2
00001B0A  4203                    1928              CLR.B      D3
00001B0C                          1929              
00001B0C                          1930              ;======Isolate Size (S) Bits=======
00001B0C                          1931              ;Copy the address values into a register
00001B0C  3412                    1932              MOVE.W     (A2),D2
00001B0E                          1933              
00001B0E                          1934              ;Passing in parameters for isolating size bits
00001B0E  163C 0006               1935              MOVE.B      #6,D3             ;Start bit index = 6
00001B12  183C 0002               1936              MOVE.B      #2,D4             ;Number of bits needed = 2
00001B16                          1937              
00001B16                          1938              ;Jumps to getBits and returns with isolated bits in D2
00001B16  6100 F724               1939              BSR         getBits  
00001B1A                          1940              
00001B1A                          1941              ;Jumps to printSizeSubroutine and returns after size has been printed
00001B1A  6100 00AA               1942              BSR         printSizeSubroutine
00001B1E                          1943         
00001B1E                          1944              ;Let's store the size indicator since it will help us determine how many times
00001B1E                          1945              ;we have to iterate through addresses to print out the whole instruction
00001B1E                          1946              ;We will use A4 as the register to temporary store the size
00001B1E  3842                    1947              MOVE.W      D2,A4
00001B20  11C2 2000               1948              MOVE.B      D2,$2000
00001B24                          1949              
00001B24                          1950              ;======Isolate direction (D) Bit=======
00001B24                          1951              ; 0 = data register is destination | 1 = Dn is source
00001B24  4282                    1952              CLR.L       D2
00001B26                          1953              
00001B26                          1954              ;Copy the address values into a register
00001B26  3412                    1955              MOVE.W      (A2),D2
00001B28                          1956              
00001B28                          1957              ;Passing in parameters for isolating direction bit
00001B28  163C 0008               1958              MOVE.B      #8,D3             ;Start bit index = 8
00001B2C  183C 0001               1959              MOVE.B      #1,D4             ;Number of bits needed = 1
00001B30                          1960              
00001B30                          1961              ;Jumps to getBits and returns with isolated bit in D2
00001B30  6100 F70A               1962              BSR         getBits
00001B34                          1963              
00001B34                          1964              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001B34  B43C 0000               1965              CMP.B       #0,D2
00001B38  6700 0006               1966              BEQ         dnDest
00001B3C  6000 0026               1967              BRA         dnSource
00001B40                          1968              
00001B40                          1969  
00001B40                          1970  *-----------------------------------------------------------------
00001B40                          1971  * dnDest, dnSource, & other subroutines for isolating address bits
00001B40                          1972  *-----------------------------------------------------------------
00001B40                          1973  ;* dnDest,dnSource *
00001B40                          1974  ;For: MULS,AND,ADD,SUB,DIVU
00001B40                          1975  ;Used by instructions that require Dn as one of their addressing modes.
00001B40                          1976  ;dnDest isolates the addressing bits with Dn being the destination address
00001B40                          1977  ;dnSource isolates the addressing bits with Dn being the source address
00001B40                          1978  
00001B40                          1979  dnDest:
00001B40                          1980              ;**Used for isolating addressing bits when Dn is the destination**
00001B40                          1981              
00001B40                          1982              ;*SOURCE*
00001B40                          1983              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B40                          1984              ;D6 will contain mode & D7 will contain the register after this instruction
00001B40  6100 0046               1985              BSR         isolateAddressBit0to5
00001B44                          1986              
00001B44                          1987              ;*Print source address*
00001B44  6100 00F2               1988              BSR         addressModeSR
00001B48                          1989              
00001B48                          1990              ;Print comma after source address
00001B48  43F9 00001F2F           1991              LEA         printComma,A1
00001B4E  103C 000E               1992              MOVE.B      #14,D0
00001B52  4E4F                    1993              TRAP        #15
00001B54                          1994              
00001B54                          1995              ;*DESTINATION*
00001B54                          1996              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B54                          1997              ;D7 will contain the register after this instruction
00001B54  6100 0058               1998              BSR         isolateRegisterBit9to11
00001B58                          1999              
00001B58                          2000              ;Save #%000 into D6 to specify data register mode
00001B58  1C3C 0000               2001              MOVE.B      #0,D6
00001B5C                          2002              
00001B5C                          2003              ;*Print destination address*
00001B5C  6100 00DA               2004              BSR         addressModeSR
00001B60                          2005  
00001B60  6000 F6BC               2006              BRA         update
00001B64                          2007              
00001B64                          2008  dnSource:
00001B64                          2009              ;**Used for isolating addressing bits when Dn is the destination**
00001B64                          2010                          
00001B64                          2011              ;*SOURCE*
00001B64                          2012              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B64                          2013              ;D7 will contain the register after this instruction
00001B64  6100 0048               2014              BSR         isolateRegisterBit9to11
00001B68                          2015              
00001B68                          2016              ;Save #%000 into D6 to specify data register mode
00001B68  1C3C 0000               2017              MOVE.B      #0,D6
00001B6C                          2018              
00001B6C                          2019              ;*Print Source address*
00001B6C  6100 00CA               2020              BSR         addressModeSR
00001B70                          2021              
00001B70                          2022              ;Print comma after source address
00001B70  43F9 00001F2F           2023              LEA         printComma,A1
00001B76  103C 000E               2024              MOVE.B      #14,D0
00001B7A  4E4F                    2025              TRAP        #15
00001B7C                          2026              
00001B7C                          2027              ;*DESTINATION*
00001B7C                          2028              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B7C                          2029              ;D6 will contain mode & D7 will contain the register after this instruction
00001B7C  6100 000A               2030              BSR         isolateAddressBit0to5
00001B80                          2031              
00001B80                          2032              ;*Print destination address*
00001B80  6100 00B6               2033              BSR         addressModeSR
00001B84                          2034  
00001B84  6000 F698               2035              BRA         update
00001B88                          2036                     
00001B88                          2037  isolateAddressBit0to5:
00001B88                          2038  ;Helper subroutine for isolating the address stored within bits 0-5
00001B88                          2039  ;Stores address mode in D6
00001B88                          2040  ;Stores address register in D7
00001B88                          2041  
00001B88                          2042              ;======Isolate Effective Address Mode (M) Bits=======
00001B88  4282                    2043              CLR.L       D2
00001B8A                          2044              
00001B8A                          2045              ;Copy the address values into a register
00001B8A  3412                    2046              MOVE.W      (A2),D2
00001B8C                          2047              
00001B8C                          2048              ;Passing in parameters for isolating Mode bits
00001B8C  163C 0003               2049              MOVE.B      #3,D3             ;Start bit index = 3
00001B90  183C 0003               2050              MOVE.B      #3,D4             ;Number of bits needed = 3
00001B94                          2051              
00001B94                          2052              ;Jumps to getBits and returns with isolated bits in D2
00001B94  4EB8 123C               2053              JSR         getBits
00001B98                          2054              
00001B98                          2055              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001B98  1C02                    2056              MOVE.B      D2,D6
00001B9A                          2057              
00001B9A                          2058                       
00001B9A                          2059              ;======Isolate Effective Address Register (Xn) Bits=======
00001B9A  4282                    2060              CLR.L       D2
00001B9C                          2061              
00001B9C                          2062              ;Copy the address values into a register
00001B9C  3412                    2063              MOVE.W      (A2),D2
00001B9E                          2064              
00001B9E                          2065              ;Passing in parameters for isolating Xn bits
00001B9E  163C 0000               2066              MOVE.B      #0,D3             ;Start bit index = 0
00001BA2  183C 0003               2067              MOVE.B      #3,D4             ;Number of bits needed = 3
00001BA6                          2068              
00001BA6                          2069              ;Jumps to getBits and returns with isolated bits in D2
00001BA6  6100 F694               2070              BSR         getBits
00001BAA                          2071              
00001BAA                          2072              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001BAA  1E02                    2073              MOVE.B      D2,D7
00001BAC                          2074              
00001BAC  4E75                    2075              RTS
00001BAE                          2076  
00001BAE                          2077  isolateRegisterBit9to11:
00001BAE                          2078  ;Helper subroutine for isolating the register stored within bits 9-11
00001BAE                          2079  ;Stores the address register in D7
00001BAE                          2080  
00001BAE                          2081              ;======Isolate Register Bits=======
00001BAE  4282                    2082              CLR.L       D2
00001BB0  4286                    2083              CLR.L       D6
00001BB2  4287                    2084              CLR.L       D7
00001BB4                          2085              
00001BB4                          2086              ;Copy the address values into a register
00001BB4  3412                    2087              MOVE.W      (A2),D2
00001BB6                          2088              
00001BB6                          2089              ;Passing in parameters for isolating register bits
00001BB6  163C 0009               2090              MOVE.B      #9,D3             ;Start bit index = 9
00001BBA  183C 0003               2091              MOVE.B      #3,D4             ;Number of bits needed = 3
00001BBE                          2092              
00001BBE                          2093              ;Jumps to getBits and returns with isolated bit in D2
00001BBE  6100 F67C               2094              BSR         getBits
00001BC2                          2095              
00001BC2                          2096              ;Save register bit into ***D7*** for later use in addressModeSR
00001BC2  1E02                    2097              MOVE.B      D2,D7
00001BC4                          2098  
00001BC4  4E75                    2099              RTS
00001BC6                          2100              
00001BC6                          2101  *-----------------------------------------------------------
00001BC6                          2102  * Print Sizes
00001BC6                          2103  *-----------------------------------------------------------
00001BC6                          2104  printSizeSubroutine:
00001BC6                          2105              ;Prints the apporpriate size
00001BC6                          2106              ;PARAMETER:
00001BC6                          2107              ;D2 = the size bits
00001BC6                          2108              
00001BC6                          2109              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
00001BC6  B63C 0001               2110              CMP.B      #1,D3
00001BCA  6700 001A               2111              BEQ        printMOVESize
00001BCE                          2112              
00001BCE                          2113              ;Compare to which size is being moved for the opcode
00001BCE  B43C 0000               2114              CMP.B      #%00,D2
00001BD2  6700 003A               2115              BEQ        PByte
00001BD6                          2116              
00001BD6  B43C 0001               2117              CMP.B      #%01,D2
00001BDA  6700 0040               2118              BEQ        PWord
00001BDE                          2119              
00001BDE  B43C 0002               2120              CMP.B      #%10,D2
00001BE2  6700 0046               2121              BEQ        PLong
00001BE6                          2122           
00001BE6                          2123  printMOVESize:
00001BE6                          2124              ;Now that we know we have a MOVE opcode
00001BE6                          2125              ;Compare to which size is being moved for the opcode
00001BE6  B43C 0001               2126              CMP.B      #%01,D2
00001BEA  6700 0022               2127              BEQ        PByte
00001BEE                          2128  
00001BEE  B43C 0003               2129              CMP.B      #%11,D2
00001BF2  6700 0028               2130              BEQ        PWord            
00001BF6                          2131    
00001BF6  B43C 0002               2132              CMP.B      #%10,D2
00001BFA  6700 002E               2133              BEQ        PLong
00001BFE                          2134              
00001BFE                          2135  printMOVEMSize:
00001BFE                          2136              ;Now that we know we have a MOVEM opcode
00001BFE                          2137              ;Compare to which size is being moved for the opcode
00001BFE  B43C 0000               2138              CMP.B      #%0,D2
00001C02  6700 0018               2139              BEQ        PWord
00001C06                          2140              
00001C06  B43C 0001               2141              CMP.B      #%1,D2
00001C0A  6700 001E               2142              BEQ        PLong
00001C0E                          2143  
00001C0E                          2144  PByte:
00001C0E  43F9 00001F03           2145              LEA        printSIZEB,A1
00001C14  103C 000E               2146              MOVE.B     #14,D0
00001C18  4E4F                    2147              TRAP       #15
00001C1A                          2148              
00001C1A  4E75                    2149              RTS
00001C1C                          2150  PWord:
00001C1C  43F9 00001F08           2151              LEA        printSIZEW,A1
00001C22  103C 000E               2152              MOVE.B     #14,D0
00001C26  4E4F                    2153              TRAP       #15
00001C28                          2154              
00001C28  4E75                    2155              RTS
00001C2A                          2156  PLong:            
00001C2A  43F9 00001F0E           2157              LEA        printSIZEL,A1
00001C30  103C 000E               2158              MOVE.B     #14,D0
00001C34  4E4F                    2159              TRAP       #15
00001C36                          2160              
00001C36  4E75                    2161              RTS
00001C38                          2162              
00001C38                          2163  *-----------------------------------------------------------
00001C38                          2164  * Addressing Mode Implementation
00001C38                          2165  *-----------------------------------------------------------
00001C38                          2166  addressModeSR:
00001C38                          2167              ;Prints address according to the parameters passed in
00001C38                          2168              ;PARAMETERS:
00001C38                          2169              ;D6 = mode
00001C38                          2170              ;D7 = register
00001C38                          2171  
00001C38                          2172              ;Data register direct
00001C38  BC3C 0000               2173              CMP.B       #%000,D6
00001C3C  6700 002A               2174              BEQ         DRD
00001C40                          2175              
00001C40                          2176              ;Address register direct
00001C40  BC3C 0001               2177              CMP.B       #%001,D6
00001C44  6700 0036               2178              BEQ         ARD
00001C48                          2179              
00001C48                          2180              ;Address register indirect
00001C48  BC3C 0002               2181              CMP.B       #%010,D6
00001C4C  6700 0042               2182              BEQ         ARI
00001C50                          2183              
00001C50                          2184              ;Post Increment
00001C50  BC3C 0003               2185              CMP.B       #%011,D6
00001C54  6700 005A               2186              BEQ         PI
00001C58                          2187              
00001C58                          2188              ;Pre Decrement
00001C58  BC3C 0004               2189              CMP.B       #%100,D6
00001C5C  6700 0072               2190              BEQ         PD
00001C60                          2191              
00001C60                          2192              ;Immediate/Absolute Addressing
00001C60  BC3C 0007               2193              CMP.B       #%111,D6
00001C64  6700 008A               2194              BEQ         otherModes
00001C68                          2195  DRD:
00001C68                          2196              ;Print D __
00001C68  43F9 00001F16           2197              LEA         printDRD,A1
00001C6E  103C 000E               2198              MOVE.B      #14,D0
00001C72  4E4F                    2199              TRAP        #15
00001C74                          2200              
00001C74                          2201              ;Print register number
00001C74  7003                    2202              MOVE.L      #3,D0
00001C76  2207                    2203              MOVE.L      D7,D1
00001C78  4E4F                    2204              TRAP        #15
00001C7A                          2205              
00001C7A  4E75                    2206              RTS
00001C7C                          2207  ARD:
00001C7C                          2208              ;Print A __
00001C7C  43F9 00001F18           2209              LEA         printARD,A1
00001C82  103C 000E               2210              MOVE.B      #14,D0
00001C86  4E4F                    2211              TRAP        #15
00001C88                          2212              
00001C88                          2213              ;Print register number
00001C88  7003                    2214              MOVE.L      #3,D0
00001C8A  2207                    2215              MOVE.L      D7,D1
00001C8C  4E4F                    2216              TRAP        #15
00001C8E                          2217              
00001C8E  4E75                    2218              RTS
00001C90                          2219  ARI:
00001C90                          2220              ;Print (A __ )
00001C90  43F9 00001F1A           2221              LEA         printARI,A1
00001C96  103C 000E               2222              MOVE.B      #14,D0
00001C9A  4E4F                    2223              TRAP        #15
00001C9C                          2224              
00001C9C                          2225              ;Print register number
00001C9C  7003                    2226              MOVE.L      #3,D0
00001C9E  2207                    2227              MOVE.L      D7,D1
00001CA0  4E4F                    2228              TRAP        #15
00001CA2                          2229              
00001CA2                          2230              ;Print closing ')'
00001CA2  43F9 00001F1D           2231              LEA         printARI2,A1
00001CA8  103C 000E               2232              MOVE.B      #14,D0
00001CAC  4E4F                    2233              TRAP        #15
00001CAE                          2234              
00001CAE  4E75                    2235              RTS
00001CB0                          2236  PI:
00001CB0                          2237              ;Print (A __)+
00001CB0  43F9 00001F23           2238              LEA         printPI,A1
00001CB6  103C 000E               2239              MOVE.B      #14,D0
00001CBA  4E4F                    2240              TRAP        #15
00001CBC                          2241              
00001CBC                          2242              ;Print register number
00001CBC  7003                    2243              MOVE.L      #3,D0
00001CBE  2207                    2244              MOVE.L      D7,D1
00001CC0  4E4F                    2245              TRAP        #15
00001CC2                          2246              
00001CC2                          2247              ;Print closing ')+'
00001CC2  43F9 00001F26           2248              LEA         printPI2,A1
00001CC8  103C 000E               2249              MOVE.B      #14,D0
00001CCC  4E4F                    2250              TRAP        #15
00001CCE                          2251              
00001CCE  4E75                    2252              RTS
00001CD0                          2253  PD:
00001CD0                          2254              ;Print -(A __)
00001CD0  43F9 00001F29           2255              LEA         printPD,A1
00001CD6  103C 000E               2256              MOVE.B      #14,D0
00001CDA  4E4F                    2257              TRAP        #15
00001CDC                          2258              
00001CDC                          2259              ;Print register number
00001CDC  7003                    2260              MOVE.L      #3,D0
00001CDE  2207                    2261              MOVE.L      D7,D1
00001CE0  4E4F                    2262              TRAP        #15
00001CE2                          2263              
00001CE2                          2264              ;Print closing ')'
00001CE2  43F9 00001F2D           2265              LEA         printPD2,A1
00001CE8  103C 000E               2266              MOVE.B      #14,D0
00001CEC  4E4F                    2267              TRAP        #15
00001CEE                          2268              
00001CEE  4E75                    2269              RTS
00001CF0                          2270  
00001CF0                          2271  otherModes:
00001CF0  B4CE                    2272              CMP.W       A6,A2
00001CF2                          2273              
00001CF2  6D00 0004               2274              BLT         SKIPCOPY  
00001CF6                          2275  
00001CF6                          2276               *=====Important step for making sure we have access to where A2 orignally points=====*
00001CF6  2C4A                    2277              MOVEA.L     A2,A6 
00001CF8                          2278  
00001CF8                          2279  
00001CF8                          2280  SKIPCOPY:            
00001CF8                          2281              
00001CF8                          2282              ;Branch to Immediate if register bits are %100       
00001CF8  BE3C 0004               2283              CMP.B       #%100,D7
00001CFC  6700 0006               2284              BEQ         Immediate
00001D00                          2285              
00001D00                          2286              ;Otherwise, branch to Absolute
00001D00  6000 0022               2287              BRA         Absolute
00001D04                          2288              
00001D04                          2289          
00001D04                          2290                     
00001D04                          2291  Immediate:
00001D04                          2292              ;Print #
00001D04  43F9 00001F1F           2293              LEA         printIA,A1
00001D0A  103C 000E               2294              MOVE.B      #14,D0
00001D0E  4E4F                    2295              TRAP        #15
00001D10                          2296              
00001D10                          2297              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001D10                          2298              ;We will be able to access the contents of either size B or W
00001D10  544E                    2299              ADDA.W      #2,A6         
00001D12                          2300  
00001D12                          2301              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
00001D12  0C38 0002 2000          2302              CMP.B       #%10,$2000
00001D18  6700 0048               2303              BEQ         IMDLong
00001D1C                          2304              
00001D1C                          2305              ;If we don't branch, then we assume we're printing out a byte or word      
00001D1C  7003                    2306              MOVE.L      #3,D0
00001D1E  3216                    2307              MOVE.W      (A6),D1
00001D20  4E4F                    2308              TRAP        #15
00001D22                          2309              
00001D22  4E75                    2310              RTS
00001D24                          2311              
00001D24                          2312              
00001D24                          2313              
00001D24                          2314  Absolute:
00001D24                          2315              ;Print $
00001D24  43F9 00001F21           2316              LEA         printA,A1
00001D2A  103C 000E               2317              MOVE.B      #14,D0
00001D2E  4E4F                    2318              TRAP        #15
00001D30                          2319              
00001D30                          2320              ;Point to the next word (contains memory address)
00001D30  544E                    2321              ADDA.W      #2,A6
00001D32                          2322              
00001D32                          2323              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
00001D32  BE3C 0001               2324              CMP.B       #%001,D7
00001D36  6700 0012               2325              BEQ         AbsLong
00001D3A                          2326              
00001D3A                          2327              ;Print out the value in the address if it's a word
00001D3A  4281                    2328              CLR.L       D1
00001D3C                          2329              
00001D3C  303C 000F               2330              MOVE.W      #15,D0
00001D40  343C 0010               2331              MOVE.W      #16,D2
00001D44  3216                    2332              MOVE.W      (A6),D1
00001D46  4E4F                    2333              TRAP        #15
00001D48                          2334              
00001D48  4E75                    2335              RTS
00001D4A                          2336              
00001D4A                          2337  AbsLong:            
00001D4A                          2338              ;Place the current value into a temp register
00001D4A  3816                    2339              MOVE.W      (A6),D4
00001D4C                          2340              
00001D4C                          2341              ;Shift the bits so we can enter the rest of the values
00001D4C  1E3C 0010               2342              MOVE.B      #16,D7
00001D50  EFAC                    2343              LSL.L       D7,D4
00001D52                          2344              
00001D52                          2345              ;Increment A6 to account for the next values in the instruction
00001D52  544E                    2346              ADDA.W      #2,A6
00001D54                          2347              
00001D54                          2348              ;Move the rest of the machine code into our register
00001D54                          2349              ;This register should have the whole long values
00001D54  3816                    2350              MOVE.W      (A6),D4
00001D56                          2351              
00001D56                          2352              ;Print the Long address
00001D56  4281                    2353              CLR.L       D1
00001D58                          2354              
00001D58  700F                    2355              MOVE.L      #15,D0
00001D5A  7410                    2356              MOVE.L      #16,D2
00001D5C  2204                    2357              MOVE.L      D4,D1
00001D5E  4E4F                    2358              TRAP        #15
00001D60                          2359              
00001D60  4E75                    2360              RTS    
00001D62                          2361          
00001D62                          2362          
00001D62                          2363  IMDLong:
00001D62                          2364              *********USED FOR IMMEDIATE LONGS ONLY***************
00001D62                          2365              
00001D62                          2366              ;Place the current value into a temp register
00001D62  3816                    2367              MOVE.W      (A6),D4
00001D64                          2368              
00001D64                          2369              ;Shift the bits so we can enter the rest of the values
00001D64  1E3C 0010               2370              MOVE.B      #16,D7
00001D68  EFAC                    2371              LSL.L       D7,D4
00001D6A                          2372              
00001D6A                          2373              ;Increment A2 to account for the next values in the machine code
00001D6A  544E                    2374              ADDA.W      #2,A6
00001D6C                          2375              
00001D6C                          2376              ;Move the rest of the machine code into our register
00001D6C                          2377              ;This register should have the whole long values
00001D6C  3816                    2378              MOVE.W      (A6),D4
00001D6E                          2379              
00001D6E                          2380              ;Print out the value in the address
00001D6E  7003                    2381              MOVE.L      #3,D0
00001D70  2204                    2382              MOVE.L      D4,D1
00001D72  4E4F                    2383              TRAP        #15
00001D74                          2384              
00001D74  4E75                    2385              RTS
00001D76                          2386  
00001D76                          2387  *-----------------------------------------------------------
00001D76                          2388  * Print Instructions for NOP and RTS
00001D76                          2389  *-----------------------------------------------------------
00001D76                          2390  printMNOP:
00001D76  43F9 00001E88           2391              LEA        printNOP,A1
00001D7C  103C 000E               2392              MOVE.B     #14,D0
00001D80  4E4F                    2393              TRAP       #15
00001D82                          2394              
00001D82  6000 F49A               2395              BRA        update
00001D86                          2396  
00001D86                          2397  printMRTS:
00001D86  43F9 00001EF1           2398              LEA        printRTS,A1
00001D8C  103C 000E               2399              MOVE.B     #14,D0
00001D90  4E4F                    2400              TRAP       #15
00001D92                          2401              
00001D92  6000 F48A               2402              BRA        update
00001D96                          2403  ;-----------------------------------------------------------
00001D96                          2404  ;ERROR MESSAGES FOR I/O portion
00001D96                          2405  ;-----------------------------------------------------------
00001D96                          2406  charError:
00001D96                          2407              
00001D96  43F9 00001F58           2408              LEA         invalCh,A1
00001D9C  103C 000E               2409              MOVE.B      #14,D0
00001DA0  4E4F                    2410              TRAP        #15
00001DA2                          2411              
00001DA2  6000 F2AC               2412              BRA         startingPrompt
00001DA6                          2413            
00001DA6                          2414  oddError:
00001DA6  43F9 00001F79           2415              LEA         odd,A1
00001DAC  103C 000E               2416              MOVE.B      #14,D0
00001DB0  4E4F                    2417              TRAP        #15
00001DB2                          2418              
00001DB2  6000 F29C               2419              BRA         startingPrompt
00001DB6                          2420              
00001DB6                          2421  manyCharError:  
00001DB6  43F9 00001FA6           2422              LEA         manyChar, A1
00001DBC  103C 000E               2423              MOVE.B      #14,D0
00001DC0  4E4F                    2424              TRAP        #15
00001DC2                          2425              
00001DC2  6000 F28C               2426              BRA         startingPrompt
00001DC6                          2427           
00001DC6                          2428  endGreater:
00001DC6  43F9 00001FE1           2429              LEA         endG,A1
00001DCC  103C 000E               2430              MOVE.B      #14,D0
00001DD0  4E4F                    2431              TRAP        #15
00001DD2                          2432              
00001DD2  6000 F27C               2433              BRA         startingPrompt
00001DD6                          2434         
00001DD6                          2435  ;-----------------------------------------------------------
00001DD6                          2436  ;MESSAGES
00001DD6                          2437  ;-----------------------------------------------------------
00001DD6= 57 65 6C 63 6F 6D ...   2438  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001DFA= 50 6C 65 61 73 65 ...   2439  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001E3C= 50 6C 65 61 73 65 ...   2440  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001E7C= 0D 0A 41 64 64 72 ...   2441  AddressNum  DC.B        CR,LF,'Address: ',0
00001E88                          2442  
00001E88                          2443  ;-----------------------------------------------------------
00001E88                          2444  ;OPCODE Messages
00001E88                          2445  ;-----------------------------------------------------------
00001E88= 4E 4F 50 00             2446  printNOP    DC.B        'NOP',0
00001E8C= 4D 4F 56 45 00          2447  printMOVE   DC.B        'MOVE',0
00001E91= 4D 4F 56 45 4D 00       2448  printMOVEM  DC.B        'MOVEM',0
00001E97= 41 44 44 00             2449  printADD    DC.B        'ADD',0
00001E9B= 41 44 44 49 00          2450  printADDI   DC.B        'ADDI',0
00001EA0= 53 55 42 00             2451  printSUB    DC.B        'SUB',0
00001EA4= 53 55 42 49 00          2452  printSUBI   DC.B        'SUBI',0
00001EA9= 4D 55 4C 53 2E 57 ...   2453  printMULS   DC.B        'MULS.W ',0
00001EB1= 44 49 56 55 2E 57 ...   2454  printDIVU   DC.B        'DIVU.W ',0
00001EB9= 4C 45 41 20 00          2455  printLEA    DC.B        'LEA ',0
00001EBE= 41 4E 44 00             2456  printAND    DC.B        'AND',0
00001EC2= 41 4E 44 49 00          2457  printANDI   DC.B        'ANDI',0
00001EC7= 4E 4F 54 00             2458  printNOT    DC.B        'NOT',0
00001ECB= 4C 53 4C 00             2459  printLSL    DC.B        'LSL',0
00001ECF= 4C 53 52 00             2460  printLSR    DC.B        'LSR',0
00001ED3= 41 53 4C 00             2461  printASL    DC.B        'ASL',0
00001ED7= 41 53 52 00             2462  printASR    DC.B        'ASR',0
00001EDB= 42 4C 54 00             2463  printBLT    DC.B        'BLT',0
00001EDF= 42 47 45 00             2464  printBGE    DC.B        'BGE',0
00001EE3= 42 45 51 00             2465  printBEQ    DC.B        'BEQ',0
00001EE7= 42 43 43 20 00          2466  printBCC    DC.B        'BCC ',0
00001EEC= 4A 53 52 20 00          2467  printJSR    DC.B        'JSR ',0
00001EF1= 52 54 53 00             2468  printRTS    DC.B        'RTS',0
00001EF5= 42 52 41 00             2469  printBRA    DC.B        'BRA',0
00001EF9= 41 53 00                2470  printMAS    DC.B        'AS',0
00001EFC= 4C 53 00                2471  printMLS    DC.B        'LS',0
00001EFF= 4C 00                   2472  printL      DC.B        'L',0    
00001F01= 52 00                   2473  printR      DC.B        'R',0
00001F03                          2474  ;-----------------------------------------------------------
00001F03                          2475  ;Size Messages
00001F03                          2476  ;-----------------------------------------------------------
00001F03= 2E 42 20 00             2477  printSIZEB  DC.B        '.B ',0
00001F08= 2E57 2000 0000          2478  printSIZEW  DC.W        '.W ',0
00001F0E= 2E4C2000 00000000       2479  printSIZEL  DC.L        '.L ',0
00001F16                          2480  
00001F16                          2481  ;-----------------------------------------------------------
00001F16                          2482  ;Addressing Mode Messages
00001F16                          2483  ;-----------------------------------------------------------
00001F16= 44 00                   2484  printDRD      DC.B        'D',0
00001F18= 41 00                   2485  printARD      DC.B        'A',0
00001F1A= 28 41 00                2486  printARI      DC.B        '(A',0
00001F1D= 29 00                   2487  printARI2     DC.B        ')',0
00001F1F= 23 00                   2488  printIA       DC.B        '#',0
00001F21= 24 00                   2489  printA        DC.B        '$',0
00001F23= 28 41 00                2490  printPI       DC.B        '(A',0
00001F26= 29 2B 00                2491  printPI2      DC.B        ')+',0
00001F29= 2D 28 41 00             2492  printPD       DC.B        '-(A',0
00001F2D= 29 00                   2493  printPD2      DC.B        ')',0
00001F2F                          2494  
00001F2F= 2C 00                   2495  printComma    DC.B        ',',0
00001F31= 20 00                   2496  printSpace    DC.B        ' ',0
00001F33= 2F 00                   2497  printSlash    DC.B        '/',0
00001F35= 2D 00                   2498  printDash     DC.B        '-',0
00001F37                          2499  
00001F37= 0D 0A 59 6F 75 20 ...   2500  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001F58                          2501  
00001F58                          2502  ;-----------------------------------------------------------
00001F58                          2503  ;ERRORS
00001F58                          2504  ;-----------------------------------------------------------
00001F58= 45 52 52 4F 52 3A ...   2505  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001F79= 45 52 52 4F 52 3A ...   2506  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001FA6= 45 52 52 4F 52 3A ...   2507  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001FE1= 45 52 52 4F 52 3A ...   2508  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00002026= 45 52 52 4F 52 3A ...   2509  sizeError   DC.B        'ERROR: Invalid size instruction',0
00002046= 45 52 52 4F 52 3A ...   2510  invalOpcode DC.B        'ERROR: Invalid opcode = ',0
0000205F                          2511  
00002060  4283                    2512              CLR.L       D3     
00002062                          2513  
00002062                          2514  ;-----------------------------------------------------------
00002062                          2515  ;Ending function that ends our program 
00002062                          2516  ;-----------------------------------------------------------
00002062                          2517  ending:
00002062  43F8 1F37               2518              LEA         theEnd,A1
00002066  303C 000E               2519              MOVE        #14,D0
0000206A  4E4F                    2520              TRAP        #15
0000206C                          2521              
0000206C                          2522              END         MAIN  

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1D4A
ABSOLUTE            1D24
ABSOLUTEADDRESSMOVEM  1514
ADD16BITS           17C4
ADD32BITS           1806
ADD8BITS            1782
ADDRESSMODESR       1C38
ADDRESSNUM          1E7C
ARD                 1C7C
ARI                 1C90
BCCOFFSET           1752
BIT16DISPLACEMENT   17B0
BIT32DISPLACEMENT   17F2
BIT8DISPLACEMENT    1774
BITLOOP             158A
CHARERROR           1D96
CHECK               1518
CONTINUE16BITS      17D4
CONTINUE32BITS      1816
CONTINUE8BITS       1792
CONTINUEDIVU        1850
CONTINUEI           1296
CONVERT             10A4
COUNTER             1008
CR                  D
CURADD              100C
DNDEST              1B40
DNSOURCE            1B64
DORA                100A
DRD                 1C68
ENDG                1FE1
ENDGREATER          1DC6
ENDHEX              1004
ENDING              2062
ENDINGPROMPT        107C
FINDLIST            153C
FINDLIST2           155E
GETBITS             123C
IMDLONG             1D62
IMMEDIATE           1D04
IMMEDIATECOUNT      19D6
IMMEDIATECOUNT2     1A00
INVALCH             1F58
INVALID             1204
INVALOPCODE         2046
ISOADDBIT0TO5       131A
ISOLATEADDRESSBIT0TO5  1B88
ISOLATEADDRESSBIT6TO11  13A2
ISOLATEREGISTERBIT9TO11  1BAE
LETTER              10C8
LF                  A
LISTSIZE            100F
LISTTOMEM           1482
LISTTOMEM2          14A0
LOOP                1158
M00                 1340
M0000               1252
M0100               13C8
M0110               16B8
M1000               1834
M1001               1860
M1100               18A4
M1101               1AFC
M1110               191C
MADDI               128A
MAIN                1000
MAND                18E8
MANDI               127A
MANYCHAR            1FA6
MANYCHARERROR       1DB6
MAS                 1A74
MBCC                1712
MBEQ                1742
MBGE                1732
MBLT                1722
MBRA                1702
MEFFECT             12F8
MEMAS               1A46
MEMDIRECTIONSUBROUTINE  1A82
MEMLS               1A4E
MEMSHIFT            1A10
MEMSHIFT2           1A2E
MEMTOLIST           14CE
MJSR                16A0
ML                  1AAE
MLEA                1644
MLS                 1A66
MMULS               18D8
MNOT                1674
MORECHECKS          10F8
MORECHECKS1         1104
MORECHECKS2         1126
MOVEM               142A
MOVEMADD            100E
MR                  1AA0
MSOURCEDEST         1380
MSUBI               12C0
MULSCHECK           18C2
NUMBER              10DC
ODD                 1F79
ODDERROR            1DA6
OTHERMODES          1CF0
PBYTE               1C0E
PD                  1CD0
PI                  1CB0
PLONG               1C2A
PRINTA              1F21
PRINTADD            1E97
PRINTADDI           1E9B
PRINTAND            1EBE
PRINTANDI           1EC2
PRINTARD            1F18
PRINTARI            1F1A
PRINTARI2           1F1D
PRINTASL            1ED3
PRINTASR            1ED7
PRINTBCC            1EE7
PRINTBEQ            1EE3
PRINTBGE            1EDF
PRINTBLT            1EDB
PRINTBRA            1EF5
PRINTCOMMA          1F2F
PRINTDASH           1F35
PRINTDIVU           1EB1
PRINTDRD            1F16
PRINTIA             1F1F
PRINTJSR            1EEC
PRINTL              1EFF
PRINTLEA            1EB9
PRINTLSL            1ECB
PRINTLSR            1ECF
PRINTMAS            1EF9
PRINTMLS            1EFC
PRINTMNOP           1D76
PRINTMOVE           1E8C
PRINTMOVEM          1E91
PRINTMOVEMSIZE      1BFE
PRINTMOVESIZE       1BE6
PRINTMRTS           1D86
PRINTMULS           1EA9
PRINTNOP            1E88
PRINTNOT            1EC7
PRINTPD             1F29
PRINTPD2            1F2D
PRINTPI             1F23
PRINTPI2            1F26
PRINTR              1F01
PRINTRTS            1EF1
PRINTSINGLE         15B8
PRINTSIZEB          1F03
PRINTSIZEL          1F0E
PRINTSIZESUBROUTINE  1BC6
PRINTSIZEW          1F08
PRINTSLASH          1F33
PRINTSPACE          1F31
PRINTSUB            1EA0
PRINTSUBI           1EA4
PSLASH              1636
PWORD               1C1C
REGAS               1A56
REGDIRECTIONSUBROUTINE  1ABE
REGLS               1A5E
REGSHIFT            1974
REGSHIFT2           19AC
RL                  1AEC
RR                  1ADC
SETA                1580
SETD                1576
SHIFTEIGHT          1A08
SINGLEAREG          1602
SINGLEDREG          15D0
SIZEERROR           2026
SKIPA6              1226
SKIPBIT             15AC
SKIPCOPY            1CF8
SKIPSLASHA          1610
SKIPSLASHD          15DE
STAHEX              1000
STARTINGPROMPT      1050
SUB16BITS           17CA
SUB32BITS           180C
SUB8BITS            1788
THEEND              1F37
TOTALCOUNT          1009
UPDATE              121E
USEREA              1E3C
USERSA              1DFA
WELCOME             1DD6
