00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/2/2021 3:16:12 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  
00001008                            15  ;Used for MOVEM
00001008= 01                        16  firstBit:   DC.B        $1
00001009= 00                        17  counter:    DC.B        $0
0000100A= 00                        18  staIndex:   DC.B        $0
0000100B= 00                        19  endIndex:   DC.B        $0
0000100C= 00                        20  aRegDone:   DC.B        $0
0000100D= 00                        21  dORa:       DC.B        $0
0000100E= 00                        22  prev:       DC.B        $0
0000100F                            23  *-----------------------------------------------------------
0000100F                            24  * I/O Implementation
0000100F                            25  ;1. Prompt user for start and ending addresses (In hex)
0000100F                            26  ;2. User inputs their values
0000100F                            27  ;3. Check for errors
0000100F                            28  ;        Check to see if hex is too big
0000100F                            29  ;        Check to see value doesn't contain G-Z
0000100F                            30  ;        Check to see if there are no commas/special chars
0000100F                            31  ;        Check to see that starting loc, is before ending loc
0000100F                            32  ;        Check to see if value starts at odd mem location
0000100F                            33  *-----------------------------------------------------------
0000100F                            34  
0000100F                            35             ;Show welcome to user
00001010  43F9 00001DEC             36              LEA         Welcome,A1
00001016  103C 000E                 37              MOVE.B      #14,D0
0000101A  4E4F                      38              TRAP        #15
0000101C                            39                       
0000101C                            40              
0000101C                            41        
0000101C  48F9 7FFF 23485926        42              MOVEM.L     D0-D7/A0-A6,$23485926
00001024                            43              ;MOVEM.L     (A5),D0-D2/D5-D7/A0-A3/A6
00001024  4CF8 7FBF 1234            44              MOVEM.L     $1234,D0-D5/D7/A0-A6
0000102A  4CF8 7F00 1234            45              MOVEM.L     $1234,A0-A6
00001030                            46  
00001030                            47              ;MOVEM.L     D0-D5/D7/A0-A6,-(A7)     
00001030                            48              
00001030                            49  ;==========================            
00001030                            50              
00001030                            51  startingPrompt:
00001030                            52              ;Ask the user for the starting hex3
00001030  43F9 00001E10             53              LEA         userSA,A1
00001036  103C 000E                 54              MOVE.B      #14,D0
0000103A  4E4F                      55              TRAP        #15        
0000103C                            56              
0000103C                            57              ;Clear the registers in case we had an error
0000103C  227C 00000000             58              MOVE.L      #0,A1
00001042  247C 00000000             59              MOVE.L      #0,A2
00001048  4283                      60              CLR.L       D3
0000104A  4284                      61              CLR.L       D4
0000104C  4285                      62              CLR.L       D5
0000104E  4286                      63              CLR.L       D6
00001050                            64             
00001050                            65              
00001050                            66              ;Input for the hex (D1 equals number of chars)
00001050  303C 0002                 67              MOVE.W      #2,D0
00001054  4E4F                      68              TRAP        #15
00001056                            69              
00001056                            70              ;Moves A1 into A2      
00001056                            71              ;MOVEA.L     A1,A2
00001056                            72              
00001056                            73              ;Makes sure D7 is clear incase we're looping back after an error.
00001056  4207                      74              CLR.B       D7
00001058                            75              
00001058  6000 002A                 76              BRA         convert  
0000105C                            77              
0000105C                            78  endingPrompt:
0000105C                            79              ;D7 is if we're working with the first or second prompt, used in the more checks section. 
0000105C  1E3C 0001                 80              MOVE.B       #1,D7
00001060                            81              
00001060                            82              ;Ask the user for the ending hex
00001060  43F9 00001E52             83              LEA         userEA,A1
00001066  103C 000E                 84              MOVE.B      #14,D0
0000106A  4E4F                      85              TRAP        #15
0000106C                            86              
0000106C                            87              ;Clearing the registers so we can reuse them for the ending address
0000106C  227C 00000000             88              MOVE.L      #0,A1
00001072  247C 00000000             89              MOVE.L      #0,A2
00001078  4286                      90              CLR.L       D6
0000107A                            91  
0000107A                            92              ;Input for the hex (D1 equals number of chars)
0000107A  303C 0002                 93              MOVE.W      #2,D0
0000107E  4E4F                      94              TRAP        #15
00001080                            95              
00001080                            96              ;Moves A1 into A2      
00001080                            97              ;MOVEA.L     A1,A2
00001080                            98              
00001080  6000 0002                 99              BRA         convert
00001084                           100  
00001084                           101  convert:    
00001084                           102              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001084  B23C 0008                103              CMP.B       #8, D1
00001088  6E00 0D42                104              BGT         manyCharError  
0000108C                           105              
0000108C                           106              ;See if our counter variable is 0
0000108C  B23C 0000                107              CMP.B       #0,D1
00001090                           108              
00001090                           109              ;This means that we have gone through all the characters
00001090  6700 0046                110              BEQ         moreChecks
00001094                           111              
00001094                           112              ;Decrement the counter, this means we're about to go through another char
00001094  5301                     113              SUB.B       #1,D1
00001096                           114  
00001096                           115              ;Let's move the byte stored at A1
00001096  1612                     116              MOVE.B      (A2),D3
00001098                           117              
00001098                           118              ;If the byte is greater than or equal to hex $40, then it's a letter
00001098  B63C 0041                119              CMP.B       #$41,D3
0000109C  6C00 000A                120              BGE         letter
000010A0                           121              
000010A0                           122              ;If the byte is less than or equal to hex $39, then it's a number
000010A0  B63C 0040                123              CMP.B       #$40,D3
000010A4  6F00 0016                124              BLE         number
000010A8                           125              
000010A8                           126  letter:
000010A8                           127              ;We do this check to see if the character is greater than or equal 'G'
000010A8  B63C 0047                128              CMP.B       #$47,D3
000010AC                           129              ;If so, then display an error and ask the user to enter startingAdd again
000010AC  6C00 0CFE                130              BGE         charError
000010B0                           131              
000010B0                           132              ;Subtract the Ascii value to convert to hex
000010B0  0403 0037                133              SUB.B       #$37,D3
000010B4                           134              ;Move the value back to our register
000010B4  14C3                     135              MOVE.B      D3,(A2)+
000010B6                           136              
000010B6                           137              ;Shift D5 left to make room for next hex value
000010B6  E986                     138              ASL.L       #4, D6
000010B8                           139              ;Move value to D5
000010B8  DC03                     140              ADD.B      D3, D6
000010BA                           141              
000010BA  60C8                     142              BRA         convert
000010BC                           143             
000010BC                           144  
000010BC                           145  number:          
000010BC                           146             ;We do this check to see if the character is less than or equal to '/'  
000010BC  B63C 002F                147             CMP.B        #$2F,D3
000010C0                           148             ;If so, then display an error and ask the user to enter startingAdd again
000010C0  6F00 0CEA                149             BLE          charError     
000010C4                           150   
000010C4                           151             ;Check to see if the character is greater than or equal to ':'
000010C4  B63C 003A                152             CMP.B        #$3A,D3
000010C8                           153             ;If so, then display an error and ask the user to enter startingAdd again
000010C8  6C00 0CE2                154             BGE          charError
000010CC                           155            
000010CC                           156             ;Subtract the Ascii value to convert to hex
000010CC  0403 0030                157             SUB.B        #$30,D3
000010D0                           158             ;Move the value back to our register
000010D0  14C3                     159             MOVE.B       D3,(A2)+
000010D2                           160   
000010D2                           161             ;Shift D5 left to make room for next hex value
000010D2  E986                     162             ASL.L        #4, D6
000010D4                           163             ;Move value to D5
000010D4  DC03                     164             ADD.B        D3, D6
000010D6                           165              
000010D6  60AC                     166             BRA          convert
000010D8                           167   
000010D8                           168            
000010D8                           169  moreChecks:
000010D8                           170              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010D8  BE3C 0001                171              CMP.B      #1,D7
000010DC  6700 0028                172              BEQ        moreChecks2
000010E0                           173              
000010E0  6000 0002                174              BRA        moreChecks1
000010E4                           175   
000010E4                           176  moreChecks1:
000010E4                           177              
000010E4                           178              ;Copy the hex value into a temp register
000010E4  2806                     179              MOVE.L      D6,D4
000010E6                           180              
000010E6                           181              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010E6  1A3C 001F                182              MOVE.B      #31,D5
000010EA                           183              
000010EA                           184              ;Shifts 31 bits, isolates last bit. 
000010EA  EBAC                     185              LSL.L       D5,D4
000010EC                           186  
000010EC                           187              ;Shifts it back 31 bit, isolating the last bit. 
000010EC  EAAC                     188              LSR.L       D5,D4
000010EE                           189  
000010EE                           190              ;If the last bit is 1, address was odd, and throw an error. 
000010EE  B83C 0001                191              CMP.B       #1,D4
000010F2  6700 0CC8                192              BEQ         oddError   
000010F6                           193                          
000010F6                           194              ;Reset address registers.
000010F6  247C 00000000            195              MOVE.L      #0,A2
000010FC                           196              
000010FC                           197              ;Copy the value to our staHex variable
000010FC  21C6 1000                198              MOVE.L      D6,staHex 
00001100                           199              
00001100  4286                     200              CLR.L       D6
00001102  6000 FF58                201              BRA         endingPrompt     
00001106                           202              
00001106                           203  moreChecks2:       
00001106                           204              
00001106                           205              ;Copy the hex value into a temp register
00001106  2806                     206              MOVE.L      D6,D4
00001108                           207              
00001108                           208              ;Placeholder to shift bits, used for seeing if the address is odd. 
00001108  1A3C 001F                209              MOVE.B      #31,D5
0000110C                           210              
0000110C                           211              ;Shifts 31 bits, isolates last bit. 
0000110C  EBAC                     212              LSL.L       D5,D4
0000110E                           213  
0000110E                           214              ;Shifts it back 31 bit, isolating the last bit. 
0000110E  EAAC                     215              LSR.L       D5,D4
00001110                           216  
00001110                           217              ;If the last bit is 1, address was odd, and throw an error. 
00001110  B83C 0001                218              CMP.B       #1,D4
00001114  6700 0CA6                219              BEQ         oddError   
00001118                           220                          
00001118                           221              ;Reset address registers.
00001118  247C 00000000            222              MOVE.L      #0,A2
0000111E                           223              
0000111E                           224              ;Place the value in our ending hex variable
0000111E  21C6 1004                225              MOVE.L      D6,endHex 
00001122                           226              
00001122                           227              ;Make D7 a temp location to compare our starting hex
00001122  2E38 1000                228              MOVE.L      staHex,D7
00001126                           229           
00001126                           230              
00001126                           231              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
00001126  BC87                     232              CMP.L       D7,D6
00001128  6B00 0CB2                233              BMI         endGreater
0000112C                           234              
0000112C                           235              ;done, start reading memory. 
0000112C                           236              
0000112C                           237              ;Clear all the registers since we have the addresses stored in our variables
0000112C  4283                     238              CLR.L       D3
0000112E  4285                     239              CLR.L       D5
00001130  4286                     240              CLR.L       D6
00001132  4287                     241              CLR.L       D7  
00001134                           242              
00001134                           243              ;Copy the value of our starting hex to A2 (temp register)
00001134  2478 1000                244              MOVEA.L     staHex,A2
00001138                           245                          
00001138                           246              
00001138                           247  LOOP:   
00001138                           248              ;We will be printing out the address, regardless if the opcode is valid or not
00001138  43F9 00001E92            249              LEA         AddressNum,A1
0000113E  103C 000E                250              MOVE.B      #14,D0
00001142  4E4F                     251              TRAP        #15
00001144                           252              
00001144                           253              ;Print out the address
00001144  700F                     254              MOVE.L      #15,D0
00001146  7410                     255              MOVE.L      #16,D2
00001148  220A                     256              MOVE.L      A2,D1
0000114A  4E4F                     257              TRAP        #15
0000114C                           258              
0000114C  43F9 00001F41            259              LEA         printSpace,A1
00001152  103C 000E                260              MOVE.B      #14,D0
00001156  4E4F                     261              TRAP        #15
00001158                           262  
00001158                           263              ;--------------------------------------------------------
00001158                           264              ;Check for NOP or RTS
00001158                           265              ;--------------------------------------------------------
00001158                           266              
00001158                           267              ;Move the NOP binary value for comparing
00001158  243C 00004E71            268              MOVE.L      #%0100111001110001,D2
0000115E                           269              
0000115E                           270              ;Check and see i the instruction is NOP
0000115E  B452                     271              CMP.W       (A2),D2
00001160  6700 0C2A                272              BEQ         printMNOP
00001164                           273              
00001164                           274              ;Move the RTS binary value for comparing
00001164  243C 00004E75            275              MOVE.L      #%0100111001110101,D2
0000116A                           276              
0000116A                           277              ;Check and see if the instruction is RTS
0000116A  B452                     278              CMP.W       (A2),D2
0000116C  6700 0C2E                279              BEQ         printMRTS
00001170                           280              
00001170                           281              ;Clear the contents for reusing
00001170  4282                     282              CLR.L       D2
00001172                           283              
00001172                           284              ;--------------------------------------------------------
00001172                           285              ;Check for ADDI or SUBI, check for four 0's since it's the only
00001172                           286              ;opcode with this pattern
00001172                           287              ;--------------------------------------------------------  
00001172                           288              ;Move the value in A2 to a temp register
00001172  3412                     289              MOVE.W      (A2),D2
00001174                           290              
00001174                           291              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001174  163C 000C                292              MOVE.B      #12,D3
00001178  183C 0004                293              MOVE.B      #4,D4
0000117C                           294              
0000117C                           295              ;Jumps to getBits and returns with isolated bits in D2
0000117C  6100 0078                296              BSR         getBits
00001180                           297              
00001180  B43C 0000                298              CMP.B       #%0000,D2
00001184  6700 0086                299              BEQ         M0000
00001188                           300              
00001188                           301              ;--------------------------------------------------------
00001188                           302              ;Check for MOVE, since it's the only word starting with 00
00001188                           303              ;--------------------------------------------------------            
00001188                           304              ;Move the value in A2 to a temp register
00001188  1412                     305              MOVE.B      (A2),D2
0000118A                           306              
0000118A                           307              ;Shift 6 bits to the right to isolate the left-most digits
0000118A  EC8A                     308              LSR.L       #6,D2
0000118C                           309              
0000118C                           310              ;If the first two bits (left-most) are 00, then the instruction is MOVE
0000118C  B43C 0000                311              CMP.B       #00,D2
00001190  6F00 014E                312              BLE         M00
00001194                           313              
00001194                           314              ;Reuse the register
00001194  4282                     315              CLR.L       D2
00001196                           316              
00001196                           317              
00001196                           318              ;--------------------------------------------------------
00001196                           319              ;Check for other OpCodes
00001196                           320              ;--------------------------------------------------------
00001196                           321              ;Move the word into a temp register 
00001196  3412                     322              MOVE.W      (A2),D2
00001198                           323              
00001198                           324              ;Passing in parameters for isolating the left most hand 4 bits of D2 using getBits
00001198  163C 000C                325              MOVE.B        #12,D3            ;Start bit index = 12
0000119C  183C 0004                326              MOVE.B        #4,D4             ;Number of bits needed = 4
000011A0                           327              
000011A0                           328              ;Jumps to getBits and returns with isolated bits in D2
000011A0  6100 0054                329              BSR           getBits            
000011A4                           330  
000011A4                           331              
000011A4                           332              ;MOVEM,LEA,NOT,JSR
000011A4  B43C 0004                333              CMP.B       #%0100,D2
000011A8  6700 01B4                334              BEQ         M0100
000011AC                           335              
000011AC                           336              ;BRA,BLT,BGE,BEQ
000011AC  B43C 0006                337              CMP.B       #%0110,D2
000011B0  6700 0544                338              BEQ         M0110
000011B4                           339              
000011B4                           340              ;DIVU
000011B4  B43C 0008                341              CMP.B       #%1000,D2
000011B8  6700 06B8                342              BEQ         M1000
000011BC                           343              
000011BC                           344              ;SUB
000011BC  B43C 0009                345              CMP.B       #%1001,D2
000011C0  6700 06DC                346              BEQ         M1001
000011C4                           347              
000011C4                           348              ;MULS,AND
000011C4  B43C 000C                349              CMP.B       #%1100,D2
000011C8  6700 0718                350              BEQ         M1100
000011CC                           351              
000011CC                           352              ;LSL,LSR,ASL,ASR
000011CC  B43C 000E                353              CMP.B       #%1110,D2
000011D0  6700 0784                354              BEQ         M1110
000011D4                           355              
000011D4                           356              ;ADD
000011D4  B43C 000D                357              CMP.B       #%1101,D2
000011D8  6700 0938                358              BEQ         M1101
000011DC                           359              
000011DC                           360              ;BSR         invalOpCode
000011DC                           361              
000011DC  6000 0E94                362              BRA         ending
000011E0                           363              
000011E0                           364              
000011E0                           365              
000011E0                           366  
000011E0                           367             
000011E0                           368  update:
000011E0                           369              *=====Important if we've done any Immediate or Absolute addressing=====*
000011E0                           370              ;If we've done any Immediate or Absolute addressing, then we would have made use of A6. 
000011E0                           371              ;A6 would point to the last word in instruction and thus pointing to a larger address value than A2, 
000011E0                           372              ;because A2 always points at the the first word in an instruction (opcode).
000011E0  B5CE                     373              CMP.L       A6,A2
000011E2  6C00 0004                374              BGE         skipA6
000011E6                           375              
000011E6                           376              ;If A6 points to an address larger than the one A2 points to then we update A2 to point to where A6 points
000011E6  244E                     377              MOVEA.L     A6,A2
000011E8                           378              
000011E8                           379  skipA6:
000011E8                           380              ;Check and see if we are at the ending hex
000011E8  B5F8 1004                381              CMP.L      endHex,A2
000011EC  6E00 0E84                382              BGT        ending
000011F0                           383  
000011F0                           384              ;Update address in A2
000011F0  544A                     385              ADDA.W      #2,A2
000011F2                           386              
000011F2                           387              
000011F2  6000 FF44                388              BRA        LOOP
000011F6                           389              
000011F6                           390              
000011F6                           391  getBits:
000011F6                           392              ;GETS ___ MANY BITS STARTING FROM __ START BIT INDEX
000011F6                           393              ;PARAMETERS:
000011F6                           394              ;D2 = the value the bits are extracted from & saved back in
000011F6                           395              ;D3 = the start bit index (starting from 0)
000011F6                           396              ;D4 = the number of bits we want to extract
000011F6                           397              
000011F6                           398              ;Calculate left shift
000011F6  3A3C 0010                399              MOVE.W      #16,D5
000011FA                           400              
000011FA  D843                     401              ADD.W       D3,D4             ; start bit index + number of bits needed = X 
000011FC  9A44                     402              SUB.W       D4,D5             ; 16 - X = leftShift
000011FE                           403              
000011FE  EB6A                     404              LSL.W       D5,D2
00001200                           405              
00001200                           406              
00001200                           407              ;Calculate right shift
00001200  DA43                     408              ADD.W       D3,D5             ; start bit + leftShift = X
00001202  EA6A                     409              LSR.W       D5,D2
00001204                           410              
00001204  4283                     411              CLR.L       D3
00001206  4284                     412              CLR.L       D4
00001208  4285                     413              CLR.L       D5   
0000120A  4E75                     414              RTS
0000120C                           415  
0000120C                           416  *-----------------------------------------------------------
0000120C                           417  * 
0000120C                           418  *
0000120C                           419  *
0000120C                           420  * OpCode Implementation
0000120C                           421  *
0000120C                           422  *
0000120C                           423  *
0000120C                           424  *-----------------------------------------------------------
0000120C                           425  
0000120C                           426  
0000120C                           427  *-----------------------------------------------------------
0000120C                           428  * ADDI/SUBI INSTRUCTION
0000120C                           429  *-----------------------------------------------------------
0000120C                           430  M0000:
0000120C  4282                     431              CLR.L       D2
0000120E  4283                     432              CLR.L       D3
00001210                           433              
00001210                           434              ;Copy the address values into a register to check for ADDI or SUBI
00001210  3412                     435              MOVE.W      (A2),D2
00001212                           436              
00001212                           437              ;Passing in paramters for isolating bits
00001212  163C 0008                438              MOVE.B      #8,D3
00001216  183C 0004                439              MOVE.B      #4,D4
0000121A                           440              
0000121A                           441              ;Jumps to getBits and returns with isolated bits in D2
0000121A  61DA                     442              BSR         getBits
0000121C                           443              
0000121C                           444              ;--------------------------------------------------------
0000121C                           445              ;Check for ADDI
0000121C                           446              ;--------------------------------------------------------
0000121C  B43C 0006                447              CMP.B       #%0110,D2
00001220  6700 000A                448              BEQ         MADDI
00001224                           449             
00001224                           450              ;--------------------------------------------------------
00001224                           451              ;Check for SUBI
00001224                           452              ;--------------------------------------------------------
00001224  B43C 0004                453              CMP.B       #%0100,D2
00001228  6700 0036                454              BEQ         MSUBI
0000122C                           455  
0000122C                           456  MADDI:
0000122C  43F9 00001EB1            457              LEA         printADDI,A1
00001232  103C 000E                458              MOVE.B      #14,D0
00001236  4E4F                     459              TRAP        #15
00001238                           460              
00001238  4282                     461              CLR.L       D2
0000123A  4283                     462              CLR.L       D3
0000123C                           463              
0000123C                           464              ;======Isolate Size (S) Bits======
0000123C                           465              ;Copy the address values into a register
0000123C  3412                     466              MOVE.W      (A2),D2
0000123E                           467              
0000123E                           468              ;Passing in parameters for isolating size bits
0000123E  163C 0006                469              MOVE.B      #6,D3
00001242  183C 0002                470              MOVE.B      #2,D4
00001246                           471              
00001246                           472              ;Jumps to getBits and returns with isolated bits in D2
00001246  61AE                     473              BSR         getBits
00001248                           474              
00001248                           475              ;Jumps to printSizeSubroutine and returns after size has been printed
00001248  6100 0992                476              BSR         printSizeSubroutine
0000124C                           477              
0000124C                           478              ;Let's store the size indicator since it will help us determine how many times
0000124C                           479              ;we have to iterate through addresses to print out the whole instruction
0000124C                           480              ;We will use A4 as the register to temporary store the size
0000124C  3842                     481              MOVE.W      D2,A4
0000124E  11C2 2000                482              MOVE.B      D2,$2000
00001252                           483              
00001252                           484              ;Clear the register so we can reuse it
00001252  4282                     485              CLR.L       D2
00001254                           486              
00001254  1412                     487              MOVE.B      (A2),D2
00001256                           488              
00001256                           489              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
00001256                           490              ;This is meant so we can use the copy to figure out the destination addrresing mode
00001256  264A                     491              MOVE.L      A2,A3
00001258                           492              
00001258  6100 003E                493              BSR         mEffect
0000125C                           494              
0000125C  4283                     495              CLR.L       D3
0000125E                           496              
0000125E  6080                     497              BRA         update
00001260                           498              
00001260                           499              
00001260                           500  MSUBI:
00001260  43F9 00001EBA            501              LEA         printSUBI,A1
00001266  103C 000E                502              MOVE.B      #14,D0
0000126A  4E4F                     503              TRAP        #15
0000126C                           504              
0000126C  4282                     505              CLR.L       D2
0000126E  4283                     506              CLR.L       D3
00001270                           507              
00001270                           508              ;======Isolate Size (S) Bits======
00001270                           509              ;Copy the address values into a register
00001270  3412                     510              MOVE.W      (A2),D2
00001272                           511              
00001272                           512              ;Passing in parameters for isolating size bits
00001272  163C 0006                513              MOVE.B      #6,D3
00001276  183C 0002                514              MOVE.B      #2,D4
0000127A                           515              
0000127A                           516              ;Jumps to getBits and returns with isolated bits in D2
0000127A  6100 FF7A                517              BSR         getBits
0000127E                           518              
0000127E                           519              ;Jumps to printSizeSubroutine and returns after size has been printed
0000127E  6100 095C                520              BSR         printSizeSubroutine
00001282                           521              
00001282                           522              ;Let's store the size indicator since it will help us determine how many times
00001282                           523              ;we have to iterate through addresses to print out the whole instruction
00001282                           524              ;We will use A4 as the register to temporary store the size
00001282  3842                     525              MOVE.W      D2,A4
00001284  11C2 2000                526              MOVE.B      D2,$2000
00001288                           527              
00001288                           528              ;Clear the register so we can reuse it
00001288  4282                     529              CLR.L       D2
0000128A                           530              
0000128A  1412                     531              MOVE.B      (A2),D2
0000128C                           532              
0000128C                           533              ;Just before manipulating A2's value, let's store a copy of it so we can use the unmanipulated address
0000128C                           534              ;This is meant so we can use the copy to figure out the destination addrresing mode
0000128C  264A                     535              MOVE.L      A2,A3
0000128E                           536              
0000128E  6100 0008                537              BSR         mEffect
00001292                           538              
00001292  4283                     539              CLR.L       D3
00001294                           540              
00001294  6000 FF4A                541              BRA         update
00001298                           542  
00001298                           543              
00001298                           544  mEffect:
00001298                           545              ;Male D6 #%111 since the source will always be an immediate value 
00001298  1C3C 0007                546              MOVE.B      #7,D6
0000129C                           547              ;Make D7 #%100 since the source will always be an immediate value
0000129C  1E3C 0004                548              MOVE.B      #4,D7     
000012A0                           549  
000012A0                           550              ;Print source address
000012A0  6100 09AC                551              BSR         addressModeSR
000012A4                           552              
000012A4                           553              ;Print the comma after the source address
000012A4  43F9 00001F3F            554              LEA        printComma,A1
000012AA  103C 000E                555              MOVE.B     #14,D0
000012AE  4E4F                     556              TRAP       #15
000012B0                           557              
000012B0                           558              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
000012B0  6100 0008                559              BSR        isoAddBit0to5
000012B4                           560              
000012B4                           561              ;Print source address
000012B4  6100 0998                562              BSR        addressModeSR
000012B8                           563              
000012B8  4E75                     564              RTS            
000012BA                           565              
000012BA                           566              
000012BA                           567  isoAddBit0to5:
000012BA                           568              ;===Isolate the Destination Mode (M)Bits===
000012BA  4282                     569              CLR.L      D2
000012BC                           570              
000012BC                           571              ;Copy the address value into a register
000012BC  3413                     572              MOVE.W     (A3),D2
000012BE                           573              
000012BE                           574              ;Passing in parameters for isolating Mode bits
000012BE  163C 0003                575              MOVE.B     #3,D3
000012C2  183C 0003                576              MOVE.B     #3,D4
000012C6                           577              
000012C6                           578              ;Jumps to getBits and returns with isolated bits in D2
000012C6  4EB8 11F6                579              JSR        getBits
000012CA                           580              
000012CA                           581              ;Save M bit into ***D6*** for later use in addressModeSubroutine
000012CA  1C02                     582              MOVE.B     D2,D6
000012CC                           583              
000012CC                           584              ;===Isolate the Destination Address Register (Xn)Bits===
000012CC  4282                     585              CLR.L      D2
000012CE                           586              
000012CE                           587              ;Copy the address values into a register
000012CE  3413                     588              MOVE.W     (A3),D2
000012D0                           589              
000012D0                           590              ;Passing in parameters for isolating Xn bits
000012D0  163C 0000                591              MOVE.B     #0,D3
000012D4  183C 0003                592              MOVE.B     #3,D4
000012D8                           593              
000012D8                           594              ;Jumps to getBits and returns with isolated bits in D2
000012D8  4EB8 11F6                595              JSR        getBits
000012DC                           596              
000012DC                           597              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000012DC  1E02                     598              MOVE.B      D2,D7
000012DE                           599  
000012DE  4E75                     600              RTS
000012E0                           601              
000012E0                           602  *-----------------------------------------------------------
000012E0                           603  * MOVE INSTRUCTION
000012E0                           604  *-----------------------------------------------------------
000012E0                           605  M00:
000012E0  43F9 00001EA2            606              LEA        printMOVE,A1
000012E6  103C 000E                607              MOVE.B     #14,D0
000012EA  4E4F                     608              TRAP       #15
000012EC                           609              
000012EC  4202                     610              CLR.B      D2
000012EE  4203                     611              CLR.B      D3
000012F0                           612              
000012F0                           613              ;======Isolate Size (S) Bits=======
000012F0                           614              ;Copy the address values into a register
000012F0  3412                     615              MOVE.W     (A2),D2
000012F2                           616              
000012F2                           617              ;Passing in parameters for isolating size bits 12,13
000012F2  163C 000C                618              MOVE.B      #12,D3             
000012F6  183C 0002                619              MOVE.B      #2,D4             
000012FA                           620              
000012FA                           621              ;Jumps to getBits and returns with isolated bits in D2
000012FA  6100 FEFA                622              BSR         getBits  
000012FE                           623              
000012FE                           624              ;Indicate to our print function we are doing this for the MOVE opcode
000012FE  163C 0001                625              MOVE.B      #1,D3
00001302                           626              
00001302                           627              ;Jumps to printSizeSubroutine and returns after size has been printed
00001302  6100 08D8                628              BSR         printSizeSubroutine
00001306                           629              
00001306                           630              ;Let's store the size indicator since it will help us determine how many times
00001306                           631              ;we have to iterate through addresses to print out the whole instruction
00001306                           632              ;We will use A4 as the register to temporary store the size
00001306  3842                     633              MOVE.W      D2,A4
00001308  11C2 2000                634              MOVE.B      D2,$2000
0000130C                           635  
0000130C                           636              ;Clear the register so we can reuse it
0000130C  4282                     637              CLR.L       D2
0000130E                           638              
0000130E  3412                     639              MOVE.W      (A2),D2
00001310                           640              
00001310                           641              ;Just before manipulating A2's value, lets store a copy of it so we can use the unmanipulated address
00001310                           642              ;This is meant so we can use the copy to figure out the destination addressing mode
00001310  264A                     643              MOVE.L      A2,A3
00001312                           644  
00001312  6000 0002                645              BRA         mSourceDest
00001316                           646              
00001316                           647            
00001316                           648  ;======Helper function to find the destination for MOVE======
00001316                           649  mSourceDest:
00001316                           650              ;SOURCE
00001316                           651              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
00001316  6100 0886                652              BSR        isolateAddressBit0to5
0000131A                           653              
0000131A                           654              ;Print source address
0000131A  6100 0932                655              BSR        addressModeSR
0000131E                           656              
0000131E                           657              ;Print the comma after the source address
0000131E  43F9 00001F3F            658              LEA        printComma,A1
00001324  103C 000E                659              MOVE.B     #14,D0
00001328  4E4F                     660              TRAP       #15
0000132A                           661              
0000132A                           662              ;DESTINATION
0000132A                           663              ;Jump to a helper subroutine which will help isolate bits for the address mode and register
0000132A  6100 000C                664              BSR        isolateAddressBit6to11
0000132E                           665              
0000132E                           666              ;Print destination address
0000132E  6100 091E                667              BSR        addressModeSR
00001332                           668              
00001332  4283                     669              CLR.L      D3
00001334                           670              
00001334  6000 FEAA                671              BRA        update
00001338                           672              
00001338                           673  
00001338                           674  isolateAddressBit6to11:
00001338                           675              ;===Isolate the Destination Mode (M)Bits===
00001338  4282                     676              CLR.L      D2
0000133A                           677              
0000133A                           678              ;Copy the address value into a register
0000133A  3413                     679              MOVE.W     (A3),D2
0000133C                           680              
0000133C                           681              ;Passing in parameters for isolating Mode bits
0000133C  163C 0006                682              MOVE.B     #6,D3
00001340  183C 0003                683              MOVE.B     #3,D4
00001344                           684              
00001344                           685              ;Jumps to getBits and returns with isolated bits in D2
00001344  4EB8 11F6                686              JSR        getBits
00001348                           687              
00001348                           688              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001348  1C02                     689              MOVE.B     D2,D6
0000134A                           690              
0000134A                           691              ;===Isolate the Destination Address Register (Xn)Bits===
0000134A  4282                     692              CLR.L      D2
0000134C                           693              
0000134C                           694              ;Copy the address values into a register
0000134C  3413                     695              MOVE.W     (A3),D2
0000134E                           696              
0000134E                           697              ;Passing in parameters for isolating Xn bits
0000134E  163C 0009                698              MOVE.B     #9,D3
00001352  183C 0003                699              MOVE.B     #3,D4
00001356                           700              
00001356                           701              ;Jumps to getBits and returns with isolated bits in D2
00001356  4EB8 11F6                702              JSR        getBits
0000135A                           703              
0000135A                           704              ;Save Xn register bit into ***D7*** for later use in addressModeSR
0000135A  1E02                     705              MOVE.B      D2,D7
0000135C                           706  
0000135C  4E75                     707              RTS
0000135E                           708              
0000135E                           709              
0000135E                           710  *-----------------------------------------------------------
0000135E                           711  * MOVEM,LEA,NOT,JSR INSTRUCTIONS
0000135E                           712  *-----------------------------------------------------------
0000135E                           713  M0100:      
0000135E  4282                     714              CLR.L       D2
00001360  4283                     715              CLR.L       D3
00001362                           716              
00001362                           717              ;--------------------------------------------------------
00001362                           718              ;Check for LEA
00001362                           719              ;--------------------------------------------------------
00001362                           720              ;Copy the address values into a register to check for LEA
00001362  3412                     721              MOVE.W     (A2),D2
00001364                           722              
00001364                           723              ;Passing in parameters for isolating bits 6,7,8
00001364  163C 0006                724              MOVE.B      #6,D3             ;Start bit index = 6
00001368  183C 0003                725              MOVE.B      #3,D4             ;Number of bits needed = 3
0000136C                           726              
0000136C                           727              ;Jumps to getBits and returns with isolated bits in D2
0000136C  6100 FE88                728              BSR         getBits
00001370                           729  
00001370  B43C 0007                730              CMP.B       #%111,D2
00001374  6700 030C                731              BEQ         MLEA
00001378                           732  
00001378                           733              ;--------------------------------------------------------
00001378                           734              ;Check for NOT
00001378                           735              ;--------------------------------------------------------
00001378                           736              ;Clear D2 and recopy it to check for NOT
00001378  4282                     737              CLR.L       D2
0000137A  3412                     738              MOVE.W      (A2),D2
0000137C                           739              
0000137C                           740              ;Pass in parameters for isolating bits 8,9,10,11
0000137C  163C 0008                741              MOVE.B      #8,D3
00001380  183C 0004                742              MOVE.B      #4,D4
00001384                           743              
00001384                           744              ;Jumps to getBits and returns with isolated bits in D2
00001384  6100 FE70                745              BSR         getBits
00001388                           746              
00001388  B43C 0006                747              CMP.B       #%0110,D2
0000138C  6700 0324                748              BEQ         MNOT      
00001390                           749              
00001390                           750              ;--------------------------------------------------------
00001390                           751              ;Check for JSR
00001390                           752              ;--------------------------------------------------------
00001390                           753              ;Clear D2 and recopy it to check for JSR
00001390  4282                     754              CLR.L       D2
00001392  3412                     755              MOVE.W     (A2),D2
00001394                           756              
00001394                           757              ;Pass in parameters for isolating bits 6-11
00001394  163C 0006                758              MOVE.B      #6,D3
00001398  183C 0006                759              MOVE.B      #6,D4
0000139C                           760              
0000139C                           761              ;Jumps to getBits and returns with isolated bits in D2
0000139C  6100 FE58                762              BSR         getBits
000013A0                           763              
000013A0  B43C 003A                764              CMP.B       #%111010,D2
000013A4  6700 0338                765              BEQ         MJSR
000013A8                           766              
000013A8                           767              ;--------------------------------------------------------
000013A8                           768              ;Check for MOVEM
000013A8                           769              ;--------------------------------------------------------
000013A8                           770              ;Clear D2 and recopy it to check for MOVEM
000013A8  4282                     771              CLR.L       D2
000013AA  3412                     772              MOVE.W     (A2),D2
000013AC                           773              
000013AC                           774              ;Pass in parameters for isolating bit 9
000013AC  163C 0009                775              MOVE.B      #9,D3
000013B0  183C 0001                776              MOVE.B      #1,D4
000013B4                           777              
000013B4                           778              ;Jumps to getBits and returns with isolated bits in D2
000013B4  6100 FE40                779              BSR         getBits
000013B8                           780              
000013B8  B43C 0000                781              CMP.B       #%0,D2
000013BC  6700 0002                782              BEQ         MOVEM
000013C0                           783              
000013C0                           784         
000013C0                           785  MOVEM:
000013C0  43F9 00001EA7            786              LEA         printMOVEM,A1
000013C6  103C 000E                787              MOVE.B      #14,D0
000013CA  4E4F                     788              TRAP        #15
000013CC                           789              
000013CC                           790              ***Isolate Size Bit***
000013CC                           791              ;Clear D2 and recopy it to check for Size bit
000013CC  4282                     792              CLR.L       D2
000013CE  3412                     793              MOVE.W      (A2),D2
000013D0                           794              
000013D0                           795              ;Pass in paramters for isolating bit 6
000013D0  163C 0006                796              MOVE.B      #6,D3
000013D4  183C 0001                797              MOVE.B      #1,D4
000013D8                           798              
000013D8                           799              ;Jumps to getBits and returns with isolated bits in D2
000013D8  6100 FE1C                800              BSR         getBits
000013DC                           801              
000013DC                           802              ;Print size
000013DC  4EB9 00001C14            803              JSR         printMOVEMSize
000013E2                           804              
000013E2                           805              ***Isolate Direction bit
000013E2                           806              ;Clear D2 and recopy it to check for D bit
000013E2  4282                     807              CLR.L       D2
000013E4  3412                     808              MOVE.W      (A2),D2
000013E6                           809              
000013E6                           810              ;Pass in parameters for isolating bit 10
000013E6  163C 000A                811              MOVE.B      #10,D3
000013EA  183C 0001                812              MOVE.B      #1,D4
000013EE                           813              
000013EE                           814              ;Jumps to getBits and returns with isolated bits in D2
000013EE  6100 FE06                815              BSR         getBits
000013F2                           816  
000013F2                           817              ***Determine the direction of the instruction***
000013F2  B43C 0000                818              CMP.B       #0,D2
000013F6  6700 000A                819              BEQ         ListToMem
000013FA                           820  
000013FA                           821              ;Memory to Register List
000013FA  B43C 0001                822              CMP.B       #1,D2
000013FE  6700 003C                823              BEQ         MemToList  
00001402                           824                         
00001402                           825  
00001402                           826  
00001402                           827  ListToMem:
00001402                           828              ***SOURCE(Register List)  
00001402  4282                     829              CLR.L       D2
00001404                           830  
00001404                           831              ;A3 will act as our temp variable 
00001404  2678 0000                832              MOVE.L   $00000000,A3
00001408  364A                     833              MOVEA.W     A2,A3
0000140A                           834              
0000140A                           835              ;Go find the register list
0000140A  6100 0068                836              BSR         findList
0000140E                           837              
0000140E                           838              ;Print the comma after the source address
0000140E  43F9 00001F3F            839              LEA         printComma,A1
00001414  103C 000E                840              MOVE.B      #14,D0
00001418  4E4F                     841              TRAP        #15
0000141A                           842              
0000141A                           843              ***DESTINATION(Memory)
0000141A                           844              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
0000141A  4282                     845              CLR.L       D2
0000141C                           846              
0000141C  3412                     847              MOVE.W      (A2),D2
0000141E                           848              
0000141E                           849              ;Isolate bits 0 to 5
0000141E  4EB9 00001B9E            850              JSR         isolateAddressBit0to5
00001424                           851              
00001424  BC3C 0007                852              CMP.B       #%111,D6
00001428  6100 0046                853              BSR         absoluteAddressMOVEM
0000142C                           854              
0000142C                           855              ;Clear A6 since we will need this for later
0000142C  2C7C 00000000            856              MOVE.L      #00000000,A6
00001432                           857              
00001432                           858              ;Print memory address
00001432  6100 081A                859              BSR         addressModeSR
00001436                           860              
00001436  4283                     861              CLR.L      D3
00001438                           862              
00001438  6000 FDA6                863              BRA        update
0000143C                           864  
0000143C                           865              
0000143C                           866  MemToList:
0000143C                           867              ***SOURCE(Memory)***
0000143C                           868              ;Clear D2 and recopy it to check for bits 0-5 (to print memory addressing)
0000143C  4282                     869              CLR.L       D2            
0000143E                           870              
0000143E  3412                     871              MOVE.W      (A2),D2
00001440                           872              
00001440                           873              ;Use A3 as a temp address to be able to access the memory address
00001440  267C 00000000            874              MOVE.L      #00000000,A3
00001446  364A                     875              MOVEA.W     A2,A3
00001448                           876  
00001448                           877              ;Isolate addressing bits 0 to 5
00001448  4EB9 00001B9E            878              JSR         isolateAddressBit0to5
0000144E                           879              
0000144E  BC3C 0007                880              CMP.B       #%111,D6
00001452  6100 001C                881              BSR         absoluteAddressMOVEM
00001456                           882             
00001456                           883              ;Clear A6 since we will need this for later
00001456  2C7C 00000000            884              MOVE.L      #00000000,A6
0000145C                           885              
0000145C                           886              ;Print memory address
0000145C  6100 07F0                887              BSR         addressModeSR
00001460                           888              
00001460                           889              ;Print the comma after the source address
00001460  43F9 00001F3F            890              LEA         printComma,A1
00001466  103C 000E                891              MOVE.B      #14,D0
0000146A  4E4F                     892              TRAP        #15
0000146C                           893              
0000146C                           894              ;Go find the register list
0000146C  6000 0006                895              BRA         findList
00001470                           896              
00001470                           897  
00001470                           898              
00001470                           899              
00001470                           900  absoluteAddressMOVEM:
00001470  544A                     901              ADDA.W      #2,A2
00001472                           902  
00001472  4E75                     903              RTS                     
00001474                           904                
00001474                           905  findList:
00001474                           906              ;Set up the temp register to the register list
00001474  544B                     907              ADDA.W      #2,A3
00001476                           908  
00001476  3413                     909              MOVE.W      (A3),D2
00001478                           910  
00001478                           911              ;Clear some registers so we can have a counter
00001478                           912              ;and two registers to hold a beginning index and then ending index
00001478  4284                     913              CLR.L       D4
0000147A  4285                     914              CLR.L       D5
0000147C  4286                     915              CLR.L       D6
0000147E  4287                     916              CLR.L       D7  ;Holds the actual value for manipulation
00001480                           917              
00001480                           918              ;Set D7 to indicate we are doing the first bit check
00001480  3E13                     919              MOVE.W      (A3),D7
00001482                           920              
00001482                           921              
00001482                           922              ;===Setting Up Variables===
00001482                           923              ;Both of our index variables should start at 0
00001482  11FC 0000 100A           924              MOVE.B      #0,staIndex
00001488  11FC 0000 100B           925              MOVE.B      #0,endIndex
0000148E                           926              ;Indicate we are at the start of the word for our counter
0000148E  11FC 0000 1009           927              MOVE.B      #0,counter
00001494                           928              ;==========================
00001494                           929                       
00001494                           930              ;Go through a loop and rotate bits twice for the D registers
00001494  6100 0038                931              BSR         bitLoop
00001498                           932  
00001498                           933  check:
00001498  0C38 0000 100C           934              CMP.B       #0,(aRegDone)
0000149E  6700 0008                935              BEQ         findList2
000014A2                           936              
000014A2  4283                     937              CLR.L       D3
000014A4                           938              
000014A4  6000 FD3A                939              BRA         update
000014A8                           940              
000014A8                           941  findList2:           
000014A8  4287                     942              CLR.L       D7
000014AA  1E13                     943              MOVE.B      (A3),D7
000014AC                           944  
000014AC                           945              ;If we are not done with MOVEM, then the next time we get here, we will make sure we don't keep looping
000014AC  11FC 0001 100C           946              MOVE.B      #1,aRegDone
000014B2                           947              
000014B2                           948              ;===Setting Up Variables===
000014B2                           949              ;Use currentReg which indicates whether or not we are printing D or A
000014B2  11FC 0001 100D           950              MOVE.B      #1,dORa
000014B8                           951              ;Both of our index variables should start at 0
000014B8  11FC 0000 100A           952              MOVE.B      #0,staIndex
000014BE  11FC 0000 100B           953              MOVE.B      #0,endIndex
000014C4                           954              ;Indicate we are at the start of the word for our counter
000014C4  11FC 0000 1009           955              MOVE.B      #0,counter
000014CA                           956              ;==========================
000014CA                           957              
000014CA  6000 0002                958              BRA         bitLoop
000014CE                           959              
000014CE                           960  bitLoop:
000014CE                           961  
000014CE                           962              ;If our counter is 8, then we must finish printing the list
000014CE  0C38 0008 1009           963              CMP.B       #8,counter
000014D4  67C2                     964              BEQ         check
000014D6                           965  
000014D6  3407                     966              MOVE.W      D7,D2
000014D8                           967              
000014D8                           968              ;We will use getBits to get the right-most bit (Stored in D2)
000014D8  163C 0000                969              MOVE.B      #0,D3  ;The starting index of the word
000014DC  183C 0001                970              MOVE.B      #1,D4  ;How many bits we want
000014E0                           971  
000014E0  6100 FD14                972              BSR         getBits
000014E4                           973              
000014E4                           974              ;If the bit is 0, then that means we must print out some values
000014E4  B43C 0000                975              CMP.B       #0,D2
000014E8  6700 000E                976              BEQ         bitLoopHelper
000014EC                           977  
000014EC                           978              ;We can extend the ending index for our register range
000014EC  5238 100B                979              ADD.B       #1,endIndex
000014F0                           980   
000014F0                           981              ;If the bit is 1, then we just increment counter
000014F0  5238 1009                982              ADD.B       #1,counter
000014F4                           983              
000014F4                           984              ;Adjust the word to move onto the next bit to check
000014F4  E28F                     985              LSR.L       #1,D7 
000014F6                           986                     
000014F6                           987                     
000014F6                           988              ;Loop again
000014F6  60D6                     989              BRA         bitLoop
000014F8                           990  
000014F8                           991  bitLoopHelper:
000014F8                           992              ;If we are at the first bit, then just skip and go back
000014F8  1638 100A                993              MOVE.B      (staIndex),D3
000014FC  1838 100B                994              MOVE.B      (endIndex),D4
00001500  B803                     995              CMP.B        D3,D4
00001502  6700 0008                996              BEQ         skipFirst
00001506                           997              
00001506  6100 0014                998              BSR         timePrint
0000150A                           999              
0000150A  60C2                    1000              BRA         bitLoop
0000150C                          1001  
0000150C                          1002              
0000150C                          1003  skipFirst:
0000150C                          1004              ;Increment our starting index since the first bit was a 0
0000150C  5238 100A               1005              ADD.B       #1,staIndex
00001510                          1006              ;Increment the rest of our variables to set up the loop again
00001510  5238 100B               1007              ADD.B       #1,endIndex
00001514  5238 1009               1008              ADD.B       #1,counter
00001518  E28F                    1009              LSR.L       #1,D7
0000151A                          1010              
0000151A  60B2                    1011              BRA         bitLoop
0000151C                          1012  
0000151C                          1013  timePrint:            
0000151C                          1014              ;if D5 == D6 (meaning only one register to print)
0000151C                          1015              ;go to print single
0000151C  1A38 100A               1016              MOVE.B      (staIndex),D5
00001520  1C38 100B               1017              MOVE.B      (endIndex),D6
00001524  BC05                    1018              CMP.B       D5,D6
00001526  6700 0016               1019              BEQ         printSingle
0000152A                          1020  
0000152A                          1021              ;if we don't print a single register, then we print the range
0000152A                          1022              ;Check and see if we should print D or A
0000152A  0C38 0000 100D          1023              CMP.B       #0,(dORa)
00001530  6700 0088               1024              BEQ         printDReg
00001534                          1025              
00001534  0C38 0001 100D          1026              CMP.B       #1,(dORa)
0000153A  6700 00D4               1027              BEQ         printAReg
0000153E                          1028              
0000153E                          1029  printSingle:
0000153E                          1030              ;Check and see if we should print D or A
0000153E  0C38 0000 100D          1031              CMP.B       #0,(dORa)
00001544  6700 000C               1032              BEQ         singleDReg
00001548                          1033              
00001548  0C38 0001 100D          1034              CMP.B       #1,(dORa)
0000154E  6700 0036               1035              BEQ         singleAReg
00001552                          1036  
00001552                          1037  singleDReg:
00001552  43F9 00001F26           1038              LEA         printDRD,A1
00001558  103C 000E               1039              MOVE.B      #14,D0
0000155C  4E4F                    1040              TRAP        #15
0000155E                          1041  
0000155E                          1042              ;Print out the register number
0000155E  4281                    1043              CLR.L       D1
00001560  1238 100A               1044              MOVE.B      (staIndex),D1
00001564  103C 000F               1045              MOVE.B      #15,D0
00001568  143C 0010               1046              MOVE.B      #16,D2
0000156C  4E4F                    1047              TRAP        #15
0000156E                          1048              
0000156E  6100 0104               1049              BSR         pSlash
00001572                          1050              
00001572                          1051              ;Increment the rest of our variables to set up the loop again
00001572  5238 100B               1052              ADD.B       #1,endIndex
00001576                          1053              ;Since we printed out a range, we have a new starting index
00001576  11F8 100B 100A          1054              MOVE.B      endIndex,staIndex
0000157C                          1055              
0000157C  5238 1009               1056              ADD.B       #1,counter
00001580                          1057              
00001580  E28F                    1058              LSR.L       #1,D7
00001582                          1059              
00001582  6000 FF4A               1060              BRA         bitLoop
00001586                          1061  
00001586                          1062  
00001586                          1063  singleAReg:
00001586  43F9 00001F28           1064              LEA         printARD,A1
0000158C  103C 000E               1065              MOVE.B      #14,D0
00001590  4E4F                    1066              TRAP        #15
00001592                          1067  
00001592                          1068              ;Print out the register number
00001592  4281                    1069              CLR.L       D1
00001594  1238 100A               1070              MOVE.B      (staIndex),D1
00001598  103C 000F               1071              MOVE.B      #15,D0
0000159C  143C 0010               1072              MOVE.B      #16,D2
000015A0  4E4F                    1073              TRAP        #15
000015A2                          1074              
000015A2  6100 00D0               1075              BSR         pSlash
000015A6                          1076              
000015A6                          1077              ;Increment the rest of our variables to set up the loop again
000015A6  5238 100B               1078              ADD.B       #1,endIndex
000015AA                          1079              ;Since we printed out a range, we have a new starting index
000015AA  11F8 100B 100A          1080              MOVE.B      endIndex,staIndex
000015B0                          1081              
000015B0  5238 1009               1082              ADD.B       #1,counter
000015B4                          1083              
000015B4  E28F                    1084              LSR.L       #1,D7
000015B6                          1085              
000015B6  6000 FF16               1086              BRA         bitLoop
000015BA                          1087   
000015BA                          1088  printDReg:
000015BA  43F9 00001F26           1089              LEA         printDRD,A1
000015C0  103C 000E               1090              MOVE.B      #14,D0
000015C4  4E4F                    1091              TRAP        #15
000015C6                          1092  
000015C6                          1093              ;Print out the register number
000015C6  4281                    1094              CLR.L       D1
000015C8  1238 100A               1095              MOVE.B      (staIndex),D1
000015CC  103C 000F               1096              MOVE.B      #15,D0
000015D0  143C 0010               1097              MOVE.B      #16,D2
000015D4  4E4F                    1098              TRAP        #15
000015D6                          1099              
000015D6  6100 008E               1100              BSR         pDash
000015DA                          1101              
000015DA  43F9 00001F26           1102              LEA         printDRD,A1
000015E0  103C 000E               1103              MOVE.B      #14,D0
000015E4  4E4F                    1104              TRAP        #15
000015E6                          1105  
000015E6                          1106              ;Print out the end of the range
000015E6  4281                    1107              CLR.L       D1
000015E8  1238 100B               1108              MOVE.B      (endIndex),D1
000015EC  5301                    1109              SUB.B       #1,D1
000015EE                          1110              
000015EE  103C 000F               1111              MOVE.B      #15,D0
000015F2  143C 0010               1112              MOVE.B      #16,D2
000015F6  4E4F                    1113              TRAP        #15
000015F8                          1114              
000015F8  6100 007A               1115              BSR         pSlash
000015FC                          1116              
000015FC                          1117              ;Increment the rest of our variables to set up the loop again
000015FC  5238 100B               1118              ADD.B       #1,endIndex
00001600                          1119              ;Since we printed out a range, we have a new starting index
00001600  11F8 100B 100A          1120              MOVE.B      endIndex,staIndex
00001606                          1121              
00001606  5238 1009               1122              ADD.B       #1,counter
0000160A                          1123              
0000160A  E38F                    1124              LSL.L       #1,D7       
0000160C                          1125  
0000160C  6000 FEC0               1126              BRA         bitLoop
00001610                          1127  
00001610                          1128  printAReg:
00001610  43F9 00001F28           1129              LEA         printARD,A1
00001616  103C 000E               1130              MOVE.B      #14,D0
0000161A  4E4F                    1131              TRAP        #15
0000161C                          1132               
0000161C                          1133              ;Print out the register number
0000161C  4281                    1134              CLR.L       D1
0000161E  1238 100A               1135              MOVE.B      (staIndex),D1
00001622  103C 000F               1136              MOVE.B      #15,D0
00001626  143C 0010               1137              MOVE.B      #16,D2
0000162A  4E4F                    1138              TRAP        #15
0000162C                          1139              
0000162C  6100 0038               1140              BSR         pDash
00001630                          1141              
00001630  43F9 00001F28           1142              LEA         printARD,A1
00001636  103C 000E               1143              MOVE.B      #14,D0
0000163A  4E4F                    1144              TRAP        #15
0000163C                          1145              
0000163C                          1146              ;Print out the end of the range
0000163C  4281                    1147              CLR.L       D1
0000163E  1238 100B               1148              MOVE.B      (endIndex),D1
00001642  5301                    1149              SUB.B       #1,D1
00001644                          1150  
00001644                          1151              
00001644  103C 000F               1152              MOVE.B      #15,D0
00001648  143C 0010               1153              MOVE.B      #16,D2
0000164C  4E4F                    1154              TRAP        #15
0000164E                          1155              
0000164E  6100 0024               1156              BSR         pSlash
00001652                          1157              
00001652                          1158              ;Increment the rest of our variables to set up the loop again
00001652  5238 100B               1159              ADD.B       #1,endIndex
00001656                          1160              ;Since we printed out a range, we have a new starting index
00001656  11F8 100B 100A          1161              MOVE.B      endIndex,staIndex
0000165C                          1162              
0000165C  5238 1009               1163              ADD.B       #1,counter
00001660                          1164  
00001660  E38F                    1165              LSL.L       #1,D7
00001662                          1166   
00001662  6000 FE6A               1167              BRA         bitLoop
00001666                          1168           
00001666                          1169  pDash:
00001666  43F9 00001F45           1170              LEA         printDash,A1
0000166C  103C 000E               1171              MOVE.B      #14,D0
00001670  4E4F                    1172              TRAP        #15
00001672                          1173              
00001672  4E75                    1174              RTS
00001674                          1175  pSlash:
00001674  43F9 00001F43           1176              LEA         printSlash,A1
0000167A  103C 000E               1177              MOVE.B      #14,D0
0000167E  4E4F                    1178              TRAP        #15
00001680                          1179              
00001680  4E75                    1180              RTS
00001682                          1181              
00001682                          1182  MLEA:
00001682  43F9 00001ECF           1183              LEA         printLEA,A1
00001688  103C 000E               1184              MOVE.B      #14,D0
0000168C  4E4F                    1185              TRAP        #15
0000168E                          1186              
0000168E                          1187              ;*SOURCE*
0000168E                          1188              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
0000168E                          1189              ;D6 will contain mode & D7 will contain the register after this instruction
0000168E  6100 050E               1190              BSR         isolateAddressBit0to5
00001692                          1191              
00001692                          1192              ;*Print source address*
00001692  6100 05BA               1193              BSR         addressModeSR
00001696                          1194              
00001696                          1195              ;Print comma after source address
00001696  43F9 00001F3F           1196              LEA         printComma,A1
0000169C  103C 000E               1197              MOVE.B      #14,D0
000016A0  4E4F                    1198              TRAP        #15
000016A2                          1199              
000016A2                          1200              ;*DESTINATION*
000016A2                          1201              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000016A2                          1202              ;D7 will contain the register after this instruction
000016A2  6100 0520               1203              BSR         isolateRegisterBit9to11
000016A6                          1204              
000016A6                          1205              ;Save #%001 into D6 to specify address register mode
000016A6  1C3C 0001               1206              MOVE.B      #1,D6
000016AA                          1207              
000016AA                          1208              
000016AA                          1209              ;*Print destination address*
000016AA  6100 05A2               1210              BSR         addressModeSR
000016AE                          1211  
000016AE  6000 FB30               1212              BRA        update
000016B2                          1213  
000016B2                          1214  MNOT:
000016B2                          1215              ;Distinguish NOT from "MOVE to SSR"                 
000016B2                          1216              
000016B2  4282                    1217              CLR.L      D2
000016B4                          1218              ;Move the address into the register to check for size
000016B4  3412                    1219              MOVE.W     (A2),D2
000016B6                          1220              
000016B6                          1221              ;Pass in parameters for isolating bits 6,7
000016B6  163C 0006               1222              MOVE.B     #6,D3
000016BA  183C 0002               1223              MOVE.B     #2,D4
000016BE                          1224              
000016BE                          1225              ;Jump to getbits and return with isolated bits
000016BE  6100 FB36               1226              BSR        getbits
000016C2                          1227  
000016C2                          1228              ;This was meant for invalid opcode testing
000016C2                          1229              ;CMP.B      #%11,D2
000016C2                          1230              ;BRA        InOpCode     
000016C2                          1231  
000016C2  43F9 00001ED8           1232              LEA        printNOT,A1
000016C8  103C 000E               1233              MOVE.B     #14,D0
000016CC  4E4F                    1234              TRAP       #15    
000016CE                          1235              
000016CE                          1236              ;Jumps to printSizeSubroutine and returns after size has been printed
000016CE  6100 050C               1237              BSR        printSizeSubroutine
000016D2                          1238              
000016D2                          1239              ;*SOURCE*
000016D2                          1240              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000016D2                          1241              ;D6 will contain mode & D7 will contain the register after this instruction
000016D2  6100 04CA               1242              BSR        isolateAddressBit0to5
000016D6                          1243              
000016D6                          1244              ;*Print source address*
000016D6  6100 0576               1245              BSR        addressModeSR
000016DA                          1246              
000016DA  6000 FB04               1247              BRA        update 
000016DE                          1248  
000016DE                          1249  MJSR:
000016DE  43F9 00001EFD           1250              LEA        printJSR,A1
000016E4  103C 000E               1251              MOVE.B     #14,D0
000016E8  4E4F                    1252              TRAP       #15
000016EA                          1253              
000016EA                          1254              ;*SOURCE*
000016EA                          1255              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
000016EA                          1256              ;D6 will contain mode & D7 will contain the register after this instruction
000016EA  6100 04B2               1257              BSR        isolateAddressBit0to5
000016EE                          1258              
000016EE                          1259              ;*Print source address*
000016EE  6100 055E               1260              BSR        addressModeSR
000016F2                          1261              
000016F2  6000 FAEC               1262              BRA        update 
000016F6                          1263              
000016F6                          1264  
000016F6                          1265  *-----------------------------------------------------------
000016F6                          1266  * BRA,BLT,BGE,BEQ INSTRUCTIONS
000016F6                          1267  *-----------------------------------------------------------       
000016F6                          1268  M0110:
000016F6  4280                    1269              CLR.L       D0
000016F8  4281                    1270              CLR.L       D1
000016FA  4282                    1271              CLR.L       D2
000016FC  4283                    1272              CLR.L       D3
000016FE  4284                    1273              CLR.L       D4
00001700                          1274        
00001700                          1275              ;Moves the instruction into D2
00001700  3412                    1276              MOVE.W     (A2),D2
00001702                          1277              
00001702                          1278              ;Setting up parameters for getBits - isolating bits 11-8
00001702  163C 0008               1279              MOVE.B      #8,D3             ;Start bit index = 8
00001706  183C 0004               1280              MOVE.B      #4,D4             ;Number of bits needed = 4
0000170A                          1281              
0000170A                          1282              ;calls getBits subroutine, D2 now has the four condition bits of the Bcc/BRA instruction. 
0000170A  6100 FAEA               1283              BSR         getBits
0000170E                          1284              
0000170E                          1285              ;If the condition bits are 0000, the instruction is a BRA instruction. 
0000170E  B4BC 00000000           1286              CMP.L       #%0000,D2
00001714  6700 002A               1287              BEQ         MBRA
00001718                          1288              
00001718                          1289              ;0100 = BCC
00001718  B4BC 00000004           1290              CMP.L       #%0100,D2
0000171E  6700 0030               1291              BEQ         MBCC
00001722                          1292              
00001722                          1293              ;1101 = BLT
00001722  B4BC 0000000D           1294              CMP.L       #%1101,D2
00001728  6700 0036               1295              BEQ         MBLT
0000172C                          1296              
0000172C                          1297              ;1100 = BGE
0000172C  B4BC 0000000C           1298              CMP.L       #%1100,D2
00001732  6700 003C               1299              BEQ         MBGE
00001736                          1300              
00001736                          1301              ;0111 = BEQ
00001736  B4BC 00000007           1302              CMP.L       #%0111,D2
0000173C  6700 0042               1303              BEQ         MBEQ
00001740                          1304  
00001740                          1305  MBRA:
00001740                          1306      ;condition bits (11-8) are 0000
00001740  43F9 00001F06           1307              LEA         printBRA,A1
00001746  103C 000E               1308              MOVE.B      #14,D0
0000174A  4E4F                    1309              TRAP        #15
0000174C                          1310              
0000174C  6000 0042               1311              BRA         bccOffset
00001750                          1312  
00001750                          1313  MBCC:
00001750                          1314      ;condition bits (11-8) are 0100     
00001750  43F9 00001EF8           1315              LEA         printBCC,A1
00001756  103C 000E               1316              MOVE.B      #14,D0
0000175A  4E4F                    1317              TRAP        #15
0000175C                          1318  
0000175C  6000 0032               1319              BRA         bccOffset
00001760                          1320  
00001760                          1321  MBLT:
00001760                          1322      ;condition bits (11-8) are 1101
00001760  43F9 00001EEC           1323              LEA         printBLT,A1
00001766  103C 000E               1324              MOVE.B      #14,D0
0000176A  4E4F                    1325              TRAP        #15
0000176C                          1326              
0000176C  6000 0022               1327              BRA         bccOffset
00001770                          1328  
00001770                          1329  MBGE:
00001770                          1330      ;condition bits (11-8) are 1100
00001770  43F9 00001EF0           1331              LEA         printBGE,A1
00001776  103C 000E               1332              MOVE.B      #14,D0
0000177A  4E4F                    1333              TRAP        #15
0000177C                          1334              
0000177C  6000 0012               1335              BRA         bccOffset
00001780                          1336  
00001780                          1337  MBEQ:            
00001780                          1338      ;condition bits (11-8) are 0111
00001780  43F9 00001EF4           1339              LEA         printBEQ,A1
00001786  103C 000E               1340              MOVE.B      #14,D0
0000178A  4E4F                    1341              TRAP        #15
0000178C                          1342              
0000178C  6000 0002               1343              BRA         bccOffset         
00001790                          1344  
00001790                          1345  bccOffset:
00001790                          1346      ;each variation of Bcc, BLT, BEQ, BRA, etc has the same format for the offset bits. Bits 0-7 are either the offset themself, or
00001790                          1347      ;tell us where to look. If it contains $00, then 16-bit offset. If it contains $FF, 32-bit offset.
00001790                          1348      
00001790                          1349              ;Moves the branch family instruction into D2
00001790  3412                    1350              MOVE.W     (A2),D2
00001792                          1351              
00001792                          1352              ;Setting up parameters for getBits - isolating bits 0-7
00001792  163C 0000               1353              MOVE.B      #0,D3             ;Start bit index = 0
00001796  183C 0008               1354              MOVE.B      #8,D4             ;Number of bits needed = 8
0000179A                          1355  
0000179A                          1356              ;calls getBits subroutine, D2 now has the offset bits
0000179A  6100 FA5A               1357              BSR         getBits
0000179E                          1358              
0000179E                          1359              ;If the offset bits are $00, we need to look at the next 16 bits for the offset.
0000179E  B4BC 00000000           1360              CMP.L       #%00000000,D2
000017A4  6700 0048               1361              BEQ         bit16Displacement
000017A8                          1362              
000017A8                          1363              ;If the offset bits are $FF, we need to look at the next 32 bits for the offset.
000017A8  B4BC 000000FF           1364              CMP.L       #%11111111,D2
000017AE  6700 0080               1365              BEQ         bit32Displacement
000017B2                          1366              
000017B2                          1367              ;If neither of the above two cases are true, we continue to 8bitDisplacement. 
000017B2                          1368              
000017B2                          1369  bit8Displacement:
000017B2                          1370              ;We're here if the 8-bit displacement isn't $00 or $FF, and D2 already has the offset bits.
000017B2                          1371              ;D2 is a twos complement integer specifying the number of bytes between the branch instruction 
000017B2                          1372              ;and the next instruction to be executed (if the condition is met) 
000017B2                          1373              
000017B2                          1374              ;A2 is the address of the current instruction we're working with
000017B2  2C4A                    1375              MOVEA.L      A2,A6
000017B4                          1376            
000017B4  B43C 0080               1377              CMP.B       #$80,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000017B8  6C00 000C               1378              BGE         sub8Bits
000017BC                          1379              
000017BC  6000 0002               1380              BRA         add8Bits
000017C0                          1381  
000017C0                          1382  add8Bits:
000017C0  DCC2                    1383              ADD.W       D2,A6
000017C2  6000 000C               1384              BRA         continue8Bits
000017C6                          1385  sub8Bits:
000017C6                          1386              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
000017C6  4602                    1387              NOT.B       D2      ;inverts D2
000017C8  5302                    1388              SUB.B       #1, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
000017CA                          1389                                  ;account for the length of the instruction's opperation, which is 2 bytes, so we subtract 1.
000017CA  9CC2                    1390              SUB.W       D2,A6   
000017CC                          1391              
000017CC  6000 0002               1392              BRA         continue8Bits
000017D0                          1393  
000017D0                          1394  continue8Bits:
000017D0                          1395              
000017D0                          1396              ;Output $
000017D0  43F9 00001F31           1397              LEA         printA,A1
000017D6  103C 000E               1398              MOVE.B      #14,D0
000017DA  4E4F                    1399              TRAP        #15
000017DC                          1400              
000017DC                          1401              ;Output destination address
000017DC  7410                    1402              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
000017DE  700F                    1403              MOVE.L      #15,D0  ;task number
000017E0  220E                    1404              MOVE.L      A6,D1
000017E2  4E4F                    1405              TRAP        #15
000017E4                          1406              
000017E4  2C7C 00000000           1407              MOVE.L      #$0,A6
000017EA  6000 F9F4               1408              BRA         update
000017EE                          1409  bit16Displacement:
000017EE                          1410              ;Getting the next 16 bits
000017EE  341A                    1411              MOVE.W      (A2)+,D2
000017F0  3412                    1412              MOVE.W      (A2),D2
000017F2  2C4A                    1413              MOVEA.L      A2,A6
000017F4                          1414            
000017F4  B4BC 00008000           1415              CMP.L       #$8000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
000017FA  6C00 000C               1416              BGE         sub16Bits
000017FE                          1417              
000017FE  6000 0002               1418              BRA         add16Bits
00001802                          1419  
00001802                          1420              
00001802                          1421  add16Bits: 
00001802  DCC2                    1422              ADD.W       D2,A6
00001804  6000 000C               1423              BRA         continue16Bits
00001808                          1424  
00001808                          1425  sub16Bits:  
00001808                          1426              ;If the displacement is negative, convert it into a regular value and subtract it from the address.
00001808  4642                    1427              NOT.W       D2      ;inverts D2
0000180A  5742                    1428              SUB.W       #3, D2  ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000180C                          1429                                  ;account for the length of the instruction's opperation, which is 4 bytes, so we subtract 3.
0000180C  9CC2                    1430              SUB.W       D2,A6   
0000180E  6000 0002               1431              BRA         continue16Bits
00001812                          1432              
00001812                          1433  continue16Bits:
00001812                          1434              ;Output $
00001812  43F9 00001F31           1435              LEA         printA,A1
00001818  103C 000E               1436              MOVE.B      #14,D0
0000181C  4E4F                    1437              TRAP        #15
0000181E                          1438              
0000181E                          1439              ;Output destination addres
0000181E  7410                    1440              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
00001820  700F                    1441              MOVE.L      #15,D0  ;task number
00001822  220E                    1442              MOVE.L      A6,D1
00001824  4E4F                    1443              TRAP        #15
00001826                          1444              
00001826  2C7C 00000000           1445              MOVE.L      #$0,A6
0000182C  6000 F9B2               1446              BRA         update
00001830                          1447              
00001830                          1448  bit32Displacement:      ;Getting the next 32 bits
00001830  241A                    1449              MOVE.L      (A2)+,D2
00001832  2412                    1450              MOVE.L      (A2),D2
00001834  2C4A                    1451              MOVEA.L     A2,A6
00001836                          1452            
00001836  B4BC 80000000           1453              CMP.L       #$80000000,D2   ;Check to see if the two's complement value is positive/negative, and branch accordingly.
0000183C  6C00 000C               1454              BGE         sub32Bits
00001840                          1455              
00001840  6000 0002               1456              BRA         add32Bits
00001844                          1457  
00001844                          1458  add32Bits:
00001844  DDC2                    1459              ADD.L       D2,A6
00001846  6000 000C               1460              BRA         continue32Bits
0000184A                          1461  
0000184A                          1462  sub32Bits:              ;If the displacement is negative, convert it into a regular value and subtract it from the address. 
0000184A  4682                    1463              NOT.L       D2      ;inverts D2
0000184C  5B82                    1464              SUB.L       #5,D2   ;usually we would add 1 to turn this two's complement into a regular number, but we have to 
0000184E                          1465                                  ;account for the length of the instruction's opperation, which is 6 bytes, so we subtract 5.
0000184E  9DC2                    1466              SUB.L       D2,A6   
00001850  6000 0002               1467              BRA         continue32Bits
00001854                          1468  
00001854                          1469  continue32Bits:      
00001854                          1470              ;Output $
00001854  43F9 00001F31           1471              LEA         printA,A1
0000185A  103C 000E               1472              MOVE.B      #14,D0
0000185E  4E4F                    1473              TRAP        #15
00001860                          1474              
00001860                          1475              ;Output destination addres
00001860  7410                    1476              MOVE.L      #16,D2  ;sets the base for output - hexadecimal
00001862  700F                    1477              MOVE.L      #15,D0  ;task number
00001864  220E                    1478              MOVE.L      A6,D1
00001866  4E4F                    1479              TRAP        #15
00001868                          1480        
00001868  2C7C 00000000           1481              MOVE.L      #$0,A6      
0000186E  6000 F970               1482              BRA         update
00001872                          1483  
00001872                          1484  *-----------------------------------------------------------
00001872                          1485  * DIVU INSTRUCTION
00001872                          1486  *-----------------------------------------------------------           
00001872                          1487  M1000:
00001872                          1488              
00001872  4282                    1489              CLR.L       D2
00001874  4283                    1490              CLR.L       D3
00001876                          1491              
00001876                          1492              ;Copy the address values into a register
00001876  3412                    1493              MOVE.W     (A2),D2
00001878                          1494              
00001878                          1495              ;Passing in parameters for isolating bits 6,7,8
00001878  163C 0006               1496              MOVE.B      #6,D3             ;Start bit index = 6
0000187C  183C 0003               1497              MOVE.B      #3,D4             ;Number of bits needed = 3
00001880                          1498              
00001880                          1499              ;Jumps to getBits and returns with isolated bits in D2
00001880  6100 F974               1500              BSR         getBits
00001884                          1501              
00001884                          1502              ;If bits 6,7,8 are #%011, then it's DIVU. Otherwise, branch to error message
00001884  B4BC 00000003           1503              CMP.L       #%011,D2
0000188A  6700 0002               1504              BEQ         continueDIVU
0000188E                          1505              
0000188E                          1506              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT DIVU**************
0000188E                          1507  
0000188E                          1508  continueDIVU:
0000188E                          1509  
0000188E  43F9 00001EC7           1510              LEA         printDIVU,A1
00001894  103C 000E               1511              MOVE.B      #14,D0
00001898  4E4F                    1512              TRAP        #15
0000189A                          1513              
0000189A  6000 02BA               1514              BRA         dnDest
0000189E                          1515              
0000189E                          1516              
0000189E                          1517  *-----------------------------------------------------------
0000189E                          1518  * SUB INSTRUCTION
0000189E                          1519  *-----------------------------------------------------------  
0000189E                          1520  M1001:
0000189E  43F9 00001EB6           1521              LEA        printSUB,A1
000018A4  103C 000E               1522              MOVE.B     #14,D0
000018A8  4E4F                    1523              TRAP       #15
000018AA                          1524              
000018AA  4202                    1525              CLR.B      D2
000018AC  4203                    1526              CLR.B      D3
000018AE                          1527              
000018AE                          1528              ;======Isolate Size (S) Bits=======
000018AE                          1529              ;Copy the address values into a register
000018AE  3412                    1530              MOVE.W     (A2),D2
000018B0                          1531              
000018B0                          1532              ;Passing in parameters for isolating size bits
000018B0  163C 0006               1533              MOVE.B      #6,D3             ;Start bit index = 6
000018B4  183C 0002               1534              MOVE.B      #2,D4             ;Number of bits needed = 2
000018B8                          1535              
000018B8                          1536              ;Jumps to getBits and returns with isolated bits in D2
000018B8  6100 F93C               1537              BSR         getBits  
000018BC                          1538              
000018BC                          1539              ;Jumps to printSizeSubroutine and returns after size has been printed
000018BC  6100 031E               1540              BSR         printSizeSubroutine
000018C0                          1541              
000018C0                          1542              ;Let's store the size indicator since it will help us determine how many times
000018C0                          1543              ;we have to iterate through addresses to print out the whole instruction
000018C0                          1544              ;We will use A4 as the register to temporary store the size
000018C0  3842                    1545              MOVE.W      D2,A4
000018C2  11C2 2000               1546              MOVE.B      D2,$2000
000018C6                          1547              
000018C6                          1548              ;======Isolate direction (D) Bit=======
000018C6                          1549              ; 0 = data register is destination | 1 = Dn is source
000018C6  4282                    1550              CLR.L       D2
000018C8                          1551              
000018C8                          1552              ;Copy the address values into a register
000018C8  3412                    1553              MOVE.W      (A2),D2
000018CA                          1554              
000018CA                          1555              ;Passing in parameters for isolating direction bit
000018CA  163C 0008               1556              MOVE.B      #8,D3             ;Start bit index = 8
000018CE  183C 0001               1557              MOVE.B      #1,D4             ;Number of bits needed = 1
000018D2                          1558              
000018D2                          1559              ;Jumps to getBits and returns with isolated bit in D2
000018D2  6100 F922               1560              BSR         getBits
000018D6                          1561              
000018D6                          1562              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
000018D6  B43C 0000               1563              CMP.B       #0,D2
000018DA  6700 027A               1564              BEQ         dnDest
000018DE  6000 029A               1565              BRA         dnSource
000018E2                          1566  
000018E2                          1567  
000018E2                          1568  *-----------------------------------------------------------
000018E2                          1569  * MULS,AND INSTRUCTIONS
000018E2                          1570  *-----------------------------------------------------------  
000018E2                          1571  M1100:      
000018E2  4282                    1572              CLR.L       D2
000018E4  4283                    1573              CLR.L       D3
000018E6                          1574              
000018E6                          1575              ;Copy the address values into a register
000018E6  3412                    1576              MOVE.W     (A2),D2
000018E8                          1577              
000018E8                          1578              ;Passing in parameters for isolating bits 6 and 7
000018E8  163C 0006               1579              MOVE.B      #6,D3             ;Start bit index = 6
000018EC  183C 0002               1580              MOVE.B      #2,D4             ;Number of bits needed = 2
000018F0                          1581              
000018F0                          1582              ;Jumps to getBits and returns with isolated bits in D2
000018F0  6100 F904               1583              BSR         getBits  
000018F4                          1584              
000018F4                          1585              ;If bits 6 & 7 are not #%11 then the opcode is MAND. If they are, then check 8th bit to determine if its MULS
000018F4  B43C 0003               1586              CMP.B       #%11,D2
000018F8  6700 0006               1587              BEQ         mulsCheck
000018FC  6000 0028               1588              BRA         MAND
00001900                          1589              
00001900                          1590  mulsCheck:
00001900                          1591              ;Copy the address values into a register
00001900  3412                    1592              MOVE.W     (A2),D2
00001902                          1593              
00001902                          1594              ;Passing in parameters for isolating bit 8
00001902  163C 0008               1595              MOVE.B      #8,D3             ;Start bit index = 8
00001906  183C 0001               1596              MOVE.B      #1,D4             ;Number of bits needed = 1
0000190A                          1597              
0000190A                          1598              ;Jumps to getBits and returns with isolated bits in D2
0000190A  6100 F8EA               1599              BSR         getBits 
0000190E                          1600              
0000190E                          1601              ;If 8th bit is 1 then branch to MULS. Otherwise, print error
0000190E  B43C 0001               1602              CMP.B       #1,D2
00001912  6700 0002               1603              BEQ         MMULS
00001916                          1604              
00001916                          1605              ;************TO DO: BRANCH TO ERROR MESSAGE IF NOT MULS**************
00001916                          1606  
00001916                          1607              
00001916                          1608              
00001916                          1609              
00001916                          1610  MMULS:
00001916  43F9 00001EBF           1611              LEA         printMULS,A1
0000191C  103C 000E               1612              MOVE.B      #14,D0
00001920  4E4F                    1613              TRAP        #15
00001922                          1614              
00001922  6000 0232               1615              BRA         dnDest 
00001926                          1616  
00001926                          1617  
00001926                          1618  MAND:
00001926  43F9 00001ED4           1619              LEA        printAND,A1
0000192C  103C 000E               1620              MOVE.B     #14,D0
00001930  4E4F                    1621              TRAP       #15
00001932                          1622              
00001932                          1623              ;D2 already contains the size bits for AND (bits 6,7) so no need for isolating again
00001932                          1624              ;Jumps to printSizeSubroutine and returns after size has been printed
00001932  6100 02A8               1625              BSR         printSizeSubroutine
00001936                          1626              
00001936                          1627              ;======Isolate direction (D) Bit=======
00001936                          1628              ; 0 = data register is destination | 1 = Dn is source
00001936  4282                    1629              CLR.L       D2
00001938                          1630              
00001938                          1631              ;Copy the address values into a register
00001938  3412                    1632              MOVE.W      (A2),D2
0000193A                          1633              
0000193A                          1634              ;Passing in parameters for isolating direction bit
0000193A  163C 0008               1635              MOVE.B      #8,D3           ;Start bit index = 8
0000193E  183C 0001               1636              MOVE.B      #1,D4           ;Number of bits needed = 1
00001942                          1637  
00001942                          1638              ;Jumps to getBits and returns with isolated bit in D2
00001942  6100 F8B2               1639              BSR         getBits
00001946                          1640              
00001946                          1641              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001946  B43C 0000               1642              CMP.B       #0,D2
0000194A  6700 020A               1643              BEQ         dnDest
0000194E  6000 022A               1644              BRA         dnSource
00001952                          1645              
00001952                          1646              
00001952  6000 F88C               1647              BRA         update          ;Unnecessary with current implementation. dnDest & dnSource will call it instead
00001956                          1648     
00001956                          1649     
00001956                          1650  *-----------------------------------------------------------
00001956                          1651  * LSL,LSR,ASL,ASR INSTRUCTIONS
00001956                          1652  *-----------------------------------------------------------  
00001956                          1653  M1110:
00001956  4282                    1654              CLR.L       D2
00001958  4283                    1655              CLR.L       D3
0000195A                          1656              
0000195A                          1657              ;Copy the address values into a register
0000195A  3412                    1658              MOVE.W     (A2),D2
0000195C                          1659              
0000195C                          1660              ;Passing in parameters for isolating bits 6-7
0000195C  163C 0006               1661              MOVE.B      #6,D3             ;Start bit index = 6
00001960  183C 0002               1662              MOVE.B      #2,D4             ;Number of bits needed = 2
00001964                          1663              
00001964                          1664              ;Jumps to getBits and returns with isolated bits in D2
00001964  6100 F890               1665              BSR         getBits  
00001968                          1666              
00001968                          1667              ;Check if Memory Shift
00001968  B43C 0003               1668              CMP.B       #%11,D2
0000196C  6700 00B8               1669              BEQ         MemShift
00001970                          1670              
00001970                          1671              ;If not Memory Shift, is a Register Shift
00001970                          1672              
00001970                          1673              ;Copy the address values into a register
00001970  3412                    1674              MOVE.W     (A2),D2
00001972                          1675              
00001972                          1676              ;Passing in parameters for isolating bit 3
00001972  163C 0003               1677              MOVE.B      #3,D3             ;Start bit index = 3
00001976  183C 0001               1678              MOVE.B      #1,D4             ;Number of bits needed = 1
0000197A                          1679              
0000197A                          1680              ;Jumps to getBits and returns with isolated bits in D2
0000197A  6100 F87A               1681              BSR         getBits  
0000197E                          1682              
0000197E                          1683              ;Checks if ASd
0000197E  B43C 0000               1684              CMP.B       #%0,D2
00001982  6700 00E8               1685              BEQ         RegAS
00001986                          1686              
00001986                          1687              ;Checks if LSd
00001986  B43C 0001               1688              CMP.B       #%1,D2
0000198A  6700 00E8               1689              BEQ         RegLS
0000198E                          1690  RegShift      
0000198E                          1691              ;Copy the address values into a register
0000198E  3412                    1692              MOVE.W     (A2),D2
00001990                          1693              
00001990                          1694              ;Passing in parameters for isolating bits 6-7
00001990  163C 0006               1695              MOVE.B      #6,D3             ;Start bit index = 6
00001994  183C 0002               1696              MOVE.B      #2,D4             ;Number of bits needed = 2
00001998                          1697              
00001998                          1698              ;Jumps to getBits and returns with isolated bits in D2
00001998  6100 F85C               1699              BSR         getBits  
0000199C                          1700              
0000199C                          1701              ;Print Size
0000199C  6100 023E               1702              BSR         printSizeSubroutine
000019A0                          1703              
000019A0                          1704              ;Copy the address values into a register
000019A0  3412                    1705              MOVE.W     (A2),D2
000019A2                          1706              
000019A2                          1707              ;Passing in parameters for isolating bit 5
000019A2  163C 0005               1708              MOVE.B      #5,D3             ;Start bit index = 5
000019A6  183C 0001               1709              MOVE.B      #1,D4             ;Number of bits needed = 1
000019AA                          1710              
000019AA                          1711              ;Jumps to getBits and returns with isolated bits in D2
000019AA  6100 F84A               1712              BSR         getBits  
000019AE                          1713              
000019AE                          1714              ;Checks if shift count is immediate
000019AE  B43C 0000               1715              CMP.B       #%0,D2
000019B2  6700 003C               1716              BEQ         ImmediateCount
000019B6                          1717              
000019B6                          1718              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
000019B6                          1719              ;D7 will contain the register after this instruction
000019B6  6100 020C               1720              BSR         isolateRegisterBit9to11
000019BA                          1721              
000019BA                          1722              ;Save #%000 into D6 to specify data register mode
000019BA  1C3C 0000               1723              MOVE.B      #0,D6
000019BE                          1724              
000019BE                          1725              ;*Print Shift Count address*
000019BE  6100 028E               1726              BSR         addressModeSR
000019C2                          1727  
000019C2  6100 0002               1728              BSR         RegShift2
000019C6                          1729  
000019C6                          1730  RegShift2   ;Print comma after shift count
000019C6  43F9 00001F3F           1731              LEA         printComma,A1
000019CC  103C 000E               1732              MOVE.B      #14,D0
000019D0  4E4F                    1733              TRAP        #15
000019D2                          1734              
000019D2                          1735              ;*Data Register to be Shifted*
000019D2  4282                    1736              CLR.L       D2
000019D4                          1737              
000019D4                          1738              ;Copy the address values into a register
000019D4  3412                    1739              MOVE.W      (A2),D2
000019D6                          1740              
000019D6                          1741              ;Passing in parameters for isolating bits 0-2
000019D6  163C 0000               1742              MOVE.B      #0,D3             ;Start bit index = 0
000019DA  183C 0003               1743              MOVE.B      #3,D4             ;Number of bits needed = 3
000019DE                          1744              
000019DE                          1745              ;Jumps to getBits and returns with isolated bits in D2
000019DE  6100 F816               1746              BSR         getBits
000019E2                          1747              
000019E2                          1748              ;Save Xn register bit into ***D7*** for later use in addressModeSR
000019E2  1E02                    1749              MOVE.B      D2,D7
000019E4                          1750              
000019E4                          1751              ;Save #%000 into D6 to specify data register mode
000019E4  1C3C 0000               1752              MOVE.B      #0,D6
000019E8                          1753              
000019E8                          1754              ;*Prints data register to be shifted*
000019E8  6100 0264               1755              BSR         addressModeSR
000019EC                          1756  
000019EC  6000 F7F2               1757              BRA         update
000019F0                          1758              
000019F0                          1759  ImmediateCount
000019F0                          1760              ;Print #$
000019F0  43F9 00001F2F           1761              LEA        printIA,A1
000019F6  103C 000E               1762              MOVE.B     #14,D0
000019FA  4E4F                    1763              TRAP       #15
000019FC                          1764              
000019FC                          1765              ;Copy the address values into a register
000019FC  3412                    1766              MOVE.W     (A2),D2
000019FE                          1767              
000019FE                          1768              ;Passing in parameters for isolating bits 9-11
000019FE  163C 0009               1769              MOVE.B      #9,D3             ;Start bit index = 9
00001A02  183C 0003               1770              MOVE.B      #3,D4             ;Number of bits needed = 3
00001A06                          1771              
00001A06                          1772              ;Jumps to getBits and returns with isolated bits in D2
00001A06  6100 F7EE               1773              BSR         getBits  
00001A0A                          1774              
00001A0A                          1775              ;Check if shift count is 8
00001A0A  B43C 0000               1776              CMP.B       #%000,D2
00001A0E  6700 0010               1777              BEQ         ShiftEight
00001A12                          1778              
00001A12  1202                    1779              MOVE.B      D2, D1
00001A14  6100 0002               1780              BSR         ImmediateCount2
00001A18                          1781             
00001A18                          1782  ImmediateCount2
00001A18                          1783              ;Print shift count
00001A18  103C 0003               1784              MOVE.B      #3,D0
00001A1C  4E4F                    1785              TRAP        #15
00001A1E  61A6                    1786              BSR         RegShift2
00001A20                          1787   
00001A20                          1788  ShiftEight  ;Move 8 into D1    
00001A20  123C 0008               1789              MOVE.B      #8, D1
00001A24  61F2                    1790              BSR         ImmediateCount2
00001A26                          1791                                     
00001A26                          1792  MemShift
00001A26                          1793              ;Copy the address values into a register
00001A26  3412                    1794              MOVE.W     (A2),D2
00001A28                          1795              
00001A28                          1796              ;Passing in parameters for isolating bit 9
00001A28  163C 0009               1797              MOVE.B      #9,D3             ;Start bit index = 9
00001A2C  183C 0001               1798              MOVE.B      #1,D4             ;Number of bits needed = 1
00001A30                          1799              
00001A30                          1800              ;Jumps to getBits and returns with isolated bits in D2
00001A30  6100 F7C4               1801              BSR         getBits  
00001A34                          1802              
00001A34                          1803              ;Checks if ASd
00001A34  B43C 0000               1804              CMP.B       #%0,D2
00001A38  6700 0022               1805              BEQ         MemAS
00001A3C                          1806              
00001A3C                          1807              ;Checks if LSd
00001A3C  B43C 0001               1808              CMP.B       #%1,D2
00001A40  6700 0022               1809              BEQ         MemLS
00001A44                          1810  
00001A44                          1811  MemShift2   
00001A44                          1812              ;Print Space
00001A44  43F9 00001F41           1813              LEA        printSpace,A1
00001A4A  103C 000E               1814              MOVE.B     #14,D0
00001A4E  4E4F                    1815              TRAP       #15
00001A50                          1816              
00001A50                          1817              ;*Memory Address*
00001A50                          1818              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001A50                          1819              ;D6 will contain mode & D7 will contain the register after this instruction
00001A50  6100 014C               1820              BSR         isolateAddressBit0to5
00001A54                          1821              
00001A54                          1822              ;*Print source address*
00001A54  6100 01F8               1823              BSR         addressModeSR
00001A58                          1824              
00001A58  6000 F786               1825              BRA         update
00001A5C                          1826              
00001A5C                          1827  MemAS       ;Print AS
00001A5C  6100 002C               1828              BSR         MAS      
00001A60  6100 0036               1829              BSR         MemDirectionSubroutine                
00001A64                          1830  
00001A64                          1831              
00001A64                          1832  MemLS       ;Print LS
00001A64  6100 0016               1833              BSR         MLS      
00001A68  6100 002E               1834              BSR         MemDirectionSubroutine
00001A6C                          1835              
00001A6C                          1836  RegAS       ;Print AS
00001A6C  6100 001C               1837              BSR         MAS      
00001A70  6100 0062               1838              BSR         RegDirectionSubroutine                
00001A74                          1839  
00001A74                          1840              
00001A74                          1841  RegLS       ;Print LS
00001A74  6100 0006               1842              BSR         MLS      
00001A78  6100 005A               1843              BSR         RegDirectionSubroutine
00001A7C                          1844  
00001A7C                          1845  MLS:
00001A7C  43F9 00001F0D           1846              LEA        printMLS,A1
00001A82  103C 000E               1847              MOVE.B     #14,D0
00001A86  4E4F                    1848              TRAP       #15
00001A88  4E75                    1849              RTS
00001A8A                          1850  MAS:
00001A8A  43F9 00001F0A           1851              LEA        printMAS,A1
00001A90  103C 000E               1852              MOVE.B     #14,D0
00001A94  4E4F                    1853              TRAP       #15
00001A96  4E75                    1854              RTS
00001A98                          1855  
00001A98                          1856  MemDirectionSubroutine
00001A98                          1857              ;Copy the address values into a register
00001A98  3412                    1858              MOVE.W     (A2),D2
00001A9A                          1859              
00001A9A                          1860              ;Passing in parameters for isolating bit 8
00001A9A  163C 0008               1861              MOVE.B      #8,D3             ;Start bit index = 8
00001A9E  183C 0001               1862              MOVE.B      #1,D4             ;Number of bits needed = 1
00001AA2                          1863              
00001AA2                          1864              ;Jumps to getBits and returns with isolated bits in D2
00001AA2  6100 F752               1865              BSR         getBits  
00001AA6                          1866              
00001AA6                          1867              ;Checks if Right
00001AA6  B43C 0000               1868              CMP.B       #%0,D2
00001AAA  6700 000A               1869              BEQ         MR
00001AAE                          1870              
00001AAE                          1871              ;Checks if Left
00001AAE  B43C 0001               1872              CMP.B       #%1,D2
00001AB2  6700 0010               1873              BEQ         ML
00001AB6                          1874                          
00001AB6  43F9 00001F12           1875  MR          LEA        printR,A1
00001ABC  103C 000E               1876              MOVE.B     #14,D0
00001AC0  4E4F                    1877              TRAP       #15
00001AC2  6180                    1878              BSR        MemShift2
00001AC4                          1879  
00001AC4  43F9 00001F10           1880  ML          LEA        printL,A1
00001ACA  103C 000E               1881              MOVE.B     #14,D0
00001ACE  4E4F                    1882              TRAP       #15
00001AD0  6100 FF72               1883              BSR        MemShift2
00001AD4                          1884              
00001AD4                          1885  RegDirectionSubroutine
00001AD4                          1886              ;Copy the address values into a register
00001AD4  3412                    1887              MOVE.W     (A2),D2
00001AD6                          1888              
00001AD6                          1889              ;Passing in parameters for isolating bit 8
00001AD6  163C 0008               1890              MOVE.B      #8,D3             ;Start bit index = 8
00001ADA  183C 0001               1891              MOVE.B      #1,D4             ;Number of bits needed = 1
00001ADE                          1892              
00001ADE                          1893              ;Jumps to getBits and returns with isolated bits in D2
00001ADE  6100 F716               1894              BSR         getBits  
00001AE2                          1895              
00001AE2                          1896              ;Checks if Right
00001AE2  B43C 0000               1897              CMP.B       #%0,D2
00001AE6  6700 000A               1898              BEQ         RR
00001AEA                          1899              
00001AEA                          1900              ;Checks if Left
00001AEA  B43C 0001               1901              CMP.B       #%1,D2
00001AEE  6700 0012               1902              BEQ         RL
00001AF2                          1903                          
00001AF2  43F9 00001F12           1904  RR          LEA        printR,A1
00001AF8  103C 000E               1905              MOVE.B     #14,D0
00001AFC  4E4F                    1906              TRAP       #15
00001AFE  6100 FE8E               1907              BSR        RegShift
00001B02                          1908  
00001B02  43F9 00001F10           1909  RL          LEA        printL,A1
00001B08  103C 000E               1910              MOVE.B     #14,D0
00001B0C  4E4F                    1911              TRAP       #15
00001B0E  6100 FE7E               1912              BSR        RegShift
00001B12                          1913  
00001B12                          1914  
00001B12                          1915  *-----------------------------------------------------------------------
00001B12                          1916  *-----------------------------------------------------------------------
00001B12                          1917  *-----------------------------------------------------------------------
00001B12                          1918  
00001B12                          1919  
00001B12                          1920  
00001B12                          1921  
00001B12                          1922  ;ADD
00001B12                          1923  M1101:
00001B12  43F9 00001EAD           1924              LEA        printADD,A1
00001B18  103C 000E               1925              MOVE.B     #14,D0
00001B1C  4E4F                    1926              TRAP       #15
00001B1E                          1927              
00001B1E  4202                    1928              CLR.B      D2
00001B20  4203                    1929              CLR.B      D3
00001B22                          1930              
00001B22                          1931              ;======Isolate Size (S) Bits=======
00001B22                          1932              ;Copy the address values into a register
00001B22  3412                    1933              MOVE.W     (A2),D2
00001B24                          1934              
00001B24                          1935              ;Passing in parameters for isolating size bits
00001B24  163C 0006               1936              MOVE.B      #6,D3             ;Start bit index = 6
00001B28  183C 0002               1937              MOVE.B      #2,D4             ;Number of bits needed = 2
00001B2C                          1938              
00001B2C                          1939              ;Jumps to getBits and returns with isolated bits in D2
00001B2C  6100 F6C8               1940              BSR         getBits  
00001B30                          1941              
00001B30                          1942              ;Jumps to printSizeSubroutine and returns after size has been printed
00001B30  6100 00AA               1943              BSR         printSizeSubroutine
00001B34                          1944         
00001B34                          1945              ;Let's store the size indicator since it will help us determine how many times
00001B34                          1946              ;we have to iterate through addresses to print out the whole instruction
00001B34                          1947              ;We will use A4 as the register to temporary store the size
00001B34  3842                    1948              MOVE.W      D2,A4
00001B36  11C2 2000               1949              MOVE.B      D2,$2000
00001B3A                          1950              
00001B3A                          1951              ;======Isolate direction (D) Bit=======
00001B3A                          1952              ; 0 = data register is destination | 1 = Dn is source
00001B3A  4282                    1953              CLR.L       D2
00001B3C                          1954              
00001B3C                          1955              ;Copy the address values into a register
00001B3C  3412                    1956              MOVE.W      (A2),D2
00001B3E                          1957              
00001B3E                          1958              ;Passing in parameters for isolating direction bit
00001B3E  163C 0008               1959              MOVE.B      #8,D3             ;Start bit index = 8
00001B42  183C 0001               1960              MOVE.B      #1,D4             ;Number of bits needed = 1
00001B46                          1961              
00001B46                          1962              ;Jumps to getBits and returns with isolated bit in D2
00001B46  6100 F6AE               1963              BSR         getBits
00001B4A                          1964              
00001B4A                          1965              ;Uses direction bit to see if Dn is the destination. Important because it determines the order in which we isolate and print the addressing bits.
00001B4A  B43C 0000               1966              CMP.B       #0,D2
00001B4E  6700 0006               1967              BEQ         dnDest
00001B52  6000 0026               1968              BRA         dnSource
00001B56                          1969              
00001B56                          1970  
00001B56                          1971  *-----------------------------------------------------------------
00001B56                          1972  * dnDest, dnSource, & other subroutines for isolating address bits
00001B56                          1973  *-----------------------------------------------------------------
00001B56                          1974  ;* dnDest,dnSource *
00001B56                          1975  ;For: MULS,AND,ADD,SUB,DIVU
00001B56                          1976  ;Used by instructions that require Dn as one of their addressing modes.
00001B56                          1977  ;dnDest isolates the addressing bits with Dn being the destination address
00001B56                          1978  ;dnSource isolates the addressing bits with Dn being the source address
00001B56                          1979  
00001B56                          1980  dnDest:
00001B56                          1981              ;**Used for isolating addressing bits when Dn is the destination**
00001B56                          1982              
00001B56                          1983              ;*SOURCE*
00001B56                          1984              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B56                          1985              ;D6 will contain mode & D7 will contain the register after this instruction
00001B56  6100 0046               1986              BSR         isolateAddressBit0to5
00001B5A                          1987              
00001B5A                          1988              ;*Print source address*
00001B5A  6100 00F2               1989              BSR         addressModeSR
00001B5E                          1990              
00001B5E                          1991              ;Print comma after source address
00001B5E  43F9 00001F3F           1992              LEA         printComma,A1
00001B64  103C 000E               1993              MOVE.B      #14,D0
00001B68  4E4F                    1994              TRAP        #15
00001B6A                          1995              
00001B6A                          1996              ;*DESTINATION*
00001B6A                          1997              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B6A                          1998              ;D7 will contain the register after this instruction
00001B6A  6100 0058               1999              BSR         isolateRegisterBit9to11
00001B6E                          2000              
00001B6E                          2001              ;Save #%000 into D6 to specify data register mode
00001B6E  1C3C 0000               2002              MOVE.B      #0,D6
00001B72                          2003              
00001B72                          2004              ;*Print destination address*
00001B72  6100 00DA               2005              BSR         addressModeSR
00001B76                          2006  
00001B76  6000 F668               2007              BRA         update
00001B7A                          2008              
00001B7A                          2009  dnSource:
00001B7A                          2010              ;**Used for isolating addressing bits when Dn is the destination**
00001B7A                          2011                          
00001B7A                          2012              ;*SOURCE*
00001B7A                          2013              ;Jumps to helper subroutine to isolates and return the register stored in bits 9 - 11
00001B7A                          2014              ;D7 will contain the register after this instruction
00001B7A  6100 0048               2015              BSR         isolateRegisterBit9to11
00001B7E                          2016              
00001B7E                          2017              ;Save #%000 into D6 to specify data register mode
00001B7E  1C3C 0000               2018              MOVE.B      #0,D6
00001B82                          2019              
00001B82                          2020              ;*Print Source address*
00001B82  6100 00CA               2021              BSR         addressModeSR
00001B86                          2022              
00001B86                          2023              ;Print comma after source address
00001B86  43F9 00001F3F           2024              LEA         printComma,A1
00001B8C  103C 000E               2025              MOVE.B      #14,D0
00001B90  4E4F                    2026              TRAP        #15
00001B92                          2027              
00001B92                          2028              ;*DESTINATION*
00001B92                          2029              ;Jumps to helper subroutine to isolates and return the address mode & register stored in bits 0 - 5
00001B92                          2030              ;D6 will contain mode & D7 will contain the register after this instruction
00001B92  6100 000A               2031              BSR         isolateAddressBit0to5
00001B96                          2032              
00001B96                          2033              ;*Print destination address*
00001B96  6100 00B6               2034              BSR         addressModeSR
00001B9A                          2035  
00001B9A  6000 F644               2036              BRA         update
00001B9E                          2037                     
00001B9E                          2038  isolateAddressBit0to5:
00001B9E                          2039  ;Helper subroutine for isolating the address stored within bits 0-5
00001B9E                          2040  ;Stores address mode in D6
00001B9E                          2041  ;Stores address register in D7
00001B9E                          2042  
00001B9E                          2043              ;======Isolate Effective Address Mode (M) Bits=======
00001B9E  4282                    2044              CLR.L       D2
00001BA0                          2045              
00001BA0                          2046              ;Copy the address values into a register
00001BA0  3412                    2047              MOVE.W      (A2),D2
00001BA2                          2048              
00001BA2                          2049              ;Passing in parameters for isolating Mode bits
00001BA2  163C 0003               2050              MOVE.B      #3,D3             ;Start bit index = 3
00001BA6  183C 0003               2051              MOVE.B      #3,D4             ;Number of bits needed = 3
00001BAA                          2052              
00001BAA                          2053              ;Jumps to getBits and returns with isolated bits in D2
00001BAA  4EB8 11F6               2054              JSR         getBits
00001BAE                          2055              
00001BAE                          2056              ;Save M bit into ***D6*** for later use in addressModeSubroutine
00001BAE  1C02                    2057              MOVE.B      D2,D6
00001BB0                          2058              
00001BB0                          2059                       
00001BB0                          2060              ;======Isolate Effective Address Register (Xn) Bits=======
00001BB0  4282                    2061              CLR.L       D2
00001BB2                          2062              
00001BB2                          2063              ;Copy the address values into a register
00001BB2  3412                    2064              MOVE.W      (A2),D2
00001BB4                          2065              
00001BB4                          2066              ;Passing in parameters for isolating Xn bits
00001BB4  163C 0000               2067              MOVE.B      #0,D3             ;Start bit index = 0
00001BB8  183C 0003               2068              MOVE.B      #3,D4             ;Number of bits needed = 3
00001BBC                          2069              
00001BBC                          2070              ;Jumps to getBits and returns with isolated bits in D2
00001BBC  6100 F638               2071              BSR         getBits
00001BC0                          2072              
00001BC0                          2073              ;Save Xn register bit into ***D7*** for later use in addressModeSR
00001BC0  1E02                    2074              MOVE.B      D2,D7
00001BC2                          2075              
00001BC2  4E75                    2076              RTS
00001BC4                          2077  
00001BC4                          2078  isolateRegisterBit9to11:
00001BC4                          2079  ;Helper subroutine for isolating the register stored within bits 9-11
00001BC4                          2080  ;Stores the address register in D7
00001BC4                          2081  
00001BC4                          2082              ;======Isolate Register Bits=======
00001BC4  4282                    2083              CLR.L       D2
00001BC6  4286                    2084              CLR.L       D6
00001BC8  4287                    2085              CLR.L       D7
00001BCA                          2086              
00001BCA                          2087              ;Copy the address values into a register
00001BCA  3412                    2088              MOVE.W      (A2),D2
00001BCC                          2089              
00001BCC                          2090              ;Passing in parameters for isolating register bits
00001BCC  163C 0009               2091              MOVE.B      #9,D3             ;Start bit index = 9
00001BD0  183C 0003               2092              MOVE.B      #3,D4             ;Number of bits needed = 3
00001BD4                          2093              
00001BD4                          2094              ;Jumps to getBits and returns with isolated bit in D2
00001BD4  6100 F620               2095              BSR         getBits
00001BD8                          2096              
00001BD8                          2097              ;Save register bit into ***D7*** for later use in addressModeSR
00001BD8  1E02                    2098              MOVE.B      D2,D7
00001BDA                          2099  
00001BDA  4E75                    2100              RTS
00001BDC                          2101              
00001BDC                          2102  *-----------------------------------------------------------
00001BDC                          2103  * Print Sizes
00001BDC                          2104  *-----------------------------------------------------------
00001BDC                          2105  printSizeSubroutine:
00001BDC                          2106              ;Prints the apporpriate size
00001BDC                          2107              ;PARAMETER:
00001BDC                          2108              ;D2 = the size bits
00001BDC                          2109              
00001BDC                          2110              ;Since MOVE uses different bits for size, we must check and see if the opcode is MOVE
00001BDC  B63C 0001               2111              CMP.B      #1,D3
00001BE0  6700 001A               2112              BEQ        printMOVESize
00001BE4                          2113              
00001BE4                          2114              ;Compare to which size is being moved for the opcode
00001BE4  B43C 0000               2115              CMP.B      #%00,D2
00001BE8  6700 003A               2116              BEQ        PByte
00001BEC                          2117              
00001BEC  B43C 0001               2118              CMP.B      #%01,D2
00001BF0  6700 0040               2119              BEQ        PWord
00001BF4                          2120              
00001BF4  B43C 0002               2121              CMP.B      #%10,D2
00001BF8  6700 0046               2122              BEQ        PLong
00001BFC                          2123           
00001BFC                          2124  printMOVESize:
00001BFC                          2125              ;Now that we know we have a MOVE opcode
00001BFC                          2126              ;Compare to which size is being moved for the opcode
00001BFC  B43C 0001               2127              CMP.B      #%01,D2
00001C00  6700 0022               2128              BEQ        PByte
00001C04                          2129  
00001C04  B43C 0003               2130              CMP.B      #%11,D2
00001C08  6700 0028               2131              BEQ        PWord            
00001C0C                          2132    
00001C0C  B43C 0002               2133              CMP.B      #%10,D2
00001C10  6700 002E               2134              BEQ        PLong
00001C14                          2135              
00001C14                          2136  printMOVEMSize:
00001C14                          2137              ;Now that we know we have a MOVEM opcode
00001C14                          2138              ;Compare to which size is being moved for the opcode
00001C14  B43C 0000               2139              CMP.B      #%0,D2
00001C18  6700 0018               2140              BEQ        PWord
00001C1C                          2141              
00001C1C  B43C 0001               2142              CMP.B      #%1,D2
00001C20  6700 001E               2143              BEQ        PLong
00001C24                          2144  
00001C24                          2145  PByte:
00001C24  43F9 00001F14           2146              LEA        printSIZEB,A1
00001C2A  103C 000E               2147              MOVE.B     #14,D0
00001C2E  4E4F                    2148              TRAP       #15
00001C30                          2149              
00001C30  4E75                    2150              RTS
00001C32                          2151  PWord:
00001C32  43F9 00001F18           2152              LEA        printSIZEW,A1
00001C38  103C 000E               2153              MOVE.B     #14,D0
00001C3C  4E4F                    2154              TRAP       #15
00001C3E                          2155              
00001C3E  4E75                    2156              RTS
00001C40                          2157  PLong:            
00001C40  43F9 00001F1E           2158              LEA        printSIZEL,A1
00001C46  103C 000E               2159              MOVE.B     #14,D0
00001C4A  4E4F                    2160              TRAP       #15
00001C4C                          2161              
00001C4C  4E75                    2162              RTS
00001C4E                          2163              
00001C4E                          2164  *-----------------------------------------------------------
00001C4E                          2165  * Addressing Mode Implementation
00001C4E                          2166  *-----------------------------------------------------------
00001C4E                          2167  addressModeSR:
00001C4E                          2168              ;Prints address according to the parameters passed in
00001C4E                          2169              ;PARAMETERS:
00001C4E                          2170              ;D6 = mode
00001C4E                          2171              ;D7 = register
00001C4E                          2172  
00001C4E                          2173              ;Data register direct
00001C4E  BC3C 0000               2174              CMP.B       #%000,D6
00001C52  6700 002A               2175              BEQ         DRD
00001C56                          2176              
00001C56                          2177              ;Address register direct
00001C56  BC3C 0001               2178              CMP.B       #%001,D6
00001C5A  6700 0036               2179              BEQ         ARD
00001C5E                          2180              
00001C5E                          2181              ;Address register indirect
00001C5E  BC3C 0002               2182              CMP.B       #%010,D6
00001C62  6700 0042               2183              BEQ         ARI
00001C66                          2184              
00001C66                          2185              ;Post Increment
00001C66  BC3C 0003               2186              CMP.B       #%011,D6
00001C6A  6700 005A               2187              BEQ         PI
00001C6E                          2188              
00001C6E                          2189              ;Pre Decrement
00001C6E  BC3C 0004               2190              CMP.B       #%100,D6
00001C72  6700 0072               2191              BEQ         PD
00001C76                          2192              
00001C76                          2193              ;Immediate/Absolute Addressing
00001C76  BC3C 0007               2194              CMP.B       #%111,D6
00001C7A  6700 008A               2195              BEQ         otherModes
00001C7E                          2196  DRD:
00001C7E                          2197              ;Print D __
00001C7E  43F9 00001F26           2198              LEA         printDRD,A1
00001C84  103C 000E               2199              MOVE.B      #14,D0
00001C88  4E4F                    2200              TRAP        #15
00001C8A                          2201              
00001C8A                          2202              ;Print register number
00001C8A  7003                    2203              MOVE.L      #3,D0
00001C8C  2207                    2204              MOVE.L      D7,D1
00001C8E  4E4F                    2205              TRAP        #15
00001C90                          2206              
00001C90  4E75                    2207              RTS
00001C92                          2208  ARD:
00001C92                          2209              ;Print A __
00001C92  43F9 00001F28           2210              LEA         printARD,A1
00001C98  103C 000E               2211              MOVE.B      #14,D0
00001C9C  4E4F                    2212              TRAP        #15
00001C9E                          2213              
00001C9E                          2214              ;Print register number
00001C9E  7003                    2215              MOVE.L      #3,D0
00001CA0  2207                    2216              MOVE.L      D7,D1
00001CA2  4E4F                    2217              TRAP        #15
00001CA4                          2218              
00001CA4  4E75                    2219              RTS
00001CA6                          2220  ARI:
00001CA6                          2221              ;Print (A __ )
00001CA6  43F9 00001F2A           2222              LEA         printARI,A1
00001CAC  103C 000E               2223              MOVE.B      #14,D0
00001CB0  4E4F                    2224              TRAP        #15
00001CB2                          2225              
00001CB2                          2226              ;Print register number
00001CB2  7003                    2227              MOVE.L      #3,D0
00001CB4  2207                    2228              MOVE.L      D7,D1
00001CB6  4E4F                    2229              TRAP        #15
00001CB8                          2230              
00001CB8                          2231              ;Print closing ')'
00001CB8  43F9 00001F2D           2232              LEA         printARI2,A1
00001CBE  103C 000E               2233              MOVE.B      #14,D0
00001CC2  4E4F                    2234              TRAP        #15
00001CC4                          2235              
00001CC4  4E75                    2236              RTS
00001CC6                          2237  PI:
00001CC6                          2238              ;Print (A __)+
00001CC6  43F9 00001F33           2239              LEA         printPI,A1
00001CCC  103C 000E               2240              MOVE.B      #14,D0
00001CD0  4E4F                    2241              TRAP        #15
00001CD2                          2242              
00001CD2                          2243              ;Print register number
00001CD2  7003                    2244              MOVE.L      #3,D0
00001CD4  2207                    2245              MOVE.L      D7,D1
00001CD6  4E4F                    2246              TRAP        #15
00001CD8                          2247              
00001CD8                          2248              ;Print closing ')+'
00001CD8  43F9 00001F36           2249              LEA         printPI2,A1
00001CDE  103C 000E               2250              MOVE.B      #14,D0
00001CE2  4E4F                    2251              TRAP        #15
00001CE4                          2252              
00001CE4  4E75                    2253              RTS
00001CE6                          2254  PD:
00001CE6                          2255              ;Print -(A __)
00001CE6  43F9 00001F39           2256              LEA         printPD,A1
00001CEC  103C 000E               2257              MOVE.B      #14,D0
00001CF0  4E4F                    2258              TRAP        #15
00001CF2                          2259              
00001CF2                          2260              ;Print register number
00001CF2  7003                    2261              MOVE.L      #3,D0
00001CF4  2207                    2262              MOVE.L      D7,D1
00001CF6  4E4F                    2263              TRAP        #15
00001CF8                          2264              
00001CF8                          2265              ;Print closing ')'
00001CF8  43F9 00001F3D           2266              LEA         printPD2,A1
00001CFE  103C 000E               2267              MOVE.B      #14,D0
00001D02  4E4F                    2268              TRAP        #15
00001D04                          2269              
00001D04  4E75                    2270              RTS
00001D06                          2271  
00001D06                          2272  otherModes:
00001D06  B4CE                    2273              CMP.W       A6,A2
00001D08                          2274              
00001D08  6D00 0004               2275              BLT         SKIPCOPY  
00001D0C                          2276  
00001D0C                          2277               *=====Important step for making sure we have access to where A2 orignally points=====*
00001D0C  2C4A                    2278              MOVEA.L     A2,A6 
00001D0E                          2279  
00001D0E                          2280  
00001D0E                          2281  SKIPCOPY:            
00001D0E                          2282              
00001D0E                          2283              ;Branch to Immediate if register bits are %100       
00001D0E  BE3C 0004               2284              CMP.B       #%100,D7
00001D12  6700 0006               2285              BEQ         Immediate
00001D16                          2286              
00001D16                          2287              ;Otherwise, branch to Absolute
00001D16  6000 0022               2288              BRA         Absolute
00001D1A                          2289              
00001D1A                          2290          
00001D1A                          2291                     
00001D1A                          2292  Immediate:
00001D1A                          2293              ;Print #
00001D1A  43F9 00001F2F           2294              LEA         printIA,A1
00001D20  103C 000E               2295              MOVE.B      #14,D0
00001D24  4E4F                    2296              TRAP        #15
00001D26                          2297              
00001D26                          2298              ;Since we are dealing with addresses, we update our address to account for the actual address value
00001D26                          2299              ;We will be able to access the contents of either size B or W
00001D26  544A                    2300              ADDA.W      #2,A2         
00001D28                          2301  
00001D28                          2302              ;If the value is a Long then branch to ImmLong to get the remaining bits of the value
00001D28  0C38 0002 2000          2303              CMP.B       #%10,$2000
00001D2E  6700 0048               2304              BEQ         IMDLong
00001D32                          2305              
00001D32                          2306              ;If we don't branch, then we assume we're printing out a byte or word      
00001D32  7003                    2307              MOVE.L      #3,D0
00001D34  3212                    2308              MOVE.W      (A2),D1
00001D36  4E4F                    2309              TRAP        #15
00001D38                          2310              
00001D38  4E75                    2311              RTS
00001D3A                          2312              
00001D3A                          2313              
00001D3A                          2314              
00001D3A                          2315  Absolute:
00001D3A                          2316              ;Print $
00001D3A  43F9 00001F31           2317              LEA         printA,A1
00001D40  103C 000E               2318              MOVE.B      #14,D0
00001D44  4E4F                    2319              TRAP        #15
00001D46                          2320              
00001D46                          2321              ;Point to the next word (contains memory address)
00001D46  544E                    2322              ADDA.W      #2,A6
00001D48                          2323              
00001D48                          2324              ;If the value is a Long then branch to AbsLong to get the remaining bits of the value
00001D48  BE3C 0001               2325              CMP.B       #%001,D7
00001D4C  6700 0012               2326              BEQ         AbsLong
00001D50                          2327              
00001D50                          2328              ;Print out the value in the address if it's a word
00001D50  4281                    2329              CLR.L       D1
00001D52                          2330              
00001D52  303C 000F               2331              MOVE.W      #15,D0
00001D56  343C 0010               2332              MOVE.W      #16,D2
00001D5A  3216                    2333              MOVE.W      (A6),D1
00001D5C  4E4F                    2334              TRAP        #15
00001D5E                          2335              
00001D5E  4E75                    2336              RTS
00001D60                          2337              
00001D60                          2338  AbsLong:            
00001D60                          2339              ;Place the current value into a temp register
00001D60  3816                    2340              MOVE.W      (A6),D4
00001D62                          2341              
00001D62                          2342              ;Shift the bits so we can enter the rest of the values
00001D62  1E3C 0010               2343              MOVE.B      #16,D7
00001D66  EFAC                    2344              LSL.L       D7,D4
00001D68                          2345              
00001D68                          2346              ;Increment A6 to account for the next values in the instruction
00001D68  544E                    2347              ADDA.W      #2,A6
00001D6A                          2348              
00001D6A                          2349              ;Move the rest of the machine code into our register
00001D6A                          2350              ;This register should have the whole long values
00001D6A  3816                    2351              MOVE.W      (A6),D4
00001D6C                          2352              
00001D6C                          2353              ;Print the Long address
00001D6C  4281                    2354              CLR.L       D1
00001D6E                          2355              
00001D6E  700F                    2356              MOVE.L      #15,D0
00001D70  7410                    2357              MOVE.L      #16,D2
00001D72  2204                    2358              MOVE.L      D4,D1
00001D74  4E4F                    2359              TRAP        #15
00001D76                          2360              
00001D76  4E75                    2361              RTS    
00001D78                          2362          
00001D78                          2363  IMDLong:
00001D78                          2364              *********USED FOR IMMEDIATE LONGS ONLY***************
00001D78                          2365              
00001D78                          2366              ;Place the current value into a temp register
00001D78  3812                    2367              MOVE.W      (A2),D4
00001D7A                          2368              
00001D7A                          2369              ;Shift the bits so we can enter the rest of the values
00001D7A  1E3C 0010               2370              MOVE.B      #16,D7
00001D7E  EFAC                    2371              LSL.L       D7,D4
00001D80                          2372              
00001D80                          2373              ;Increment A2 to account for the next values in the machine code
00001D80  544A                    2374              ADDA.W      #2,A2
00001D82                          2375              
00001D82                          2376              ;Move the rest of the machine code into our register
00001D82                          2377              ;This register should have the whole long values
00001D82  3812                    2378              MOVE.W      (A2),D4
00001D84                          2379              
00001D84                          2380              ;Print out the value in the address
00001D84  7003                    2381              MOVE.L      #3,D0
00001D86  2204                    2382              MOVE.L      D4,D1
00001D88  4E4F                    2383              TRAP        #15
00001D8A                          2384              
00001D8A  4E75                    2385              RTS
00001D8C                          2386  
00001D8C                          2387  
00001D8C                          2388  *-----------------------------------------------------------
00001D8C                          2389  * Print Instructions for NOP and RTS
00001D8C                          2390  *-----------------------------------------------------------
00001D8C                          2391  printMNOP:
00001D8C  43F9 00001E9E           2392              LEA        printNOP,A1
00001D92  103C 000E               2393              MOVE.B     #14,D0
00001D96  4E4F                    2394              TRAP       #15
00001D98                          2395              
00001D98  6000 F446               2396              BRA        update
00001D9C                          2397  
00001D9C                          2398  printMRTS:
00001D9C  43F9 00001F02           2399              LEA        printRTS,A1
00001DA2  103C 000E               2400              MOVE.B     #14,D0
00001DA6  4E4F                    2401              TRAP       #15
00001DA8                          2402              
00001DA8  6000 F436               2403              BRA        update
00001DAC                          2404  ;-----------------------------------------------------------
00001DAC                          2405  ;ERROR MESSAGES FOR I/O portion
00001DAC                          2406  ;-----------------------------------------------------------
00001DAC                          2407  charError:
00001DAC                          2408              
00001DAC  43F9 00001F68           2409              LEA         invalCh,A1
00001DB2  103C 000E               2410              MOVE.B      #14,D0
00001DB6  4E4F                    2411              TRAP        #15
00001DB8                          2412              
00001DB8  6000 F276               2413              BRA         startingPrompt
00001DBC                          2414            
00001DBC                          2415  oddError:
00001DBC  43F9 00001F89           2416              LEA         odd,A1
00001DC2  103C 000E               2417              MOVE.B      #14,D0
00001DC6  4E4F                    2418              TRAP        #15
00001DC8                          2419              
00001DC8  6000 F266               2420              BRA         startingPrompt
00001DCC                          2421              
00001DCC                          2422  manyCharError:  
00001DCC  43F9 00001FB6           2423              LEA         manyChar, A1
00001DD2  103C 000E               2424              MOVE.B      #14,D0
00001DD6  4E4F                    2425              TRAP        #15
00001DD8                          2426              
00001DD8  6000 F256               2427              BRA         startingPrompt
00001DDC                          2428           
00001DDC                          2429  endGreater:
00001DDC  43F9 00001FF1           2430              LEA         endG,A1
00001DE2  103C 000E               2431              MOVE.B      #14,D0
00001DE6  4E4F                    2432              TRAP        #15
00001DE8                          2433              
00001DE8  6000 F246               2434              BRA         startingPrompt
00001DEC                          2435         
00001DEC                          2436  ;-----------------------------------------------------------
00001DEC                          2437  ;MESSAGES
00001DEC                          2438  ;-----------------------------------------------------------
00001DEC= 57 65 6C 63 6F 6D ...   2439  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001E10= 50 6C 65 61 73 65 ...   2440  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
00001E52= 50 6C 65 61 73 65 ...   2441  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001E92= 0D 0A 41 64 64 72 ...   2442  AddressNum  DC.B        CR,LF,'Address: ',0
00001E9E                          2443  
00001E9E                          2444  ;-----------------------------------------------------------
00001E9E                          2445  ;OPCODE Messages
00001E9E                          2446  ;-----------------------------------------------------------
00001E9E= 4E 4F 50 00             2447  printNOP    DC.B        'NOP',0
00001EA2= 4D 4F 56 45 00          2448  printMOVE   DC.B        'MOVE',0
00001EA7= 4D 4F 56 45 4D 00       2449  printMOVEM  DC.B        'MOVEM',0
00001EAD= 41 44 44 00             2450  printADD    DC.B        'ADD',0
00001EB1= 41 44 44 49 00          2451  printADDI   DC.B        'ADDI',0
00001EB6= 53 55 42 00             2452  printSUB    DC.B        'SUB',0
00001EBA= 53 55 42 49 00          2453  printSUBI   DC.B        'SUBI',0
00001EBF= 4D 55 4C 53 2E 57 ...   2454  printMULS   DC.B        'MULS.W ',0
00001EC7= 44 49 56 55 2E 57 ...   2455  printDIVU   DC.B        'DIVU.W ',0
00001ECF= 4C 45 41 20 00          2456  printLEA    DC.B        'LEA ',0
00001ED4= 41 4E 44 00             2457  printAND    DC.B        'AND',0
00001ED8= 4E 4F 54 00             2458  printNOT    DC.B        'NOT',0
00001EDC= 4C 53 4C 00             2459  printLSL    DC.B        'LSL',0
00001EE0= 4C 53 52 00             2460  printLSR    DC.B        'LSR',0
00001EE4= 41 53 4C 00             2461  printASL    DC.B        'ASL',0
00001EE8= 41 53 52 00             2462  printASR    DC.B        'ASR',0
00001EEC= 42 4C 54 00             2463  printBLT    DC.B        'BLT',0
00001EF0= 42 47 45 00             2464  printBGE    DC.B        'BGE',0
00001EF4= 42 45 51 00             2465  printBEQ    DC.B        'BEQ',0
00001EF8= 42 43 43 20 00          2466  printBCC    DC.B        'BCC ',0
00001EFD= 4A 53 52 20 00          2467  printJSR    DC.B        'JSR ',0
00001F02= 52 54 53 00             2468  printRTS    DC.B        'RTS',0
00001F06= 42 52 41 00             2469  printBRA    DC.B        'BRA',0
00001F0A= 41 53 00                2470  printMAS    DC.B        'AS',0
00001F0D= 4C 53 00                2471  printMLS    DC.B        'LS',0
00001F10= 4C 00                   2472  printL      DC.B        'L',0    
00001F12= 52 00                   2473  printR      DC.B        'R',0
00001F14                          2474  ;-----------------------------------------------------------
00001F14                          2475  ;Size Messages
00001F14                          2476  ;-----------------------------------------------------------
00001F14= 2E 42 20 00             2477  printSIZEB  DC.B        '.B ',0
00001F18= 2E57 2000 0000          2478  printSIZEW  DC.W        '.W ',0
00001F1E= 2E4C2000 00000000       2479  printSIZEL  DC.L        '.L ',0
00001F26                          2480  
00001F26                          2481  ;-----------------------------------------------------------
00001F26                          2482  ;Addressing Mode Messages
00001F26                          2483  ;-----------------------------------------------------------
00001F26= 44 00                   2484  printDRD      DC.B        'D',0
00001F28= 41 00                   2485  printARD      DC.B        'A',0
00001F2A= 28 41 00                2486  printARI      DC.B        '(A',0
00001F2D= 29 00                   2487  printARI2     DC.B        ')',0
00001F2F= 23 00                   2488  printIA       DC.B        '#',0
00001F31= 24 00                   2489  printA        DC.B        '$',0
00001F33= 28 41 00                2490  printPI       DC.B        '(A',0
00001F36= 29 2B 00                2491  printPI2      DC.B        ')+',0
00001F39= 2D 28 41 00             2492  printPD       DC.B        '-(A',0
00001F3D= 29 00                   2493  printPD2      DC.B        ')',0
00001F3F                          2494  
00001F3F= 2C 00                   2495  printComma    DC.B        ',',0
00001F41= 20 00                   2496  printSpace    DC.B        ' ',0
00001F43= 2F 00                   2497  printSlash    DC.B        '/',0
00001F45= 2D 00                   2498  printDash     DC.B        '-',0
00001F47                          2499  
00001F47= 0D 0A 59 6F 75 20 ...   2500  theEnd        DC.B        CR,LF,'You are now ending the program',0
00001F68                          2501  
00001F68                          2502  ;-----------------------------------------------------------
00001F68                          2503  ;ERRORS
00001F68                          2504  ;-----------------------------------------------------------
00001F68= 45 52 52 4F 52 3A ...   2505  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001F89= 45 52 52 4F 52 3A ...   2506  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001FB6= 45 52 52 4F 52 3A ...   2507  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
00001FF1= 45 52 52 4F 52 3A ...   2508  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
00002036= 45 52 52 4F 52 3A ...   2509  sizeError   DC.B        'ERROR: Invalid size instruction',0
00002056= 45 52 52 4F 52 3A ...   2510  invalOpcode DC.B        'ERROR: INVALID OPCODE = ',0
0000206F                          2511  
00002070  4283                    2512              CLR.L       D3     
00002072                          2513  
00002072                          2514  ;-----------------------------------------------------------
00002072                          2515  ;Ending function that ends our program 
00002072                          2516  ;-----------------------------------------------------------
00002072                          2517  ending:
00002072  43F8 1F47               2518              LEA         theEnd,A1
00002076  303C 000E               2519              MOVE        #14,D0
0000207A  4E4F                    2520              TRAP        #15
0000207C                          2521              
0000207C                          2522              END         MAIN  

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1D60
ABSOLUTE            1D3A
ABSOLUTEADDRESSMOVEM  1470
ADD16BITS           1802
ADD32BITS           1844
ADD8BITS            17C0
ADDRESSMODESR       1C4E
ADDRESSNUM          1E92
ARD                 1C92
AREGDONE            100C
ARI                 1CA6
BCCOFFSET           1790
BIT16DISPLACEMENT   17EE
BIT32DISPLACEMENT   1830
BIT8DISPLACEMENT    17B2
BITLOOP             14CE
BITLOOPHELPER       14F8
CHARERROR           1DAC
CHECK               1498
CONTINUE16BITS      1812
CONTINUE32BITS      1854
CONTINUE8BITS       17D0
CONTINUEDIVU        188E
CONVERT             1084
COUNTER             1009
CR                  D
DNDEST              1B56
DNSOURCE            1B7A
DORA                100D
DRD                 1C7E
ENDG                1FF1
ENDGREATER          1DDC
ENDHEX              1004
ENDINDEX            100B
ENDING              2072
ENDINGPROMPT        105C
FINDLIST            1474
FINDLIST2           14A8
FIRSTBIT            1008
GETBITS             11F6
IMDLONG             1D78
IMMEDIATE           1D1A
IMMEDIATECOUNT      19F0
IMMEDIATECOUNT2     1A18
INVALCH             1F68
INVALOPCODE         2056
ISOADDBIT0TO5       12BA
ISOLATEADDRESSBIT0TO5  1B9E
ISOLATEADDRESSBIT6TO11  1338
ISOLATEREGISTERBIT9TO11  1BC4
LETTER              10A8
LF                  A
LISTTOMEM           1402
LOOP                1138
M00                 12E0
M0000               120C
M0100               135E
M0110               16F6
M1000               1872
M1001               189E
M1100               18E2
M1101               1B12
M1110               1956
MADDI               122C
MAIN                1000
MAND                1926
MANYCHAR            1FB6
MANYCHARERROR       1DCC
MAS                 1A8A
MBCC                1750
MBEQ                1780
MBGE                1770
MBLT                1760
MBRA                1740
MEFFECT             1298
MEMAS               1A5C
MEMDIRECTIONSUBROUTINE  1A98
MEMLS               1A64
MEMSHIFT            1A26
MEMSHIFT2           1A44
MEMTOLIST           143C
MJSR                16DE
ML                  1AC4
MLEA                1682
MLS                 1A7C
MMULS               1916
MNOT                16B2
MORECHECKS          10D8
MORECHECKS1         10E4
MORECHECKS2         1106
MOVEM               13C0
MR                  1AB6
MSOURCEDEST         1316
MSUBI               1260
MULSCHECK           1900
NUMBER              10BC
ODD                 1F89
ODDERROR            1DBC
OTHERMODES          1D06
PBYTE               1C24
PD                  1CE6
PDASH               1666
PI                  1CC6
PLONG               1C40
PREV                100E
PRINTA              1F31
PRINTADD            1EAD
PRINTADDI           1EB1
PRINTAND            1ED4
PRINTARD            1F28
PRINTAREG           1610
PRINTARI            1F2A
PRINTARI2           1F2D
PRINTASL            1EE4
PRINTASR            1EE8
PRINTBCC            1EF8
PRINTBEQ            1EF4
PRINTBGE            1EF0
PRINTBLT            1EEC
PRINTBRA            1F06
PRINTCOMMA          1F3F
PRINTDASH           1F45
PRINTDIVU           1EC7
PRINTDRD            1F26
PRINTDREG           15BA
PRINTIA             1F2F
PRINTJSR            1EFD
PRINTL              1F10
PRINTLEA            1ECF
PRINTLSL            1EDC
PRINTLSR            1EE0
PRINTMAS            1F0A
PRINTMLS            1F0D
PRINTMNOP           1D8C
PRINTMOVE           1EA2
PRINTMOVEM          1EA7
PRINTMOVEMSIZE      1C14
PRINTMOVESIZE       1BFC
PRINTMRTS           1D9C
PRINTMULS           1EBF
PRINTNOP            1E9E
PRINTNOT            1ED8
PRINTPD             1F39
PRINTPD2            1F3D
PRINTPI             1F33
PRINTPI2            1F36
PRINTR              1F12
PRINTRTS            1F02
PRINTSINGLE         153E
PRINTSIZEB          1F14
PRINTSIZEL          1F1E
PRINTSIZESUBROUTINE  1BDC
PRINTSIZEW          1F18
PRINTSLASH          1F43
PRINTSPACE          1F41
PRINTSUB            1EB6
PRINTSUBI           1EBA
PSLASH              1674
PWORD               1C32
REGAS               1A6C
REGDIRECTIONSUBROUTINE  1AD4
REGLS               1A74
REGSHIFT            198E
REGSHIFT2           19C6
RL                  1B02
RR                  1AF2
SHIFTEIGHT          1A20
SINGLEAREG          1586
SINGLEDREG          1552
SIZEERROR           2036
SKIPA6              11E8
SKIPCOPY            1D0E
SKIPFIRST           150C
STAHEX              1000
STAINDEX            100A
STARTINGPROMPT      1030
SUB16BITS           1808
SUB32BITS           184A
SUB8BITS            17C6
THEEND              1F47
TIMEPRINT           151C
UPDATE              11E0
USEREA              1E52
USERSA              1E10
WELCOME             1DEC
