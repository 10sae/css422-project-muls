00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/7/2021 6:18:07 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : MULS (Ben, Tensae, Jose, Gabriela)
00000000                             4  * Date       : April 28, 2021
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00001000                             7  MAIN:       ORG         $1000
00001000                             8  
00001000  =0000000D                  9  CR:         EQU         $0D
00001000  =0000000A                 10  LF:         EQU         $0A
00001000                            11  
00001000= 00000000                  12  staHex:     DC.L        $0
00001004= 00000000                  13  endHex:     DC.L        $0
00001008                            14  *-----------------------------------------------------------
00001008                            15  * I/O Implementation
00001008                            16  ;1. Prompt user for start and ending addresses (In hex)
00001008                            17  ;2. User inputs their values
00001008                            18  ;3. Check for errors
00001008                            19  ;        Check to see if hex is too big
00001008                            20  ;        Check to see value doesn't contain G-Z
00001008                            21  ;        Check to see if there are no commas/special chars
00001008                            22  ;        Check to see that starting loc, is before ending loc
00001008                            23  ;        Check to see if value starts at odd mem location
00001008                            24  *-----------------------------------------------------------
00001008                            25              ;Show welcome to user
00001008  43F9 0000115C             26              LEA         Welcome,A1
0000100E  103C 000E                 27              MOVE.B      #14,D0
00001012  4E4F                      28              TRAP        #15
00001014                            29    
00001014                            30  startingPrompt:
00001014                            31              ;Ask the user for the starting hex
00001014  43F9 00001180             32              LEA         userSA,A1
0000101A  103C 000E                 33              MOVE.B      #14,D0
0000101E  4E4F                      34              TRAP        #15
00001020                            35              
00001020                            36              ;Clear the registers in case we had an error
00001020  227C 00000000             37              MOVE.L      #0,A1
00001026  247C 00000000             38              MOVE.L      #0,A2
0000102C  4283                      39              CLR.L       D3
0000102E  4284                      40              CLR.L       D4
00001030  4285                      41              CLR.L       D5
00001032  4286                      42              CLR.L       D6
00001034                            43             
00001034                            44              
00001034                            45              ;Input for the hex (D1 equals number of chars)
00001034  303C 0002                 46              MOVE.W      #2,D0
00001038  4E4F                      47              TRAP        #15
0000103A                            48              
0000103A                            49              ;Moves A1 into A2      
0000103A                            50              ;MOVEA.L     A1,A2
0000103A                            51              
0000103A                            52              ;Makes sure D7 is clear incase we're looping back after an error.
0000103A  4207                      53              CLR.B       D7
0000103C                            54              
0000103C  6000 002A                 55              BRA         convert  
00001040                            56              
00001040                            57  endingPrompt:
00001040                            58              ;D7 is if we're working with the first or second promt, used in the more checks section. 
00001040  1E3C 0001                 59              MOVE.B       #1,D7
00001044                            60              
00001044                            61              ;Ask the user for the ending hex
00001044  43F9 000011C2             62              LEA         userEA,A1
0000104A  103C 000E                 63              MOVE.B      #14,D0
0000104E  4E4F                      64              TRAP        #15
00001050                            65              
00001050                            66              ;Clearing the registers so we can reuse them for the ending address
00001050  227C 00000000             67              MOVE.L      #0,A1
00001056  247C 00000000             68              MOVE.L      #0,A2
0000105C  4286                      69              CLR.L       D6
0000105E                            70  
0000105E                            71              ;Input for the hex (D1 equals number of chars)
0000105E  303C 0002                 72              MOVE.W      #2,D0
00001062  4E4F                      73              TRAP        #15
00001064                            74              
00001064                            75              ;Moves A1 into A2      
00001064                            76              ;MOVEA.L     A1,A2
00001064                            77              
00001064  6000 0002                 78              BRA         convert
00001068                            79  
00001068                            80  convert:    
00001068                            81              ;Check to see if D1 is greater than 6, limiting the address to 6 characters (subject to change)
00001068  B23C 0006                 82              CMP.B       #6, D1
0000106C  6E00 00CE                 83              BGT         manyCharError  
00001070                            84              
00001070                            85              ;See if our counter variable is 0
00001070  B23C 0000                 86              CMP.B       #0,D1
00001074                            87              
00001074                            88              ;This means that we have gone through all the characters
00001074  6700 0046                 89              BEQ         moreChecks
00001078                            90              
00001078                            91              ;Decrement the counter, this means we're about to go through another char
00001078  5301                      92              SUB.B       #1,D1
0000107A                            93  
0000107A                            94              ;Let's move the byte stored at A1
0000107A  1612                      95              MOVE.B      (A2),D3
0000107C                            96              
0000107C                            97              ;If the byte is greater than or equal to hex $40, then it's a letter
0000107C  B63C 0041                 98              CMP.B       #$41,D3
00001080  6C00 000A                 99              BGE         letter
00001084                           100              
00001084                           101              ;If the byte is less than or equal to hex $39, then it's a number
00001084  B63C 0040                102              CMP.B       #$40,D3
00001088  6F00 0016                103              BLE         number
0000108C                           104              
0000108C                           105  letter:
0000108C                           106              ;We do this check to see if the character is greater than or equal 'G'
0000108C  B63C 0047                107              CMP.B       #$47,D3
00001090                           108              ;If so, then display an error and ask the user to enter startingAdd again
00001090  6C00 008A                109              BGE         charError
00001094                           110              
00001094                           111              ;Subtract the Ascii value to convert to hex
00001094  0403 0037                112              SUB.B       #$37,D3
00001098                           113              ;Move the value back to our register
00001098  14C3                     114              MOVE.B      D3,(A2)+
0000109A                           115              
0000109A                           116              ;Shift D5 left to make room for next hex value
0000109A  E986                     117              ASL.L       #4, D6
0000109C                           118              ;Move value to D5
0000109C  DC03                     119              ADD.B      D3, D6
0000109E                           120              
0000109E  60C8                     121              BRA         convert
000010A0                           122             
000010A0                           123  
000010A0                           124  number:          
000010A0                           125             ;We do this check to see if the character is less than or equal to '/'  
000010A0  B63C 002F                126             CMP.B        #$2F,D3
000010A4                           127             ;If so, then display an error and ask the user to enter startingAdd again
000010A4  6F00 0076                128             BLE          charError     
000010A8                           129   
000010A8                           130             ;Check to see if the character is greater than or equal to ':'
000010A8  B63C 003A                131             CMP.B        #$3A,D3
000010AC                           132             ;If so, then display an error and ask the user to enter startingAdd again
000010AC  6C00 006E                133             BGE          charError
000010B0                           134            
000010B0                           135             ;Subtract the Ascii value to convert to hex
000010B0  0403 0030                136             SUB.B        #$30,D3
000010B4                           137             ;Move the value back to our register
000010B4  14C3                     138             MOVE.B       D3,(A2)+
000010B6                           139   
000010B6                           140             ;Shift D5 left to make room for next hex value
000010B6  E986                     141             ASL.L        #4, D6
000010B8                           142             ;Move value to D5
000010B8  DC03                     143             ADD.B        D3, D6
000010BA                           144              
000010BA  60AC                     145             BRA          convert
000010BC                           146   
000010BC                           147            
000010BC                           148  moreChecks:
000010BC                           149              ;Determine if we're going to moreChecks1 or moreChecks2 (if we're on starting or ending address)
000010BC  BE3C 0001                150              CMP.B      #1,D7
000010C0  6700 0028                151              BEQ        moreChecks2
000010C4                           152              
000010C4  6000 0002                153              BRA        moreChecks1
000010C8                           154   
000010C8                           155  moreChecks1:
000010C8                           156              
000010C8                           157              ;Copy the hex value into a temp register
000010C8  2806                     158              MOVE.L      D6,D4
000010CA                           159              
000010CA                           160              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010CA  1A3C 001F                161              MOVE.B      #31,D5
000010CE                           162              
000010CE                           163              ;Shifts 31 bits, isolates last bit. 
000010CE  EBAC                     164              LSL.L       D5,D4
000010D0                           165  
000010D0                           166              ;Shifts it back 31 bit, isolating the last bit. 
000010D0  EAAC                     167              LSR.L       D5,D4
000010D2                           168  
000010D2                           169              ;If the last bit is 1, address was odd, and throw an error. 
000010D2  B83C 0001                170              CMP.B       #1,D4
000010D6  6700 0054                171              BEQ         oddError   
000010DA                           172                          
000010DA                           173              ;Reset address registers.
000010DA  247C 00000000            174              MOVE.L      #0,A2
000010E0                           175              
000010E0                           176              ;Copy the value to our staHex variable
000010E0  21C6 1000                177              MOVE.L      D6,staHex 
000010E4                           178              
000010E4  4286                     179              CLR.L       D6
000010E6  6000 FF58                180              BRA         endingPrompt     
000010EA                           181              
000010EA                           182  moreChecks2:       
000010EA                           183              
000010EA                           184              ;Copy the hex value into a temp register
000010EA  2806                     185              MOVE.L      D6,D4
000010EC                           186              
000010EC                           187              ;Placeholder to shift bits, used for seeing if the address is odd. 
000010EC  1A3C 001F                188              MOVE.B      #31,D5
000010F0                           189              
000010F0                           190              ;Shifts 31 bits, isolates last bit. 
000010F0  EBAC                     191              LSL.L       D5,D4
000010F2                           192  
000010F2                           193              ;Shifts it back 31 bit, isolating the last bit. 
000010F2  EAAC                     194              LSR.L       D5,D4
000010F4                           195  
000010F4                           196              ;If the last bit is 1, address was odd, and throw an error. 
000010F4  B83C 0001                197              CMP.B       #1,D4
000010F8  6700 0032                198              BEQ         oddError   
000010FC                           199                          
000010FC                           200              ;Reset address registers.
000010FC  247C 00000000            201              MOVE.L      #0,A2
00001102                           202              
00001102                           203              ;Place the value in our ending hex variable
00001102  21C6 1004                204              MOVE.L      D6,endHex 
00001106                           205              
00001106                           206              ;Make D7 a temp location to compare our starting hex
00001106  2E38 1000                207              MOVE.L      staHex,D7
0000110A                           208           
0000110A                           209              
0000110A                           210              ;Compare the starting hex, with the ending hex to see if endHex is less than starting        
0000110A  BC87                     211              CMP.L       D7,D6
0000110C  6B00 003E                212              BMI         endGreater
00001110                           213              
00001110                           214              ;done, start reading memory. 
00001110                           215              
00001110                           216              ;Clear all the registers since we have the addresses stored in our variables
00001110  4283                     217              CLR.L       D3
00001112  4285                     218              CLR.L       D5
00001114  4286                     219              CLR.L       D6
00001116  4287                     220              CLR.L       D7
00001118                           221              
00001118  6000 01B6                222              BRA         ending    
0000111C                           223              
0000111C                           224              
0000111C                           225  LOOP:       ;This is going to help us go through each address, and see what the contents are inside it
0000111C                           226  
0000111C                           227              
0000111C                           228              ;staHex = 1, ednHex = F
0000111C                           229              ;for(int i = start; i < end; i++)
0000111C                           230              ;{
0000111C                           231              ;       load the first 16 bits into a  temp register (4 hex values)
0000111C                           232              ;       
0000111C                           233              ;       check for the first 4 left-most bits
0000111C                           234              ;       compare the bits to their corresponding values
0000111C                           235              ;       if hit{
0000111C                           236              ;           00 == MOVE
0000111C                           237              ;           0100 == MOVEM,NOP,LEA,NOT,JSR,RTS
0000111C                           238              ;           0110 == BRA,BLT,BGE,BEQ
0000111C                           239              ;           1000 == DIVU
0000111C                           240              ;           1001 == SUB
0000111C                           241              ;           1100 == MULS,AND,LSL,LSR,ASL,ASR
0000111C                           242              ;           1101 == ADD
0000111C                           243              ;       }
0000111C                           244              ;       else, display the whole value inside the address, Ex. "INVALID OPCODE d: ABCD"  
0000111C                           245              ;    
0000111C                           246              ;}
0000111C                           247  
0000111C                           248  
0000111C                           249  *-----------------------------------------------------------
0000111C                           250  * OpCode Implementation
0000111C                           251  ;
0000111C                           252  *-----------------------------------------------------------
0000111C                           253  
0000111C                           254  ;MOVE
Line 255 ERROR: Illegal symbol
0000111C                           255  00:
0000111C                           256  
0000111C                           257  ;MOVEM,LEA,NOT,JSR
Line 258 ERROR: Illegal symbol
0000111C                           258  0100:        
0000111C                           259              ;First check to see if either RTS or NOP
0000111C                           260              ;Directly compare the hex with the bin # of NOP and RTS
0000111C                           261              ;
0000111C                           262              ;Else, it might be another opcode
0000111C                           263              ;
0000111C                           264              
0000111C                           265  MOVEM:
0000111C                           266  LEA:
0000111C                           267  NOT:
0000111C                           268  JSR:
0000111C                           269     
0000111C                           270  
0000111C                           271  ;BRA,BLT,BGE,BEQ         
Line 272 ERROR: Illegal symbol
0000111C                           272  0110:
0000111C                           273              ;
0000111C                           274  BRA
0000111C                           275  BLT
0000111C                           276  BGE
0000111C                           277  BEQ            
0000111C                           278              
0000111C                           279  ;DIVU            
Line 280 ERROR: Illegal symbol
0000111C                           280  1000:
0000111C                           281  
0000111C                           282  ;SUB
Line 283 ERROR: Illegal symbol
0000111C                           283  1001:
0000111C                           284  
0000111C                           285  ;MULS,AND,LSL,LSR,ASL,ASR
Line 286 ERROR: Illegal symbol
0000111C                           286  1100:
0000111C                           287  
0000111C                           288  MULS
0000111C                           289  AND
0000111C                           290  LSL
0000111C                           291  LSR
0000111C                           292  ASL
0000111C                           293  ASR
0000111C                           294  
0000111C                           295  ;ADD
Line 296 ERROR: Illegal symbol
0000111C                           296  1101:
0000111C                           297  
0000111C                           298  *-----------------------------------------------------------
0000111C                           299  * Addressing Mode Implementation
0000111C                           300  *-----------------------------------------------------------
0000111C                           301  
0000111C                           302  
0000111C                           303  
0000111C                           304  ;-----------------------------------------------------------
0000111C                           305  ;ERROR MESSAGES
0000111C                           306  ;-----------------------------------------------------------
0000111C                           307  charError:
0000111C                           308              
0000111C  43F9 00001202            309              LEA         invalCh,A1
00001122  103C 000E                310              MOVE.B      #14,D0
00001126  4E4F                     311              TRAP        #15
00001128                           312              
00001128  6000 FEEA                313              BRA         startingPrompt
0000112C                           314            
0000112C                           315  oddError:
0000112C  43F9 00001223            316              LEA         odd,A1
00001132  103C 000E                317              MOVE.B      #14,D0
00001136  4E4F                     318              TRAP        #15
00001138                           319              
00001138  6000 FEDA                320              BRA         startingPrompt
0000113C                           321              
0000113C                           322  manyCharError:  
0000113C  43F9 00001250            323              LEA         manyChar, A1
00001142  103C 000E                324              MOVE.B      #14,D0
00001146  4E4F                     325              TRAP        #15
00001148                           326              
00001148  6000 FECA                327              BRA         startingPrompt
0000114C                           328           
0000114C                           329  endGreater:
0000114C  43F9 0000128B            330              LEA         endG,A1
00001152  103C 000E                331              MOVE.B      #14,D0
00001156  4E4F                     332              TRAP        #15
00001158                           333              
00001158  6000 FEBA                334              BRA         startingPrompt
0000115C                           335      
0000115C                           336  ;-----------------------------------------------------------
0000115C                           337  ;MESSAGES
0000115C                           338  ;-----------------------------------------------------------
0000115C= 57 65 6C 63 6F 6D ...    339  Welcome     DC.B        'Welcome to the DASM by Group MULS',CR,LF,0
00001180= 50 6C 65 61 73 65 ...    340  userSA      DC.B        'Please enter your starting hex address (Only uppercase letters)',CR,LF,0
000011C2= 50 6C 65 61 73 65 ...    341  userEA      DC.B        'Please enter your ending hex address (Only uppercase letters)',CR,LF,0
00001202                           342  
00001202                           343  ;-----------------------------------------------------------
00001202                           344  ;ERRORS
00001202                           345  ;-----------------------------------------------------------
00001202= 45 52 52 4F 52 3A ...    346  invalCh     DC.B        'ERROR: Invalid Characters used',CR,LF,0
00001223= 45 52 52 4F 52 3A ...    347  odd         DC.B        'ERROR: Cannot start at odd memory location',CR,LF,0
00001250= 45 52 52 4F 52 3A ...    348  manyChar    DC.B        'ERROR: Cannot have more than 6 characters in the address',CR,LF,0
0000128B= 45 52 52 4F 52 3A ...    349  endG        DC.B        'ERROR: The ending address cannot be less than the starting address',CR,LF,0
000012D0                           350  
000012D0                           351  ending:
000012D0                           352              END         MAIN 

7 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND                 111C
ASL                 111C
ASR                 111C
BEQ                 111C
BGE                 111C
BLT                 111C
BRA                 111C
CHARERROR           111C
CONVERT             1068
CR                  D
ENDG                128B
ENDGREATER          114C
ENDHEX              1004
ENDING              12D0
ENDINGPROMPT        1040
INVALCH             1202
JSR                 111C
LEA                 111C
LETTER              108C
LF                  A
LOOP                111C
LSL                 111C
LSR                 111C
MAIN                1000
MANYCHAR            1250
MANYCHARERROR       113C
MORECHECKS          10BC
MORECHECKS1         10C8
MORECHECKS2         10EA
MOVEM               111C
MULS                111C
NOT                 111C
NUMBER              10A0
ODD                 1223
ODDERROR            112C
STAHEX              1000
STARTINGPROMPT      1014
USEREA              11C2
USERSA              1180
WELCOME             115C
00                  32EBFF4
0100                32EBFF4
0110                32EBFF4
1000                32EBFF4
1001                32EBFF4
1100                32EBFF4
1101                32EBFF4
